[{"title":"(译)为何许多开发者仍然喜欢用Objective-C，而不是Swift","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/SwiftUsageRate/","text":"iOS SDK已经发布很多年了，开发人员纷纷涌向Objective-C，他们力图通过开发会大卖应用程序而获得丰厚的回报。但那样的时代如今已不复存在了：Swift已经面世三年多了，与Objective-C相比，大大地获取了大家的关注度。 Objective-C - 从应用程序开发世界冉冉升起的明星 - 沦为苹果生态系统中的二等公民。即使OC仍然会在WWDC的一两个板块中被提及，但世界各地的大部分会议都在谈论Swift，苹果正努力推动Swift在教育领域的应用，使用Swift作为主要的语言。 但是如果你仍然在使用Objective-C，你并不孤单 - 许多开发者仍然喜欢使用Objective-C相对于Swift，并且有很好的理由。我与一些Objective-C开发者联系，询问他们是否感觉继续使用Objective-C开发会受到指责，下面的内容就是他们不得不说的… 注意：这里表达的意见是个人意见，可能不代表雇主的意见; 人们按照他们回应的顺序列出; 一些回答在长度上进行了变更。 阻止你将Swift作为开发语言的主要原因是什么？史蒂夫·特劳顿 - 史密斯：我有几个原因避免了Swift。 首先，我不喜欢使用它 - 我发现这个语言比ObjC更难阅读和解析，尤其是在循环和switch语句中的if-let变量赋值（这在Apple的体例中是混乱的，像ARKit一样)。我不是尝试各种不同语言为各种平台编写东西的新手，而且Swift绝对是我见到的可读性很低的语言。 我还不相信苹果参与设计这个语言的初衷 - 四年之后，Swift并不用于iOS，OS或框架的重要部分（我在Twitter上保留了苹果公司的Swift应用程序，macOS很少采用它的新特性相对于iOS来说)。我明白为什么会这样（ABI的稳定性等），但如果苹果没有使用Swift，我不明白为什么我需要代表他们进行beta测试。在Swift准备好之前，我没有什么期待，而且在此期间我获得了Objective-C所带来的一切好处。 我完全相信，只是因为苹果建立了一些东西，并说这是前进的道路并不意味着它是正确的选择。 有趣的是，在最初的几年中，我曾经听说过苹果与Swift的任何人分开，苹果公司当然是大量的ObjC开发人员，而Swift对于许多人来说，对我们来说是一个惊喜。 而且我完全相信，只是因为苹果建立了一些东西，并表示这是前进的道路并不意味着它是正确的选择 - 我们已经看到了一大堆错误（DNS 解析服务 discoveryd，iOS 7，iOS 8）或’mehs ‘（macOS，Touch Bar）在过去几年里，而且看到如何摆脱这些不好因素带来的负面影响。 迈克尔·劳尔：我看不到激励。我在Objective-C方面非常有成效，我将语言视为非常优雅，简洁，富有表现力。如果Swift有一流的（异步）并发，我会高兴的跳起来。相比之下，我听说缓慢的编译时间，大量的运行时库重复，我还没有看到运行时性能的显着提升。 丹·莱弗斯：对于技术原型预演Demo或非常小的项目，我将使用Objective-C，纯粹为了在经过相当长的时间（通常可能与这些类型的客户端）之后的易于更新。我还为许多客户保留了Objective-C应用程序，而且没有时间（或将其切换到Swift的理由）。在Swift中构建这样的项目的代码通常会把它当做演示原型的Demo来简单使用。 彼得·莫尔纳尔：在3.0版本之前，我的主要障碍是缺少源代码兼容性，即使4.0之后，我还在等待ABI的稳定性。我认为这是剩下的唯一一个问题，如果源兼容性有效，我个人觉得这对我来说很重要。 托德·托马斯：Xcode对Swift的支持似乎很好笑。从大型项目的愚蠢长编译时间到重构和调试。Tweetbot for Mac是一个相当可观的项目，在2012款的Retina MBP上编译它需要44秒。这包括1个框架，1个库和应用程序本身。此外，Swift的ABI仍然不稳定 - 当我不需要使用我的应用程序包含的所有库被全部缓慢的构建为应用时。 伊恩·麦克道尔：我们有一大堆共享的C++代码，用于我们的业务逻辑，它与Windows和Android共享。我们在Objective-C中的本地UIKit/AppKit中编写我们的UI，并且有很多Objective-C++文件在两种语言之间桥接。至今，除了几个脚本和内部工具之外，我们还没有采用Swift。据使用Swift的其他团队说，编译时间比Objective-C / C ++慢。 我们有数百个Xcode项目，最终编译成一个巨大的静态库，链接到每个应用程序二进制文件。这样做可以减少应用启动时间。我们花费大概6小时流畅的构建我们的应用，不会增加很多时间。 西蒙·沃尔夫：我的主要编码项目是一个客户端，它是一个已经发展了几年的大型代码库。虽然我也会引入一些Swift进去，因为我做的很多工作涉及到编辑现有的代码，它阻止我使用太多Swift。 我也意识到作为一个开发者，每次有一个新的主要版本的Swift的更新，我都会将那些工作中可以用到拿来用，但这不是我真正需要的。 马科·阿门特：对我来说，这不是对Swift本身的判断，而是一个务实的决定：我已经是Objective-C的专家，在使用它方面极富生产力，而切换到Swift的好处并不足以说服我。 马塞尔·维赫尔：我最多的工作包括一些复杂的元编程和 C 进行部分混合的objective - C的动态消息部分。在使用Swift后所有的这些都会变得更加困难，例如，你无法在Swift中编写CoreData。还很纠结：我只是试图找到一些用Swift编写的Apple Pencil示例代码。结果浪费了我一天时间。 你有没有觉得开发人员可能会对使用Objective-C或者在社交媒体上谈论鄙视？史蒂夫·特劳顿 - 史密斯：真的吗？使用ObjC非常不受欢迎，或者说你喜欢ObjC 胜过 Swift。Swift有一个真正大规模的炒作人群，这个是你无法阻止的。 像任何充满激情的球迷一样，没有任何理由参与讨论。 Swift用户与我一样（或更多）了解其缺点，但是由于感知到的好处，他们很乐意做出妥协。我不是，也不觉得同样的好处。 迈克尔·劳尔： 实际上。我觉得我一直在为自己对Objective-C的认同而保卫自己不受外界的干扰。 我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。 丹·莱弗斯：当然，有一个新的和有光泽的驱动器。这最终有多少的iOS社区呢，所以它不是完全不足为奇，仍然存在很多争议。我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。 彼得·莫尔纳尔：当我正在阅读职位和职位描述时，这种感觉更多，不一定在社交媒体上。大家现在正在寻找高级Swift开发人员。 托德·托马斯：我并没有太多的担心。这个应该让应用程序自己来决定。如果它是好的，用户不会在乎它是用什么语言编写的。 伊恩·麦克道尔：对于仍然使用Objective-C，我感觉到一些耻辱，但并不多。 我使用Swift为我的个人项目，并爱上它，并理解我们在工作中不使用它的原因。 西蒙·沃尔夫：有一点，因为我不相信Swift是坏的，Objective-C是一个真正的Cocoa语言，我不会避免对Swift的利弊的热烈争论。我也没有看到人们对Objective-C开发人员太粗鲁，但作为Mac开发人员，我倾向于处于iOS社区的边缘，这可能是大多数冲突的地方。我不认为Mac开发人员很乐意使用最新最好的。我们还在争为NSCell争论(NSTableView中的NSCel)。 马科·阿门特：这已经开始了，但是每个过渡都是这样发生的。Objective-C开发人员为Carbon开发人员开辟了乐趣。这只是一个自然的发展历程，每当你的语言不在当前考虑范围内的，只要你的语言不被视为“进步语言”。但是你仍然以务实的原因使用它。作为网络上的PHP开发人员，我习惯了这一点。 当你看到开发者会议上大多数时间都在讨论Swift的使用时，你的感受是什么？史蒂夫·特劳顿 - 史密斯：毫无感觉，一个只有Swift的会议是对我没有任何影响。在语言还未完善之前，以及苹果尚未大规模使用之前，我并不关心Swift最佳做法或设计模式。我不想整理十几个社区主导的设计模式，我等待苹果对于Swift的进一步完善。 一个只有Swift的会议是对我没有任何影响。 知道Swift是苹果发展的一个真正的“未来”，已经做了很多工作来推动我彻底远离应用程序; iOS 7 UI与Swift一对一转换的冲击让我觉得这不是我想要开发的平台。 迈克尔·劳尔：这是可悲的。当然，我可以翻译我看到的一切，但比以前付出了更多的努力。而且我拒绝在任何要求使用Swift例子的会议上谈论它。幸运的是，还可以参加一些除了Swift之外的会议。 丹·莱弗斯：至少他们大都一致！ 彼得·莫尔纳尔：我认为这是演变的一部分，但它是真实的 - 在Objective-C周围没有太多的吸引力。Swift是新的，由于它不断变化，有很多话要说，显然这些新的话题也在快速过时。 托德·托马斯：我想如果你想要向前看，开发者会议应该谈论Swift。我不介意个人使用Swift，但也不要过度重视会议上对Swift的讨论。 伊恩·麦克道尔：我感觉很好，这是未来！ 西蒙·沃尔夫：我不介意，我意识到Swift是新的闪亮的东西，因为我知道Swift足够好了解它，真的不用担心我。如果我把我的头埋在沙滩上，而不是继续学习Swift，那么我可能会被遗忘，然而我不认为这种做法有利于成为一个好的开发者。 马尔科·阿门特：它不打扰我。大多数会议组织者和与会者都比我做得更紧密，所以当然应该使用Swift。将Swift代码片段从会议，教程和StackOverflow转换为Objective-C，只是继续使用Objective-C的成本之一，迄今尚未证明特别繁重的。 但随着时间的推移，这种转换负担会增加。 马塞尔·维赫尔：我不得不承认，我发现很多Swift的讨论非常肤浅，经常因为不知情而被嘲笑，所以我感到失望。我知道这听起来很苛刻，而且有明显的例外，然而很仍然感到吃惊。 你认为Swift的引入有助于或阻碍Objective-C作为一种语言的发展吗？史蒂夫·特劳顿 - 史密斯：Swift对于Objective-C开发绝对是灾难性的; 对于任何新的API或功能，我不再具有示例代码，WWDC幻灯片，教程，GitHub或StackOverflow。无论StackOverflow千禧年的笑话，但是失去了对所有这些上下文和知识的访问是毁灭性的。在这方面，ObjC语言本身已经获得了一堆生活质量/语法糖功能，以帮助它更好地与Swift进行交互，所有这些都是梦幻般的。 对于Objective-C开发，Swift绝对是灾难性的。 我非常厌恶为了让Swift存活而使ObjC死去 - 如果两种语言可以彼此独立存在，对于像我这样的开发人员来说是非常好的，他们可以选择最适合手头任务的语言。Swift背后的激情，大规模的推广宣传，苹果停止为开发人员创建ObjC资源。 迈克尔·劳尔： 未完待续…… 原文地址Why many developers still prefer Objective-C to Swift","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"Swift","slug":"Swift","permalink":"http://XibHe.github.io/tags/Swift/"}]},{"title":"小程序开发总结","date":"2017-09-24T16:00:00.000Z","path":"2017/09/25/wx-mini-AppSummary/","text":"小程序开发结束已经两天了，这是第一个我参与的小程序项目。回顾开发过程中踩过的种种坑，剖析项目中的痛点，需要优化的地方。以后如何避免这样的问题？是否从此入坑H5了？自己的知识短板是什么？ 之前一直从事iOS开发，对web前端没有过多了解。单凭一腔热血去开发小程序，初识比较迷茫，纠结于html和css的样式，js的数据交互等基础知识。但项目周期短，任务重，需要与pc，平板进行数据同步。就没有太多时间去理会前端基础知识，都是现学现用。 就是产品有些坑，设计的小程序产品原型还是是基于原生App的思维。因此，设计出的UI效果图，页面数据展示效果多数是原生App的效果，有些设计甚至与小程序组件相悖。为了实现与UI设计一致的效果，就需要花费很多时间自定义数据交互组件。 开发时没有完全吃透小程序开发文档，在实现某个功能时一直拿不定主意。以下是踩过的一些坑: 小程序页面路径只能是五层，请尽量避免多层级的交互方式。 页面之间传递数据和变量的方式需要统一，不统一传参方式，一旦出现数据展示问题，会增加调试的难度。 一定要将多次调用的功能或样式封装起来，否则，重复相同功能代码会增加.js文件的代码量，使代码不易读。 使用swiper滑块视图容器时，一定要将滑块控制的页面抽离成单独的页面，放在一个页面中，当处理不同页面的数据交互时，会对其他不相干的页面数据造成干扰。 读取页面定义的变量时，不要忘记使用that关键字，把this对象复制到临时变量that，否则会找不到原来的对象。 wx.showToast吐司，当title文字超出限制，不会自适应宽高，需要自定义弹出框。 注意navigator 组件的几种跳转方式的不同之处。 小程序变量不支持下划线命名，若使用下划线命名会造成变量无法赋值。 避免快速点击，多次触发bindtap事件，造成打开多个相同页面。 小程序写着还是很纠结的，这是内心的真实想法: 一定是上辈子缺德事干多了，这辈子才会被安排写小程序！ 通过这次开发小程序的机会，发现了自己的知识短板，正是这些短板让自己裹足不前。以下是短板高发区: 在哪些工作上花费时间最多? 可以改进的重复性劳动 自己没有完全理解的东西 你回答不出来的面试题 对比以上几点快速找出你的技术短板，然后消除它。你必须要确切知道自己需要学什么，保证焦点正确。不要让这些短板成为你的“痛点”。 我是否陷入了对技术的狂热之中？因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。 人生多艰，无暇他顾。 于是我局限在自己的世界中，变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"总结","slug":"总结","permalink":"http://XibHe.github.io/tags/总结/"}]},{"title":"小程序页面跳转","date":"2017-09-15T16:00:00.000Z","path":"2017/09/16/wx.navigateTo/","text":"微信小程序页面跳转API时需要注意，官方文档中强调：“为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。” 也就是说在连续使用navigateTo进行页面跳转时，若当前页面若正好是第5级，则点击该页面任何绑定触发事件的控件，都不会有任何反应。 更新说明更新记录: 2017 年 9 月，第一版。 2017 年 10 月，增加页面跳转流程图及跳转说明。 小程序中页面导航的API为了避免发生超过五级页面而无法跳转的悲剧，首先要了解清楚小程序中页面导航的API。小程序中页面导航API有五个，两个跳转新页面的API分别为wx.navigateTo和wx.redirectTo，一个用来做重置操作的API为wx.reLaunch，一个用于跳转到tabBar的API为wx.switchTab，还有一个API名为wx.navigateBack，用于返回页面。 wx.navigateBack 在小程序的初始版本中只能回到上一个页面，在最新版本的更新中给 navigateBack 添加了一个参数 delta，用于决定需要返回几层页面，返回的页面数，如果delta大于现有页面数，则返回首页。 几种跳转方式的不同之处navigator 组件的默认跳转方式与 wx.navigateTo 相同，而如果添加 redirect 属性，则与 wx.redirectTo 的跳转方式相同。 navigateTo 在官方文档中描述如下： 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面。 通过 navigateTo 跳转后，可点击左上角的按钮返回上一个页面。而如果多次调用 navigateTo 之后，就需要返回多次才能回到初始页面。因此，官方在此处有一个限制。 注意：为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。 不过上述五层的限制只是针对 navigateTo，redirectTo 则无此限制。因为 redirectTo 的行为是： 关闭当前页面，跳转到应用内的某个页面。 注意: 使用redirectTo跳转到一个之前加载过的页面，不会再次调用该页面的onLoad方法。 通过 redirectTo 跳转后，则无法返回跳转前的页面。但并不是无法调用 navigateBack，而是调用之后，会回到使用 redirectTo 跳转前的上一个页面。 页面栈可以通过 getCurrentPages 方法获取： getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。 上述的「页面路径」可以对应为页面栈中的元素，页面栈中的最后一个元素就是当前显示的页面，页面跳转就是新页面入栈的过程。 上述三种页面 API 的区别在于： navigateTo 不会将旧页面出栈； redirectTo 会将旧页面出栈，再将需要跳转到的页面入栈； navigateBack 则是将页面栈最后一个元素出栈，因此倒数第二个元素会成为最后一个元素，即变成「当前页面」。 结合下面这个例子，如图， 小程序包含 A、B、C、D 四个页面，A 页面为首页。小程序启动后，在 A 页面中，我们通过 navigateTo 跳转到 B 页面，然后在 B 页面中再通过 navigateTo 跳转到 C 页面。 如果通过navigateTo跳转到 D 页面，则在D页面调用navigateBack会返回到C页面；如果通过redirectTo跳转到 D 页面，则在D页面调用navigateBack会发现不是返回C 页面，而是返回到了 B 页面。 因为调用redirectTo 跳转到 D 页面，redirectTo 会将当前页面出栈，即将 C 页面出栈，再将 D 页面入栈，这时候，页面栈中的元素则会变为 A、B、D。 navigateTo 不会将旧页面出栈，因此通过 navigateTo 跳转后，页面栈中元素个数会加一，因此在页面栈中元素个数达到 5 之后再调用 navigateTo 会失败，出现无法跳转的错误。 redirectTo 会在将旧页面出栈后，再将新页面入栈，因此通过 redirectTo 跳转，页面栈中元素个数会保持不变，所以即使在页面栈中元素达到 5 个之后再调用 redirectTo 也能成功跳转。 实际业务流程业务流程:点击主页面的“扫码录入”按钮，页面跳转微信扫一扫页面，通过扫描条形码读取商品信息，若扫码到该商品信息存在数据库中，则获取数据库中的信息并将这些商品信息带至至“商品信息”页面，可以在商品信息页面对商品信息进行编辑。编辑结束后，点击商品信息页面底部的保存按钮，保存该条商品的最新信息。 为了在点击页面底部的“保存”按钮后直接跳转至微信扫一扫页面，达到快速扫码录入商品信息的目的。解决方案: 直接返回主界面，点击“扫码录入”按钮，跳转至微信扫一扫页面； 点击底部“保存”按钮后，立即调用wx.scanCode打开扫一扫页面； 方案1直接被否定了，原因是用户会频繁调用扫一扫进行商品信息的录入。如果在用户录入一天商品信息后，返回到主页面，再一次点击“扫码录入”按钮跳转至扫一扫页面进行商品录入或查询。会使得录入这一操作的连续性被打断，降低录入操作整体流畅度。 方案2在点击保存按钮后直接打开扫一扫固然可以保证操作的连贯性，但此时若在扫一扫页面不做扫码操作，而是点击扫一扫左上角的返回按钮，则返回到上个页面—商品信息保存页面。此时，如果点击“保存”按钮会对商品信息进行重复保存。 那么，能否在微信扫一扫页面做相应处理呢？比如，点击扫一扫左上角的返回按钮时，直接返回到首页。由于扫一扫页面是直接调用wx.scanCode而来的，其并不是以压栈的方式出现在页面控制的层级中。因此，无法通过getCurrentPages()函数获取对应的层级关系。 另外一种方式，针对方案2的问题，需要在点击“商品信息”页的“保存”按钮后做出特别处理，于是在点击保存绑定的事件中设置: saveTap: function (res) { wx.request({ url: requestUrl.LookForGoodsUrl data: { \"userId\": userId, \"goodsId\": numResult, \"name\": name, \"factory\": factory, }, header: { 'content-type': 'application/json' }, success: function (res) { if (res.data.code == '0000') { // 保存成功 wx.redirectTo({ url: '../homePage/homePage' }) } } }) } 将最新商品信息上传至服务器，关闭当前页面，跳转到应用内的某个页面。再调用: wx.scanCode({ var numResult = res.result; if (numResult.substring(0, 2) == '69') { wx.request({ url: requestUrl.LookForGoodsUrl data: { \"userId\": userId, \"goodsId\": numResult, }, header: { 'content-type': 'application/json' }, success: function (res) { if (res.data.state == '1') { // 存在该商品 wx.redirectTo({ url: '../goodsInfo/goodsInfo?goodsChart=' + goodsChart + '&amp;goodsId=' + goodsId, }) } } }) } }) 调用扫一扫，获取商品条码，将获取的条码作为参数上传服务器得到服务器返回的商品信息。再将这些信息传递并跳转至“商品信息”页，展示这些信息。再次扫描商品条码时，重复以上操作。 但是为了在商品信息页面点击“保存”按钮时关闭当前页面，使用了wx.redirectTo，会先返回到首页（homePage），然后再调出扫一扫页面。这期间会出现短暂（大概2~3秒钟）的停顿，停顿期间页面(homePage)仍然可以操作，会误触页面上的其他点击事件。最后，即使在该页面(homePage)加上loading，以防止误触。仍然无法回避短暂停顿后再跳转扫一扫页面的问题。 最后的解决方案是: 点击商品信息页的“保存”按钮后，将该按钮隐藏。这样当从扫一扫页面返回商品信息页时就不会出现重复保存数据的问题了。","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"wx.navigateTo","slug":"wx-navigateTo","permalink":"http://XibHe.github.io/tags/wx-navigateTo/"}]},{"title":"爱之初体验 - 小程序","date":"2017-08-31T16:00:00.000Z","path":"2017/09/01/wx-mini-AppBlindDate/","text":"开发小程序已经有两周了，从最开始踌躇满志到现在喜忧参半。这中间经历了许多波折，好像又回到了第一次初恋时的感觉，迫切，含蓄，喜悦，又苦于不能迅速了解对方的方方面面，而感到沮丧。但随着一步步的接触，由浅入深，终会瓜熟蒂落，水到渠成。 框架小程序由视图层，逻辑层，渲染层三部分组成的一整套框架。框架使用自己的视图层描述语言WXML(.WXML文件中使用的是view标签构建视图，相当于CSS中的div标签。)和WXSS，逻辑层是基于JavaScript框架。视图层和逻辑层间微信提供了用于数据交互，事件绑定的丰富组件和API。 框架的核心是一个响应的数据绑定系统。整个系统分为两块: 视图层(View) 和逻辑层(App Service)。框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会发生相应的更新。 组件框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。什么是组件: 组件是视图层的基本组成单元。 组件自带一些功能与微信风格的样式。 一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。 但使用起来还是有些不足，很多组件的风格与微信风格类似，不想使用这种风格的组件就需要自定义组件，而自定义需要花费一些额外的时间，就算自定义成功了，仍需要经过仔细的测试，确保该自定义组件在交互上不会与基础组件产生偏差。 API框架提供了丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。 说明： wx.on 开头的 API 是监听某个事件发生的API接口，接受一个 CALLBACK 函数作 为参数。当该事件触发时，会调用 CALLBACK 函数。 如未特殊约定，其他 API 接口都接受一个OBJECT作为参数。 OBJECT中可以指定success, fail, complete来接收接口调用结果。开发工具 在原有的公众号网页调试工具的基础上，推出了全新的微信开发者工具，集成了公众号网页调试和小程序调试两种开发模式。 在8月30日和8月31日，对开发工具进行了很大的更新。全新的视觉和交互体验，新增了申请测试报告功能，新增WXS功能。 开发中填的坑微信小程序填坑记录希望对你有帮助。 学习心得 多看官方文档，多看几遍，遇到问题时再看，没有问题时继续看； 关注论坛最新动态； 基础知识一定要过关（小程序的框架，组成部分，运行机制，自身限制）； 不要眼高手低，人家的demo下载下来跑起来，看懂之后一定要自己尝试写一遍； 找一个自己熟悉的逻辑，开始模仿（结合实际的项目需求，一步一步解决遇到的问题）。 遗留问题模态窗体上的textarea多行输入框，当滑动整个页面时，会将textarea里输入的内容一起滑动至输入框外部，随着滑动的方向一起滑动。官方文档中备注了关于textarea的一个tip: textarea组件是由客户端创建的原生组件，它的层级是最高的。 或许正是由于textarea是最高层级导致的滑动问题。 demo下载wxModeList 参考资料微信公众平台 | 小程序 小程序中的循环列表，在点击时改变当前项的背景颜色 小程序操作按钮悬浮固定在底部 动态的显示或隐藏控件 微信小程序从子页面退回父页面时的数据传递","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"初体验","slug":"初体验","permalink":"http://XibHe.github.io/tags/初体验/"}]},{"title":"二次筛选功能开发心得","date":"2017-08-22T16:00:00.000Z","path":"2017/08/23/FilterError/","text":"一个类似于京东搜索结果页的筛选功能，侧边栏条件筛选器，根据不同的数据类型进行条件筛选及筛选条件的排列展示。 构建原理及使用到的技术点 RunTime继承组合 遇到的问题 筛选列表距离顶部状态栏距离过近筛选列表展示选中数量限制替换二次筛选结果页数据源循环移除数组元素报错在筛选更多，跳转的搜索页面进行搜索调用两次接口请求 解决的方式替换二次筛选结果页数据源需求中要求替换筛选条件的数据源,表述如下: 选中的选项需要在二次筛选条件选择页中显示，选中的选项为默认展开的选项时，无需变更选项的位置，若选中的不是默认展开的选项，需要将选中的选项放到二次筛选条件选择页中，并代替筛选条件选择页中没被选择的默认展开的选项的位置，按照选中的时间顺序正序占据页面中的默认展开的选项的位置（举例说明：筛选条件选择页中的默认展开的选项是1、2、3、4、5，默认展开的选项选中的是2和4,然后用户点击查看更多的选项，先选了11然后又选了9的选项,根据逻辑，筛选条件选择页中显示的选项依次显示的是：11、2、9、4、5），若选中的选项被取消选择，选项的位置按照选中时的位置显示，不更改选项的位置。 如图，二次筛选结果页和生产厂家搜索列表页 当生产厂家筛选数据源大于6项时，只展示5个生产厂家，并显示“更多生产厂家 &gt;”的跳转提示。点击跳转至生产厂家搜索列表页面，在搜索页面会根据搜索关键字展示所有的生产厂家列表信息。该列表会展示上个页面勾选的生产厂家，并将其置于列表最前面。现在需要做的是: 当勾选列表页中一个或多个生产厂家，该生产厂家是二次筛选结果页(上一个页面)中，默认展示5个生产厂家中从未出现的一个，是一个新的生产厂家。则需要替换掉二次筛选结果页，生产厂家一栏中未被勾选的一个或多个生产厂家，直到全部替换完成。 方案一: 进行多层嵌套循环遍历，判断如果对象的selected属性为YES，则跳出当前循环并做一个标记，再从新进行外层循环。这样就需要设置至少两个以上的标记在循环遍历的基础之上再进行循环遍历。增加了逻辑判断的复杂性，也使代码变得不易读。 针对方案一不足之处，将方案一中的杂糅在一起的逻辑判断抽离成不同的情况，形成方案二。 方案二: 需要定义两个可变数组，_dataList(二次筛选结果页，生产厂家数据源)，_selectList(生产厂家搜索页，所有勾选的生产厂家数据源)。对二者进行嵌套循环遍历，需要考录到三种不同情况，并对这三种情况进行一一判断。① _dataList全部包含了_selectList中的元素；② _dataList不包含_selectList中的元素；③ _dataList包含部分_selectList中的元素。 针对以上三种情况对应的具体步骤: ① 遍历找到_dataList中的_selectList元素，变更生产厂家Model中selected状态，将这些选中的元素放到_dataList中元素位置的最前面； ② 直接将_selectList插入到_dataList的最前面； ③ 先替换，再插入新元素到_dataList中，最后再将生产厂家Model中selected为YES的元素前置到_dataList的最前面位置。 方案二仍需要进行大量的判断，操作起来仍旧复杂。那么，有没有简单粗暴，提刀就干的方案呢？下面就要说说方案三了。 方案三: 在生产厂家搜索列表页面直接进行操作。在二次筛选结果页点击跳转至生产厂家搜索页时，传入已经选中生产厂家的数组_selectList，生产厂家搜索结果列表页的数据源_datalist(包含当前已选中生产厂家的数组_selectList和所有未选中的生产厂家)。点击”确定“按钮时，去除_datalist中已选中的生产厂家的Model，然后使用block反向将去除后的_datalist和_selectList传给二次筛选结果页。 这样在二次筛选结果页就能直接操作已经处理过的筛选数据了，不用再进行复杂的逻辑判断了。总的来说，这种替换原有页面数据源的操作，以后还是在可以对数据源进行修改的页面进行处理，避免最后需要进行复杂的逻辑判断。 参考文档ZYSideSlipFilter Objective-C NSMutableArray mutated while being enumerated? Collection was mutated while being enumerated","tags":[{"name":"二次筛选","slug":"二次筛选","permalink":"http://XibHe.github.io/tags/二次筛选/"},{"name":"NSArray enumerate","slug":"NSArray-enumerate","permalink":"http://XibHe.github.io/tags/NSArray-enumerate/"}]},{"title":"重构webView页面间跳转逻辑","date":"2017-08-06T16:00:00.000Z","path":"2017/08/07/reconsiderUrlPush/","text":"在处理webView页面内的跳转逻辑时，需要在当前webView中点击某个按钮push到另一个webView页，在这个新的webView页中仍然可以操作页面上的点击事件，跳转到其他webView页面。于是，这些webView页面可以相互跳转，不断跳转新的或者之前的webView页面。 业务需求点击商品进入到“商品详情”页(GoodInforH5WebViewController)，点击店铺进入“店铺详情”页(ShopInfoH5WebViewController)，其中(“商品详情”页和”店铺详情”页均为webView)。其中，店铺详情页和商品详情页可以相互跳转。 当前逻辑在继承于UINavigationController的自定义导航控制器MyNavigationController里做判断，重写方法: - (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated { if (self.viewControllers.count > 0) { if ([self respondsToSelector:@selector(interactivePopGestureRecognizer)]) { self.interactivePopGestureRecognizer.delegate = nil; } viewController.hidesBottomBarWhenPushed = YES; if ([viewController isKindOfClass:[GoodInforH5WebViewController class]] || [viewController isKindOfClass:[ShopInfoH5WebViewController class]]) { viewController.navigationItem.leftBarButtonItem = [UIBarButtonItem itemWithTarget:self action:@selector(backRootViewController) image:@\"navigation_back\" highlightImage:@\"navigation_back\"]; } } [super pushViewController:viewController animated:YES]; } 重写GoodInforH5WebViewController和ShopInfoH5WebViewController的返回事件。即，backRootViewController。在backRootViewController方法里做相应页面的跳转操作。 在GoodInforH5WebViewController页面的viewWillAppear方法里进行页面跳转逻辑的判断。如下: 前方高能预警!!! - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:NO animated:NO]; //[_webView reload]; CLog(@\"self.navigationController.viewControllers count = %ld\",[self.navigationController.viewControllers count]); CLog(@\"self.navigationController.viewControllers = %@\",self.navigationController.viewControllers); // 若是经首页;分类列表页面;订单中心;商业店铺列表页;我的收藏,且viewControllers&lt;5,则设置pop回上一页的标识;商家促销,且viewControllers&lt;5,则设置pop回上一页的标识 if ([_fromWebUrl isEqualToString:@\"home_bussinessUrl\"] || ([_fromWebUrl isEqualToString:@\"assortment_searchByCate\"] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@\"sellOrderCenter_buyOrders\"] || ([_fromWebUrl isEqualToString:@\"My_collectionListUrl\"] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@\"businessShopSearchList_goodInfo\"] || ([_fromWebUrl isEqualToString:@\"ActivityViewController\"] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || ([_fromWebUrl isEqualToString:@\"BusinessPromoteViewController\"] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5)) { [[NSUserDefaults standardUserDefaults] setObject:@\"1\" forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@\"GoodsListViewController\"] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@\"search_searchByKey\"] || [_fromWebUrl isEqualToString:@\"business_shopSearch\"] || ([_fromWebUrl isEqualToString:@\"home_searchVC\"] &amp;&amp; [self.navigationController.viewControllers count] &lt; 6) || [_fromWebUrl isEqualToString:@\"businessShopSearchList_shopInfo\"] || ([_fromWebUrl isEqualToString:@\"home_productDetailUrl\"] &amp;&amp; [self.navigationController.viewControllers count] >= 4) || ([_fromWebUrl isEqualToString:@\"ShopCarListViewController\"] &amp;&amp; [self.navigationController.viewControllers count] >= 4)){ // 从GoodsListViewController跳转至原生商品详情页面;从顶部搜索等页面跳转至原生商品详情页面; 从商业店铺搜索结果列表页跳转,点击返回至self.viewControllers[2]的页面;若是从搜索首页，分类的搜索结果页跳转而来,返回搜索商品列表页;若是从商业店铺列表页跳转而来，则返回到店铺详情的H5页面;从首页商品-->商品详情-->店铺详情-->商品详情，并且viewControllers>=4，则返回店铺详情页;从原生购物车跳转而来,且viewControllers>=4，则返回店铺详情页; [[NSUserDefaults standardUserDefaults] setObject:@\"2\" forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@\"shopInfor_searchVC\"] &amp;&amp; [self.navigationController.viewControllers count] &lt; 7) || ([_fromWebUrl isEqualToString:@\"assortment_searchByCate\"] &amp;&amp; [self.navigationController.viewControllers count] >= 5) || ([_fromWebUrl isEqualToString:@\"My_collectionListUrl\"] &amp;&amp; [self.navigationController.viewControllers count] >= 5) || ([_fromWebUrl isEqualToString:@\"ActivityViewController\"] &amp;&amp; [self.navigationController.viewControllers count] >= 5) || ([_fromWebUrl isEqualToString:@\"GoodsListViewController\"] &amp;&amp; [self.navigationController.viewControllers count] == 5)) { // 若是从商业店铺详情搜索跳转而来;若是从分类列表页跳转而来;若是从我的收藏跳转而来，且viewControllers>=5，则返回店铺详情页面。 [[NSUserDefaults standardUserDefaults] setObject:@\"3\" forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@\"home_searchVC\"] &amp;&amp; [self.navigationController.viewControllers count] >= 6) || ([_fromWebUrl isEqualToString:@\"GoodsListViewController\"] &amp;&amp; [self.navigationController.viewControllers count] >= 6)) { // 从搜索商品列表-->商品详情-->店铺详情-->商品详情,且viewControllers>=6，则返回店铺详情页；从订单详情页-->商品详情-->店铺详情-->商品详情,且viewControllers>=6，则返回店铺详情页； [[NSUserDefaults standardUserDefaults] setObject:@\"4\" forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if ([_fromWebUrl isEqualToString:@\"shopInfor_searchVC\"] &amp;&amp; [self.navigationController.viewControllers count] >= 7) { // 从搜索商品列表-->商品详情-->店铺详情-->商品详情,且viewControllers>=7，则返回店铺详情页。 [[NSUserDefaults standardUserDefaults] setObject:@\"5\" forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else { [[NSUserDefaults standardUserDefaults] setObject:@\"0\" forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } } 这里是通过设置一个名为KPopHomeIndentify的NSUserDefaults对象用于存储navigationController中，当前页面的层级。通过设置一个名为_fromWebUrl的字符串，用于判断是哪个页面跳转而来的。二者结合起来，设置经过GoodInforH5WebViewController页面的返回逻辑。 当触发商品详情页的跳转链接时，需要在webView的shouldStartLoadWithRequest代理方法里做判断，当request的绝对地址中包含店铺详情的路径时，则push到店铺详情页。如下: #pragma mark - UIWebViewDelegate -(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { _absoluteUrl = [request.URL absoluteString]; // push到店铺详情页面 if ([_absoluteUrl rangeOfString:@\"appLink/showBusyInfo?\"].location != NSNotFound) { ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init]; shopInforH5WebVC.webUrl = _absoluteUrl; shopInforH5WebVC.fromWebUrl = _fromWebUrl; [self.navigationController pushViewController:shopInforH5WebVC animated:YES]; return NO; } else { return YES; } } 再回到自定义导航控制器MyNavigationController重写的返回事件中: - (void)backRootViewController { CLog(@\"self.viewControllers = %@\",self.viewControllers); NSString *popIndentify = [[NSUserDefaults standardUserDefaults] objectForKey:KPopHomeIndentify]; UIViewController *viewCtl; if ([popIndentify isEqualToString:@\"0\"]) { viewCtl = self.viewControllers[0]; } else if ([popIndentify isEqualToString:@\"1\"]) { viewCtl = self.viewControllers[1]; } else if ([popIndentify isEqualToString:@\"2\"]) { viewCtl = self.viewControllers[2]; } else if ([popIndentify isEqualToString:@\"3\"]) { viewCtl = self.viewControllers[3]; } else if ([popIndentify isEqualToString:@\"4\"]) { viewCtl = self.viewControllers[4]; } else if ([popIndentify isEqualToString:@\"5\"]) { viewCtl = self.viewControllers[5]; } [self popToViewController:viewCtl animated:YES]; } 同样是结合GoodInforH5WebViewController中设置好的KPopHomeIndentify进行判断。根据KPopHomeIndentify存储的导航控制器中的页面层级，在导航控制器中通过这些层级获取到对应的页面viewController，最后popToViewController到这些页面中。 重构原因看了上面那一片高能预警的代码逻辑，重构原因就不言而喻了。 *逻辑判断复杂，每次新增与商品详情，店铺详情相关页面时，都需要新增一系列对应页面层级的判断逻辑； *给调试造成困难，与商品详情，店铺详情关联的页面很多，需要进行多场景的关联测试； *最重要的一点:每次从商品详情页跳转到店铺详情都需要重新重新alloc一个新的ShopInfoH5WebViewController对象，耗费了很多资源。 重构逻辑通过设置NSUserDefaults存储页面层级方式进行页面跳转的逻辑，不易操纵，并且非常的不合理，也降低了代码的可读性。设想一下，这里之所以明确不同跳转页面在navigationController中的层级关系，是为了返回操作能回退到指定页面。而导致该冗余代码的罪魁祸首是:每次触发商品详情页或店铺详情页的跳转链接时，都会重新alloc一个新的对象。在进行多次跳转操作后，navigationController中控制的层级就会一直增加，若想在pop操作时跳转到指定页面，就必须明确所要跳转页面在导航控制器中的层级。 那接下来的操作就很明确了，首先移除GoodInforH5WebViewController中viewWillAppear里的一堆判断代码；然后，在webView的代理方法shouldStartLoadWithRequest中增加跳转判断，如下: #pragma mark - UIWebViewDelegate -(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { _absoluteUrl = [request.URL absoluteString]; CLog(@\"_absoluteUrl = %@\",_absoluteUrl); // push到商业店铺详情页面 if ([_absoluteUrl rangeOfString:@\"appLink/showBusyInfo?\"].location != NSNotFound) { UIViewController *shopInfoH5WebViewController; for (shopInfoH5WebViewController in self.navigationController.viewControllers) { if ([shopInfoH5WebViewController isKindOfClass:[ShopInfoH5WebViewController class]]) { // addExtractBankCardVCIndex = [self.navigationController.viewControllers indexOfObject:addExtractBankCardVC]; [self.navigationController popToViewController:shopInfoH5WebViewController animated:YES]; break; } else if ([shopInfoH5WebViewController isKindOfClass:[GoodInforH5WebViewController class]]) { ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init]; shopInforH5WebVC.webUrl = _absoluteUrl; shopInforH5WebVC.fromWebUrl = _fromWebUrl; [self.navigationController pushViewController: shopInforH5WebVC animated:YES]; break; } } return NO; } else { return YES; } } 这里遍历navigationController.viewControllers中所有视图控制器。如果存在店铺详情(ShopInfoH5WebViewController)对象类，则直接popToViewController到该控制器中；如果不存在，则alloc一个新的店铺详情(ShopInfoH5WebViewController)，并pushViewController到该页面。 最后仍然需要在自定义导航控制器MyNavigationController重写的返回事件（backRootViewController）中做跳转的逻辑判断。如下: - (void)backRootViewController { CLog(@\"self.viewControllers = %@\",self.viewControllers); // 当前视图控制器 UIViewController *currentVC = [self.viewControllers lastObject]; // 视图控制器的层级 NSInteger currentVCIndex = [self.viewControllers indexOfObject:currentVC]; // 上一个页面的视图控制器 UIViewController *previousVC = self.viewControllers[currentVCIndex - 1]; if ([currentVC isKindOfClass:[GoodInforH5WebViewController class]]) { if ([previousVC isKindOfClass:[ShopInfoH5WebViewController class]]) { [self popToViewController:previousVC animated:YES]; } else { [self popViewControllerAnimated:YES]; } } else if ([currentVC isKindOfClass:[ShopInfoH5WebViewController class]]) { // 其他会跳转到店铺页面视图的跳转逻辑 UIViewController *previoussLastVC; if ((currentVCIndex - 2) >= 0) { previoussLastVC = self.viewControllers[currentVCIndex - 2]; } else { previoussLastVC = [self.viewControllers firstObject]; } if ([previousVC isKindOfClass:[GoodInforH5WebViewController class]] ) { // 我的积分跳转 if ([previoussLastVC isKindOfClass:[OrderDetailsViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 我的收藏 else if ([previoussLastVC isKindOfClass:[MyCollectionViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 分类 else if ([previoussLastVC isKindOfClass:[LonchH5WebController class]] &amp;&amp; [self.viewControllers[0] isKindOfClass:[AssortmentViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 首页，分类搜索结果页 else if ([previoussLastVC isKindOfClass:[SearchResultViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } else { [self popToRootViewControllerAnimated:YES]; } } else { [self popViewControllerAnimated:YES]; } } } 这里通过获取当前页面层级，以及当前页面上一个页面的层级，通过这些层级做相应的跳转操作: 如果当前页面是商品详情页(GoodInforH5WebViewController)，再进一步判断它的上个页面是否为店铺详情页(ShopInfoH5WebViewController)，若是则popToViewController到上个页面，否则直接popViewControllerAnimated； 如果当前页面是店铺详情页(ShopInfoH5WebViewController)，则需要判断当前视图层级是否越界(当前页面层级currentVCIndex不会超过3级，可能会遇到导航控制器中只有1个视图控制器的情况)，这里与商品详情页不同的是:增加了其它会跳转到店铺页面视图的跳转逻辑。需要对这些页面（积分、我的收藏、分类、搜索结果页）的跳转进行判断。 总结事不过三，过则重构!","tags":[{"name":"重构","slug":"重构","permalink":"http://XibHe.github.io/tags/重构/"}]},{"title":"(译)一个给iOS App瘦身的奇怪窍门","date":"2017-07-22T16:00:00.000Z","path":"2017/07/23/One Weird Trick to Lose Size/","text":"流行的社交网络应用程序超过400M。每周更新一次，每年你下载的应用总量接近20G。 自从我们推出了Halide，我们听到的最令人意想不到的赞美就是它的大小。 在11M，我们将在一年内推出较少数据的更新，而不是社交网络应用进行频繁更新。 一个朋友问道：“所以你没有使用Swift。” 毕竟，Swift将其标准库捆绑到你的应用程序中，使应用大小增大。 Halide几乎完全是使用Swift编写的。 我们是怎么做的？ 我们从技术位开始吧。 这里有很多关于如何减少App大小的重要评论。 测量，不要猜从Xcode导出版本构建。 选择“Save for Ad Hoc deployment.”。假设你的应用程序支持app thinning（此时真的应该这样做），请选择“Export for Specific Devices.”。确保选中“ Rebuild from bitcode ”。 你不仅可以获得最终包的大小，还可以获得App Thinning报告。检查你的应用程序包，找到最大存储空间的占用者。 使用 Asset Catalogs将资源保存在资源目录中。当你上传应用程序时，Apple将其分解为特定设备的版本，因此具有2x屏幕的设备不会获得3x资源，反之亦然。 运行 PNG-crush将资源放入目录之前，请运行pngcrush。 根据QA1681，Xcode将自动压缩资源目录之外的PNG资源。 尝试JPEG格式照片由于UI资源格式限制以及PNG格式资源更加精细。这可能构成了你应用程序中大部分资源，但如果你有照片，请尝试使用JPEG格式。这样做会有些压力。 现在进入到一个困难步骤的实现经过这么辛苦的工作，你只能删掉一个100M项目中几M的文件。我不知道如何告诉你，但你需要更少的代码。 选择正确的方式Halide有大概15000行用Swift编写的代码。这包括一个实时视频处理器，一系列自定义控件，以及我们控制AVFoundation的平台。有趣的是我并没有写代码。 通过使用自动布局，我绘制了数千条样板。许多开发人员仍然坚持手工布局。也许他们不明白自动布局，也许他们听到朋友的朋友关于自动布局如何缓慢的言论。（事实并非如此。） 我看到太多的开发人员 - 特别是在大型公司 - 发明内部布局引擎。这简直太疯狂了。当Apple在操作系统上捆绑一个精细的布局引擎时，不要用自己定制的框架来增大应用程序。 我们可以通过删除Interface Builder来减少100k。用户手册和设置几乎完全是具有约束条件的IB。相机UI的高级布置也类似如此。但我们认为短期内开发进度是值得肯定的。 避免Library过大检查许多大型应用程序的包，你会发现几十个第三方框架，大小从100k到几兆。 我不使第三方库。这虽然有点极端，但我们有一个独特的情况。 很多第三方库不具备我们所需要的功能。iOS开发社区拥有大量的JSON映射器，但对于DNG文件的低级操作没有任何意义。 但是我之前提到的视频处理呢？我可以听到你大声喊叫，“GPUImage是可扩展的！你的做法太疯狂了!” 从我对Periscope的堆栈的经验来看，我们看到从GPUImage到内部解决方案的巨大收益。如果实时图像处理不是你业务的一部分，GPUImage就会很好。但是鉴于我们对Halide的长期愿景，以及实时渲染的作用，重要的是能掌控这样的组件。 由于文件太大，我从未引入过GPUImage。但是作为自己疯狂的结果，我避免了在我们的应用程序中捆绑125个未使用的过的滤镜。 PSPDFKit具有相似的成功经验，取代了太大的框架： 我们很高兴地告诉你，使用PSPDFKit 6.8 for iOS，我们重写了数字签名实施的核心，以改进检测，验证和更好的错误报告。因此，我们也设法完全放弃了对OpenSSL的依赖，从而减少了二进制文件的大小。 不要感染 Not-Invented-Here 综合征，有很多理由来避免使用三方库。 不要在分析和A / B测试中浪费资源我们不会使用任何第三方分析或崩溃报告服务。首先，我们不是很乐意将用户数据发送给广告公司。让我们暂停这样的想法。 数据不是免费的。在大型应用中，每个动作都会记录一个分析事件。大型应用程序需要日志记录基础设施 - 唯一标识用户，重复数据删除请求，缓存日志，重试失败等。这些操作都会进行叠加。 A / B测试更糟糕。你的典型社交网络应用程序由于没有人使用而死在的A / B测试上。 我们出于代码膨胀的考虑避免了分析和A / B测试。这只是我们的产品理念。知道太多的数据会扭曲你的想法。你发现自己在优化某个不存在的特殊场景，而不是真的去关注用户实际会不会有这样的需求。 所以我们使用苹果分析。它只是简单的记录，没有任何代码更改。并且免费。它尊重用户的隐私，需要选择加入。我们的选择加入率为32％，这对我们的需求是很好的。 有分析的时间和地点。我们不确定我们的最优价格，所以我们可以在那里进行实验。然而，我们在业务驱动的分析和产品开发之间保持隔离。 你需要一致的目标我们是一个两个人的开发团队。我们通过销售产品赚钱。我们顺其自然的成长。当用户高兴时，他们会向朋友们推荐我们。小应用让我们开心，我们认为用户也很开心。 我们的建议并不能帮助应用程序包很大的App。社交网络通过广告赚钱，广告客户需要详细的分析广告定位。 大型应用程序拥有数百名开发人员，组成数十个团队，每个团队都有独立的季度目标。 你走的越快，你达成的目标越多，你的晋升越有可能。 想想这是可以理解的，“这个三方库节省了我们一个星期的开发时间，但是在我们的应用程序中增加了1M。那么我们的App已经是几百M了，还有其它办法吗？” 大型组织充满带来意想不到后果的合理想法。 据说工程师想得到提升。输送功能不会让你达到目的。建立一个新的布局引擎。该公司甚至获得了工程博客的招聘诱饵。 唯一的解决方案是高层领导宣布：“我们将减少我们的应用程序大小。”不幸的是，科技CEO们不会使用8G的储存空间的iPhone，他们不会生活在网速受限的地区。 这不是一个毫不费力的努力。自从Halide发布以来，我们收到了来自世界各地的大量消息，感谢我们努力保持App的小巧。 减小App安装包大小真的有一个奇怪的伎俩：专注于你的客户。 原文地址One Weird Trick to Lose Size","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"App瘦身","slug":"App瘦身","permalink":"http://XibHe.github.io/tags/App瘦身/"}]},{"title":"第一个父亲节","date":"2017-06-17T16:00:00.000Z","path":"2017/06/18/First-father's-day/","text":"我和妻子是大学同学，在恋爱长跑五年后结了婚。妻子老家不是我们那边的，但是在同一个省，最开始的地域原因，造成了我家人对她的偏见。我们俩克服了种种阻碍，在15年情人节那天领了证。 我们的小孩比计划来的早，妻子一直很期待在猴年能生一个聪明伶俐的猴宝宝。当得知自己要作父亲的那一天，内心感受是复杂的，有期待，也有忐忑。觉得自己没有做好成为一个父亲的准备。伴随着孩子快要出生，我的这种焦虑感越发的明显了。在妻子待产期间，没有全身心的去照顾她，总是把工作中的压力和不快带到家里。终于，在一个周三的早上爆发了…… 最后，还是妻子在妻子的安慰下，我才渐渐平复了自己的心情。 由于老家人和妻子之间的矛盾，再加上我父母都不在老家，不能照顾快要临产的妻子。最终选择在我妻子老家待产。孩子出生那天的凌晨十二点多，那时我并不在妻子身边，电话那头当妻子告诉我小家伙出生了，是个男孩时，我就再也控制不住自己的激动，惊喜，幸福的感情了。当得知妻子由于羊水不足而剖腹产时，听着电话一头，妻子有气无力的声音。当时真想给自己一巴掌，我没有尽到作丈夫的责任，在妻子临盆时不能陪在她身边，给她鼓励，让她安心。还让我岳母，一个50多岁，腿脚不便利的老人家为我妻子跑前跑后，楼上楼下的张罗妻子生产的一切事宜。 像我这样的渣男竟然还有女人给我生孩子，把自己的终身幸福托付给我。我上辈子一定是积了什么大功德了！无法忘记第一次见到小家伙的场景，他紧握着一双小手，眼睛半闭半睁，好奇的打量着周围的一切。虽然我嘴上一直在埋怨小家伙让他妈妈挨了一刀，但心里还是对他充满了怜爱。唯一遗憾的是，陪在她们母子身边的时间太短，不等小家伙满月我就不得不离开她们母子俩，带着不舍与留恋重新投入到工作中。 这次端午节回家，小家伙给了我一个大大的惊喜。刚一见面，盯着看了我半天，然后就用一双小手抚摸我的脸，最后，嘿嘿一笑，扑到我的怀里。那一刻，时间仿佛静止，而我又找到了初恋的感觉[害羞]。这不禁又让我感慨了一番：不能时刻陪在你身边，经历你的成长，听到你第一次喊爸爸。终究是我无法弥补的遗憾。这里不奢望能得到你的原谅，只希望将来的某一天你能理解。成年人的生活里没有容易二字。爱❤你我的小宝贝！ 再过一个多月我们家宝宝就一岁了，这一年来我经历了很多，也成长了很多。感谢妻子的宽容和奉献，她总是迁就我的时不时就发作的小情绪，安慰我，鼓励我，支持我。尽她最大的力量来爱我和儿子。爱❤你我的大宝贝！你和儿子就是我的一切，我的天下无双。","tags":[{"name":"父亲节","slug":"父亲节","permalink":"http://XibHe.github.io/tags/父亲节/"}]},{"title":"《黑客与画家》小记","date":"2017-05-30T16:00:00.000Z","path":"2017/05/31/hacker-and-artist/","text":"郭一刀推荐的一本书，一本关于创业经历，软件开发，个人品味的书。也许是书中的章节相互独立，给我的感觉像是集合了众多的tips。而这些闪光点，或是忠告，或是建议，或者结合了很多事实而形成的结论。读后给我一种醍醐灌顶的感觉，Paul结合自己的创业和开发经历，将计算机编程的本质娓娓道来。全书大致分成三个部分: 解释了什么是黑客，黑客是如何看待这个世界的。 黑客去的成果，这些成果对世界的影响，如何创造财富？用黑客的方法防止垃圾邮件。 黑客心目中完美的编程语言是什么样的，为什么黑客如此执着于设计新的编程语言。 Paul是世界上首个互联网应用程序Viaweb的开发者之一。创建的Viaweb公司后来被雅虎收购，改名为Yahoo!Store。后来Paul成为一名资深的投资人，作为一名成功的创业者同时也是一名熟练使用Lisp语言的专家。他的经历很生动，完美诠释黑客文化的基础和核心。其中是我印象深刻的是一段关于如何促成潜在的买方掏钱收购自己创业公司的论述: 大多数时候，促成买方掏钱的最好办法不是让买方看到有获利的可能，二手让他们感到失去机会的恐惧。对于买家来说，最强的收购动机就是看到竞争对手可能收购你。我们发现这会使得CEO们连夜行动。次强的动机则是让他们担心如果现在不买你，你的高速成长将使得未来的收购耗资巨大，甚至你本身可能变成一个他们的竞争对手。 Paul曾经学习过绘画，绘画是一门艺术性很强，同时需要欣赏者有着相应的鉴赏和审美能力的创作方式。Paul总是能将自己的编程和创业经历与之结合起来，切中要害的指出二者之间的联系。 关于设计者的品味，只要你开始思考这个问题，你就会发现不同的领域对于“美”的理解有着惊人的相似度。优秀设计的原则是许多学科的共同原则，一再反复地出现。 好设计是简单的设计 好设计是永不过时的设计 好设计是解决主要问题的设计 好设计是启发性的设计 好设计通常是有点趣味性的设计 好设计是艰苦的设计 好设计是看似容易的设计 好设计是对称的设计 好设计是模仿大自然的设计 好设计是一种再设计 好设计是能够复制的设计 好设计常常是奇特的设计 好设计是成批出现的 好设计常常是大胆的设计","tags":[{"name":"《黑客与画家》","slug":"《黑客与画家》","permalink":"http://XibHe.github.io/tags/《黑客与画家》/"}]},{"title":"使用JSExport进行JS交互时遇到的一个问题","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/使用JSExport进行JS交互时遇到的一个问题/","text":"在使用JSExport与OC和JS进行通信，遇到一个问题，无法调用JS传递的最新购物车商品数量的交互方法。 解决方法将之前的放在VC里的JS交互方法抽离到单独的一个类中，这个类继承NSObject。不做任何特别的处理，将 JSContext *context = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; context[@\"jsObject\"] = self; 这句代码，从 - (void)webViewDidFinishLoad:(UIWebView *)webView 移到， - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType 该代理方法中，就能每次都调用JS与OC的交互方法。 JavaScriptCore使用注意JavaStript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换，而在回调JavaScript方法的时候最好是在刚开始调用此方法的线程中去执行那段JavaStript方法的代码。 参考文献iOS js oc相互调用（JavaScriptCore）（二）ios 与 js交互一点心得 Demo点击下载 遗留问题这里只有获取购物车最新商品数量时，无法调用JS交互方法，其他的JS交互方法仍然可以调用。那么获取JSContext的时机是什么","tags":[{"name":"JSExport","slug":"JSExport","permalink":"http://XibHe.github.io/tags/JSExport/"},{"name":"JS里通过对象调用方法","slug":"JS里通过对象调用方法","permalink":"http://XibHe.github.io/tags/JS里通过对象调用方法/"}]},{"title":"(译)HTTPS的工作原理","date":"2017-04-26T16:00:00.000Z","path":"2017/04/27/HTTPS/","text":"HTTPS只是标准HTTP协议涂上一层美味的SSL/TLS加密信息。 除非出现严重错误,它可以防止人们因infamous Eve查看或修改那些构成你浏览中产生的请求；让你可以安全的在你的电脑和服务器之间发送密码、通信和信用卡信息等数据。当绿色小挂锁和字母“https”出在你的地址栏时，并不意味你所访问的网站仍是之前的，而不是已经被篡改过的，当你打开网页时这些标识至少帮助你安全地访问网页。 1.什么是HTTPS以及它做了什么?HTTPS是著名的HTTP协议，是在SSL / TLS(以下简称为“SSL”)加密层之上。服务器和客户端仍然通过完全相同的HTTP协议进行通信，但二者的通信是建立在一个安全的SSL连接,加密和解密请求和响应体系之上的。SSL有两个主要目的: 验证你所访问的服务器的正确性 确保你与服务器之间的数据通信，无论是你发送给服务器的还是服务器返回给你的信息不被篡改 真正非常聪明的部分是任何人都可以拦截您与服务器交换的每一个消息，包括您同意使用密钥和加密策略的消息，仍然无法读取任何实际发送的数据。 2.如何建立SSL连接通过握手建立客户端和服务器之间的SSL连接，其目的是: 为了确实与客户端通信服务器的正确性 双方已经同意一个“密码套件”，其中包括二者将用于交换数据的加密算法 双方已就此算法达成任何必要的密钥 一旦连接建立，双方可以使用约定的算法和密钥来安全地发送消息给彼此。我们将把握手分为3个主要阶段 - 发送Client Hello报文，证书交换和密钥交换。 1.客户端发送Client Hello报文 — 握手开始于客户端发送Client Hello报文。这包含服务器通过SSL连接到客户端所需的所有信息，包括各种密码套件及其支持的最大SSL版本。服务器使用Server Hello报文进行响应，报文中包含客户端所需的类似信息，包括根据客户端的偏好决定将使用哪个加密套件和SSL版本。 2.证书交换 — 现在连接已经建立起来了，服务器必须向客户端证明其身份。这是使用SSL证书来实现的，这是一个很小的类似于护照的东西。SSL证书包含各种数据，包括所有者的名称，附加的属性（例如域），证书的公钥，数字签名和有关证书有效期的信息。客户端检查隐式信任该证书，或者它被隐式信任的几个证书颁发机构（CA）之一被验证和信任。更多关于证书的要求。注意服务器还可以要求通过证书证明客户端的身份，但这通常只发生在非常敏感的应用程序中。 3.密钥交换 — 客户端和服务器交换的实际消息数据的加密将使用一种对称算法来完成，该算法在发送Client Hello报文阶段已被认可。对称算法使用单个密钥进行加密和解密，与需要公钥/私钥对的不对称算法相反。双方需要就此单一的对称密钥达成一致，即使用非对称加密和服务器的公钥/私钥可以安全地实现这一过程。 客户端生成用于主对称算法的随机密钥。它使用在发送Client Hello报文阶段中同意的算法和服务器的公钥（在其SSL证书上找到）对其进行加密。它将此加密密钥发送到服务器，使用服务器的私钥对其进行解密，握手会话中有趣部分就这样完成了。双方都充满乐意，如同他们正在和正确的人交谈，并且秘密地同意对对方加密他们即将发送的数据的密钥。HTTP请求和响应现在可以通过对明文消息进行加密后发送。 3.证书3.1信任在最基本的层次上，SSL证书只是一个文本文件，任何具有文本编辑器的人都可以创建一个。实际上，您可以创建一个证书，声称您是Google Inc.，并且你掌握域名gmail.com。如果这是事实，SSL就是一个笑话;身份验证基本上是客户端询问服务器“你是Google吗？”，服务器回复“呃，是的，这是一张纸，’我是Google’写的”，客户说“好，这是我所有的数据”。阻止这场闹剧的魔法是在数字签名中，允许一方验证另一方的纸张是否合法。为什么你可能信任证书有两个明智的原因： 如果它在你隐含信任证书的列表上 如果能够证明它是被上述列表中的一个证书的控制器所信任 第一个标准很容易检查。您的浏览器具有可从其中查看，添加和删除证书颁发机构(CA)可信SSL证书预先安装的列表。这些证书由一个集中的（在理论上，一般在实践中）组织来控制，这些组织非常安全，可靠和值得信赖，如Symantec，Comodo和GoDaddy。如果服务器从该列表中提供证书，那么您可以信任它。 第二个标准很难。服务器很容易说：“er，我的名字是er，来自微软，你信任Symantec和er，他们完全相信我，所以很酷。”一个有点聪明的客户端可能会去问Symantec“我有一个来自微软的服务请求，说你相信他们，这是真的吗？”但即使Symantec说“是的，我们知道他们，微软是合法的”，您仍然不知道声称是Microsoft的服务器实际上真的是微软还是某些入侵者。这时候数字签名该登场了。 3.2数字签名如前所述，SSL证书具有关联的公钥/私钥对。公钥作为证书的一部分分发，私钥被保密。这对非对称密钥用于SSL握手，以交换另一个密钥，供双方对数据加密和解密。客户端使用服务器的公钥加密对称密钥，并将其安全地发送到服务器，服务器使用其私钥对其进行解密。任何人都可以使用公钥加密，但只有服务器可以使用私钥进行解密。 数字签名的情况恰恰相反。证书可以由另一个机构“签署”，从而有效地记录在案，“我们已经证实该证书的控制人也控制证书上列出的属性（域名）”。在这种情况下，权限使用其私钥（广义地说）加密证书的内容，并且该密文作为数字签名附加到证书中。任何人都拥有权限使用公钥对该签名进行解密，并验证其是否为预期的解密值。但只有证书的所有者才能使用私钥加密内容，所以只有所有者才能实际创建一个有效的签名。 因此，如果服务器声称拥有由Symantec（或其他CA）签署的Microsoft.com的证书，那么您的浏览器不需要为此签名。如果是合法的，Symantec将使用（超秘密）私钥来生成服务器的SSL证书的数字签名，因此您的浏览器使用可以使用（超公共）公钥来检查该签名是否有效。Symantec将采取措施确保他们正在签署的组织真正拥有Microsoft.com，因此，鉴于您的客户信任Symantec，可以确定它真的在与微软公司对话。 3.3自签名请注意，所有根CA证书都是“自签名”，这意味着使用自己的私钥生成数字签名的证书。根CA证书没有什么特别之处 — 你可以生成自己的自签名证书，并使用它来签署其他证书。 但是，由于您的随机证书不会作为CA预先加载到任何浏览器的任何地方，所以他们都不会相信你所签署的自己的或他人的证书。你是有效地说“呃，我真的是微软，这里是我自己签发并签署的身份证件”，所有正常运行的浏览器都会弹出一个非常严重的错误信息，以回应你的诡计。 这给所有浏览器和操作系统发行商带来了巨大的负担，只能信任干净的根CAs，因为他们的用户最终信任vet网站并保持证书安全的组织。这不是一件容易的事。 3.4你相信什么？有趣的是，你的客户在技术上并不试图验证是否应该信任发送证书的一方，而是应该信任证书中包含的公开密钥。SSL证书是完全公开和公共的，因此任何攻击者都可以获取Microsoft的证书，拦截客户端对Microsoft.com的请求，并向其提供合法的证书。客户端会接受这一点，并开始愉快地握手。 但是，当客户端加密将用于实际数据加密的密钥时，它将使用该真实证书中的真实的Microsoft公钥进行此操作。由于攻击者没有Microsoft私钥来解密，所以他们现在被终止了。即使握手完成，它们仍然无法解密密钥，因此无法解密客户端向其发送的任何数据。只要攻击者不控制受信任的证书的私钥，正常的秩序就会顺利进行下去。如果客户骗取了受信任的证书，攻击者控制了证书和公钥，那么麻烦就开始了。 4.真的很有趣的事实4.1咖啡店可以通过网络监控我的HTTPS流量吗?不。公钥密码使用方法的魔力意味着攻击者可以观察客户端和服务器之间交换的每一个字节数据，并且仍然不知道你们之间所说的话大致等于多少交换的数据量。然而，你的正常HTTP流量在不安全的Wi-Fi网络上仍然非常脆弱，而且脆弱的网站可能会成为任何数量的解决方案的受害者，这些方法可能会欺骗您通过纯HTTP或在完全错误的地方发送HTTPS流量。例如，即使登录表单通过HTTPS提交用户名/密码组合，如果表单本身通过HTTP安全地加载，那么攻击者可能会在到达您的计算机的途中拦截表单的HTML，在修改后将登录详细信息发送到他们自己的服务器。 4.2我的公司可以通过网络监控我的HTTPS流量吗？如果使用由自己公司控制的机器，那么是可以监控的。请记住，在每个信任链的根源都是一个隐含信任的CA，并且这些权限的列表存储在您的浏览器中。您的公司可以使用他们的机器访问权限，将自己的自签名证书添加到这个CA列表中。然后他们可以拦截您的所有HTTPS请求，提供声称代表相应网站的证书，由他们的假CA签名，因此毫无疑问，您的浏览器信任这些CA签名。由于使用其狡猾的证书的公钥对所有HTTPS请求进行加密，所以可以使用相应的私钥来解密和检查（甚至修改）您的请求，然后将其发送到其预期位置。他们可能不会这样做。但他们可以。顺便提一句，这也是你如何使用代理来检查和修改iPhone应用程序所提供的其他无法访问的HTTPS请求。 4.3那么Lavabit和联邦调查局怎么了？Lavabit是2013年NSA泄漏疯狂期间爱德华·斯诺登（Edward Snowden）的超级安全的电子邮件提供商。正如我们所看到的，无数标准黑客可以允许联邦调查局看到Lavabit和其客户之间的任何数据。没有Lavabit SSL证书的私人密钥，黑客们是不可能监听到这些数据的。然而，一位有益的美国法官告诉Lavaff创始人Ladar Levison，他不得不交出这个钥匙，有效地让联邦调查局自由地监视核心的内容。Levison通过在4点类型的11个硬拷贝页面上交出2,560个字符的键，试图停下来，但是被要求执行一个命令，必须以有用的格式交出私钥，否则将会面对每天5000美元的罚款。一旦他遵守了这个命令，Lavad的CA证书颁发机构GoDaddy就会认为证书被破坏了，就撤销了证书。这将Lavabit证书添加到证书吊销列表（CRL）中，该证书撤销列表（CRL）是客户端不再信任以提供安全连接的可信证书的列表。妥协的结果，自签名或其他不可信任的证书导致浏览器显示一个大的红色错误消息，并且阻止或彻底禁止用户进一步的操作。不幸的是，浏览器将继续信任破坏的证书，直到它们将最新的更新提交给CRL，这个过程在实践中显然是不完美的。 5.结论HTTPS不是不可破解的，SSL协议必须不断发展，因为对其的新攻击一直在快速的发展演化。但是，如果看不到您的消息，那么传输秘密数据的方式仍然是令人印象深刻的方式。当然，这里没有提及许多实现细节，例如握手消息的确切格式和顺序，缩短的握手来接收最近的会话而不必重新协商密钥和密码套件，以及每个阶段可用的许多不同的加密选项。要记住的关键是，尽管HTTPS将数据安全地保护到目的地，但绝对不会对您（作为用户或开发人员），保护您免受XSS或数据库泄漏或任何其他事情造成的严重影响。时刻保持警惕。 在威尔·史密斯的不朽言辞中，“在黑暗中行走，要时刻注意，防止突发的暴力。”。如果你喜欢这片文章，你可能会喜欢我的另一篇文章解释SSL2015年FREAK漏洞的细节。 原文地址How does HTTPS actually work? 参考资料 《图解HTTP》","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://XibHe.github.io/tags/HTTPS/"},{"name":"HTTPS的工作原理","slug":"HTTPS的工作原理","permalink":"http://XibHe.github.io/tags/HTTPS的工作原理/"}]},{"title":"iOS下的图形绘制","date":"2017-04-23T16:00:00.000Z","path":"2017/04/24/Graphics-rendering/","text":"图形绘制iOS系统本身提供了两套绘图的框架，即UIBezierPath 和 Core Graphics。而前者所属UIKit，其实是对Core Graphics框架关于path的进一步封装，所以使用起来比较简单。但是毕竟Core Graphics更接近底层，所以它更加强大。 UIBezierPathUIKit中的UIBezierPath是Core Graphics框架关于path的一个封装。可以创建基于矢量的路径，例如椭圆或者矩形，或者有多个直线和曲线段组成的形状。我们可以用moveToPoint: 和 addLineToPoint:方法去构建。moveToPoint:设置我们想要创建形状的起点。从这点开始，我们可以用方法addLineToPoint:去创建一个形状的线段。我们可以连续的创建line，每一个line的起点都是先前的终点，终点就是指定的点。closePath可以在最后一个点和第一个点之间画一条线段。 - (void)drawRect:(CGRect)rect { UIColor *color = [UIColor colorWithRed:0 green:0.7 blue:0 alpha:1]; [color set]; UIBezierPath* aPath = [UIBezierPath bezierPath]; aPath.lineWidth = 5.0; aPath.lineCapStyle = kCGLineCapRound; aPath.lineJoinStyle = kCGLineCapRound; // 起点 [aPath moveToPoint:CGPointMake(100.0, 0.0)]; // 绘制线条 [aPath addLineToPoint:CGPointMake(200.0, 40.0)]; [aPath addLineToPoint:CGPointMake(160, 140)]; [aPath addLineToPoint:CGPointMake(40.0, 140)]; [aPath addLineToPoint:CGPointMake(0.0, 40.0)]; [aPath closePath];//第五条线通过调用closePath方法得到的 //根据坐标点连线 [aPath stroke]; [aPath fill]; } UIBezierPath+CAShapeLayerCAShapeLayer 继承自 CALayer ，因此，可使用 CALayer 的所有属性。但是， CAShapeLayer 需要和贝塞尔曲线配合使用才有意义。查看官网说明: /* The shape layer draws a cubic Bezier spline in its coordinate space. The spline is described using a CGPath object and may have both fill and stroke components (in which case the stroke is composited over the fill). The shape as a whole is composited between the layer’s contents and its first sublayer.*/ 这里是说 CAShapeLayer 是在其坐标系统内绘制贝塞尔曲线的。因此，使用 CAShapeLayer 需要与 UIBezierPath 一起使用。它有一个 path 属性，而 UIBezierPath 就是对 CGPathRef 类型的封装，因此这两者要配合起来用。 CAShapeLayer与drawRect的关系 drawRect ：属于 CoreGraphics 框架，占用 CPU ，性能消耗大，不建议重写 CAShapeLayer ：属于 CoreAnimation 框架，通过 GPU 来渲染图形，节省性能。动画渲染直接提交给手机 GPU ，不消耗内存这两者各有各的用途，而不是说有了 CAShapeLayer 就不需要 drawRect。温馨提示：drawRect只是一个方法而已，是 UIView 的方法，重写此方法可以完成我们的绘制图形功能。 CAShapeLayer与UIBezierPath的关系 CAShapeLayer中shape代表形状的意思，所以需要形状才能生效 贝塞尔曲线可以创建基于矢量的路径，而UIBezierPath类是对CGPathRef的封装 贝塞尔曲线给CAShapeLayer提供路径,CAShapeLayer在提供的路径中进行渲染。路径会闭环,所以绘制出了Shape 用于CAShapeLayer的贝塞尔曲线作为path，其path是一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线 - (void)viewDidLoad { [super viewDidLoad]; _triangleView = [[UIView alloc] initWithFrame:CGRectMake(screenWidth / 4, 200, screenWidth / 2, screenHeight / 2)]; _triangleView.backgroundColor = [UIColor orangeColor]; [self.view addSubview:_triangleView]; _triangleView.layer.mask = [self createMaskLayerWithView]; } - (CALayer *)createMaskLayerWithView { CGFloat viewWidth = CGRectGetWidth(_triangleView.frame); CGFloat viewHeight = CGRectGetHeight(_triangleView.frame); CGFloat rightSpace = 10.; CGFloat topSpace = 15.; // 起点 CGPoint point1 = CGPointMake(0, 0); // 绘制线条 CGPoint point2 = CGPointMake(viewWidth-rightSpace, 0); CGPoint point3 = CGPointMake(viewWidth-rightSpace, topSpace); CGPoint point4 = CGPointMake(viewWidth, topSpace); CGPoint point5 = CGPointMake(viewWidth-rightSpace, topSpace+10.); CGPoint point6 = CGPointMake(viewWidth-rightSpace, viewHeight); CGPoint point7 = CGPointMake(0, viewHeight); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point1]; [path addLineToPoint:point2]; [path addLineToPoint:point3]; [path addLineToPoint:point4]; [path addLineToPoint:point5]; [path addLineToPoint:point6]; [path addLineToPoint:point7]; [path closePath]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = path.CGPath; return layer; } CoreGraphics这是一个绘图专用的API族，它经常被称为QuartZ或QuartZ 2D。Core Graphics是iOS上所有绘图功能的基石，包括UIKit，Core Graphics是高度集成于UIView和其他UIKit部分，Core Graphics数据结构和函数可以通过前缀CG来识别。 步骤: 1.先在drawRect方法中获得上下文context； 2.绘制图形（线，图形，图片等）； 3.设置一些修饰属性； 4.渲染到上下文，完成绘图。 - (void)drawRect:(CGRect)rect { CGContextRef c = UIGraphicsGetCurrentContext(); CGContextSetRGBStrokeColor(c, 0.0, 0.0, 0.0, 1.0); // black CGContextSetLineWidth(c, 1); CGMutablePathRef bubblePath = CGPathCreateMutable(); // 这里的点是三角形的尖尖 CGPathMoveToPoint(bubblePath, NULL, self.frame.origin.x / 2, self.frame.origin.y); // 其中的一条边的终点 CGPathAddLineToPoint(bubblePath, NULL, 0, self.frame.size.height / 3); // 另一条边的终点 CGPathAddLineToPoint(bubblePath, NULL, self.frame.size.width, self.frame.size.height / 3); CGPathCloseSubpath(bubblePath); CGContextSaveGState(c); CGContextAddPath(c, bubblePath); CGContextClip(c); CGContextSetFillColorWithColor(c, [[UIColor blueColor] CGColor]); CGContextFillRect(c, self.bounds); CGPathRelease(bubblePath); } 注意事项: 1.绘图需要 CGContextRef,CGContextRef即图形上下文。可以这么理解，我们绘图是需要一个载体或者说输出目标，它用来显示绘图信息，并且决定绘制的东西输出到哪个地方。可以形象的比喻context就像一个“画板”，我们得把图形绘制到这个画板上。所以，绘图必须要先有context; 2.并不是说一提到绘图，就一定得重写drawRect方法，只是因为通常情况下我们一般采用在drawRect方法里获取context这种方式。 drawRect方法什么时候触发?当view第一次显示到屏幕上时;当调用view的setNeedsDisplay或者setNeedsDisplayInRect:方法时。 CGContextAddArcToPoint &amp;&amp; CGPathAddArcToPointCGContextAddArcToPoint与CGPathAddArcToPoint这两函数是根据两切线及角度来画弧度,设置弧度CGFloat radius。 画一个四个角都是圆角的矩形, - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. [self drawArcToPoint2]; } - (void)drawArcToPoint2 { //创建CGContextRef UIGraphicsBeginImageContext(self.view.bounds.size); CGContextRef gc = UIGraphicsGetCurrentContext(); //===绘画逻辑 === //创建用于转移坐标的Transform,如许我们不消遵守实际显示做坐标策画 CGAffineTransform transform = CGAffineTransformMakeTranslation(200,200); //创建CGMutablePathRef CGMutablePathRef path = CGPathCreateMutable(); //半径为10 CGFloat radius = 10; //初始点为(10, 0),起点要从10开始，否则，在左上角会出现线条 CGPathMoveToPoint(path, &amp;transform, 10, 0); //右上角和右下角两个点,画出半个圆角 CGPathAddArcToPoint(path, &amp;transform,200, 0, 200, 200, radius); //右下角,画出别的半个圆角 CGPathAddArcToPoint(path, &amp;transform,200, 200, 0, 200, radius); //左下角 CGPathAddArcToPoint(path, &amp;transform,0, 200, 0,0, radius); //左上角 CGPathAddArcToPoint(path, &amp;transform,0, 0, 200, 0, radius); //将CGMutablePathRef添加到当前Context内 CGContextAddPath(gc, path); [[UIColor grayColor] setFill]; [[UIColor blueColor] setStroke]; CGContextSetLineWidth(gc,2); //履行绘画 CGContextDrawPath(gc,kCGPathFillStroke); //从Context中获取图像,并显示在界面上 UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); UIImageView *imgView = [[UIImageView alloc] initWithImage:img]; [self.view addSubview:imgView]; } CAShapedLayer处理理论上我们可以构造出任意想要的形状，但是有些形状如果你不熟悉几何知识的话是构造不出正确path的，从代码上我们可以看到我们可以通过设置CALayer的contents属性来设置显示的内容，那我们是不是可以通过设置CAShapedLayer的contents来设maskLayer呢？答案是肯定的，代码如下： - (void)setup4 { CAShapeLayer *maskLayer = [CAShapeLayer layer]; maskLayer.fillColor = [UIColor blackColor].CGColor; maskLayer.strokeColor = [UIColor clearColor].CGColor; maskLayer.frame = self.bounds; maskLayer.contentsCenter = CGRectMake(0.5, 0.5, 0.1, 0.1); maskLayer.contentsScale = [UIScreen mainScreen].scale; //非常关键设置自动拉伸的效果且不变形 maskLayer.contents = (id)[UIImage imageNamed:@\"gray_bubble_right@2x.png\"].CGImage; CALayer *contentLayer = [CALayer layer]; contentLayer.mask = _maskLayer; contentLayer.frame = self.bounds; [self.layer addSublayer:_contentLayer]; } 遗留问题使用CGPathAddArcToPoint绘制带有箭头的弹窗菜单,如图， 在绘制四个边的圆角时，无法对应到特定的四个角的位置，导致绘制不出该效果的图片。 参考资料 绘图 iOS CAShapeLayer精讲 iOS绘图—— UIBezierPath 和 Core Graphics CGPathAddArc vs CGPathAddArcToPoint CGContextAddArcToPoint与CGPathAddArcToPoint iOS 不规则的ImageView CGPathAddArc vs CGPathAddArcToPoint","tags":[{"name":"图形绘制","slug":"图形绘制","permalink":"http://XibHe.github.io/tags/图形绘制/"},{"name":"UIBezierPath","slug":"UIBezierPath","permalink":"http://XibHe.github.io/tags/UIBezierPath/"},{"name":"CGPathAddLineToPoint","slug":"CGPathAddLineToPoint","permalink":"http://XibHe.github.io/tags/CGPathAddLineToPoint/"},{"name":"CGPathAddArcToPoint","slug":"CGPathAddArcToPoint","permalink":"http://XibHe.github.io/tags/CGPathAddArcToPoint/"}]},{"title":"Harden your mind","date":"2017-03-30T16:00:00.000Z","path":"2017/03/31/Harden-your-mind/","text":"前段时间看了casa的直播《闲话iOS架构》，收看直播时，很多人在聊天里发言询问迅速提高技术有什么捷径?而casa的回答是多想多练。casa直播背景是一个书架，书架上摆满了书，中途一直有人发消息询问大神背后的书架都有什么书？给我最直观的感觉是大家很浮躁，总是想通过一种事半功倍的方式快速摘取成功果实，却忽略了平时的积累，正是这些小的积累，造就大的爆发。 《闲话iOS架构》提到的内容如下: 1.《批判性思维》 2.高效烧脑，低效伤身. 3.protocol,categary 4.注释一般写在垃圾代码那里。剩下的都是代码自注释 5.极致了，怎么保证扩展性?并不矛盾 6.框架ctmater? 7.reactive cocoa 8.APImanager 9.组件化 10.class template 12.OCLink 可以部分review 13.有if就要有else,逻辑上的，思维考虑的对称，不是强制代码必须要这样做 14.以前一直用shell 现在用swift REPL 15.架构的限制是指规范 16.组件化和模块化到底怎么区分，一个东东的不同叫法，实际上应该叫模块化 17.《Cocoa设计模式》 18.如何看待新技术, mvvm，Reactive cocoa，rac 19.没有最全面的技术，只有最合适的技术。 20.CTMediator组件化方案 21.CTNetwokring和YTKNetworking，离散型，集约型 22.codeReview 23.继承的缺点，破坏了代码结构 24.RN,weex 25.复用的东西拆成组件 26.《The Art of Capacity Planning》 27.腾讯开源的Mars,引出大一统和多元化， 28.网易，无埋点打log，网易乐得无埋点数据收集sdk casa所讲的内容多是通过平时代码积累得来的方法论，如果没有一定的代码积累和长期的项目实践是很难彻底理解这些内容的。iOS应用架构看着很高大上，但需要在牢固的基础之上一层层堆砌成高楼。忽视这些必要的步骤，一味粉饰自己，到头来也只是黄粱一梦一场空。再回过头来看目前国内知识付费现象，觉得是一个泡沫。正如知乎上所说，知识付费，抓的不是人的求知欲，抓的是人的焦虑感。人们焦虑，希望有人告诉他们捷径，如何更快的获得成功。这里莫名的想到成功学，成功的永远是成功学的讲师。当代知识产品最大的痛点就是:不看书。 我们急切的接受别人输出的价值观，却选择性的忽略掉自己的内心真正的诉求。书上得来总觉浅，听人道出方觉深，互补的只是不愿意努力看书或是去实践的懒惰。知识经济本质上就是粉丝经济的另一种表现形式。最后，还是想强调一下，作为一名攻城狮通过解决日常遇到的问题，或由浅而深，或发散思维都可以一步步引导至问题的核心。切忌自以为是，舍本逐末。","tags":[{"name":"Harden your mind","slug":"Harden-your-mind","permalink":"http://XibHe.github.io/tags/Harden-your-mind/"},{"name":"知识付费","slug":"知识付费","permalink":"http://XibHe.github.io/tags/知识付费/"}]},{"title":"待办事项提醒功能开发(二)","date":"2017-03-15T09:01:00.000Z","path":"2017/03/15/待办事项提醒功能开发(二)/","text":"新建数据库入库操作界面绘制通知log表注意事项 时间转化的时区设置 最近的本地通知最多只能有64个(待测试) 过期通知的移除(不做移除，通过通知的自有机制去处理的可行性) 生产日期，到期日，保质期天数的交互 奇妙清单的到期提醒只与提醒时间和频率有关，与是否到期无关 iOS 10之后的推送 Demo地址点击下载","tags":[{"name":"待办事项提醒","slug":"待办事项提醒","permalink":"http://XibHe.github.io/tags/待办事项提醒/"},{"name":"开源","slug":"开源","permalink":"http://XibHe.github.io/tags/开源/"}]},{"title":"待办事项提醒功能开发(一)","date":"2017-03-13T14:50:06.000Z","path":"2017/03/13/待办事项提醒功能开发(一)/","text":"业务需求根据用户所添加某件商品的生产日期和保质期天数计算商品的过期日期，在过期前的时间内，用户可以设置提醒的具体时间点和提醒频次，系统根据用户设置的提醒时间和提醒频次通知用户某某商品该使用了。具体操作步骤如下: 新增一个提醒事项的名称，这个名称将作为待完成事项显示在任务列表中，可以快速勾选完成； 在保质期限一栏，点击生产日期一栏，弹出年月日的日期选择器用于日期的选择； 点击保质期天数一栏，弹出用于输入保质期天数的输入控件，保质期单位可以是天，月，年； 如果保质期为30天以内，默认开启智能保质期提醒；如果超过30天，则关闭智能提醒，需要有手动设置结束提醒的具体时间及提醒频率； 在提醒设置一栏，根据生产日期和保质期天数自动计算出到期的具体日期，用户点击时间一栏，弹出时间的选择控件用于选择触发提醒的时间点，用户也可以设置提醒频次； 需要考虑的技术点结合需求需要考虑如下几个问题: 本地通知的运行机制是什么？ 如何自定义通知的频率？ 如何移除到期的通知提醒？ 当用户编辑一个已经存在的提醒任务时，如何根据用户修改后的日期，频率等参数，更新现有的通知提醒频次，触发时间，日期等属性？ 当切换用户或者用户退出登录后，如何操作之前已经添加的通知提醒？ 通知提醒数据的持久化？ 本地通知相关点使用本地通知提醒用户，而本地通知有些地方在使用时需要注意,如下: 1.本地通知是有操作系统统一调度的，只有在应用退出到后台或者关闭才能收到通知；2.本地通知的数量是有限制的，最近的本地通知最多只能有64个，超过这个数量将被系统忽略；3.如果想要移除本地通知可以调用UIApplication的cancelLocalNotification:或cancelAllLocalNotifications移除指定通知或所有通知；4.通知对应的NScalendarunit属性，可以通过该属性操作提醒的频率； NScalendarunit的具体属性如下： typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) { NSCalendarUnitEra = kCFCalendarUnitEra, NSCalendarUnitYear = kCFCalendarUnitYear, NSCalendarUnitMonth = kCFCalendarUnitMonth, NSCalendarUnitDay = kCFCalendarUnitDay, NSCalendarUnitHour = kCFCalendarUnitHour, NSCalendarUnitMinute = kCFCalendarUnitMinute, NSCalendarUnitSecond = kCFCalendarUnitSecond, NSCalendarUnitWeekday = kCFCalendarUnitWeekday, NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, NSCalendarUnitQuarter NS_ENUM_AVAILABLE(10_6, 4_0) = kCFCalendarUnitQuarter, NSCalendarUnitWeekOfMonth NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfMonth, NSCalendarUnitWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfYear, NSCalendarUnitYearForWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitYearForWeekOfYear, NSCalendarUnitNanosecond NS_ENUM_AVAILABLE(10_7, 5_0) = (1 &lt;&lt; 15), NSCalendarUnitCalendar NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 20), NSCalendarUnitTimeZone NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 21), NSEraCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitEra instead&quot;) = NSCalendarUnitEra, NSYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitYear instead&quot;) = NSCalendarUnitYear, NSMonthCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitMonth instead&quot;) = NSCalendarUnitMonth, NSDayCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitDay instead&quot;) = NSCalendarUnitDay, NSHourCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitHour instead&quot;) = NSCalendarUnitHour, NSMinuteCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitMinute instead&quot;) = NSCalendarUnitMinute, NSSecondCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitSecond instead&quot;) = NSCalendarUnitSecond, NSWeekCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekOfMonth or NSCalendarUnitWeekOfYear, depending on which you mean&quot;) = kCFCalendarUnitWeek, NSWeekdayCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekday instead&quot;) = NSCalendarUnitWeekday, NSWeekdayOrdinalCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekdayOrdinal instead&quot;) = NSCalendarUnitWeekdayOrdinal, NSQuarterCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_6, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitQuarter instead&quot;) = NSCalendarUnitQuarter, NSWeekOfMonthCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitWeekOfMonth instead&quot;) = NSCalendarUnitWeekOfMonth, NSWeekOfYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitWeekOfYear instead&quot;) = NSCalendarUnitWeekOfYear, NSYearForWeekOfYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitYearForWeekOfYear instead&quot;) = NSCalendarUnitYearForWeekOfYear, NSCalendarCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitCalendar instead&quot;) = NSCalendarUnitCalendar, NSTimeZoneCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitTimeZone instead&quot;) = NSCalendarUnitTimeZone, }; 步骤说明使用sqlite3进行通知提醒相关数据的持久化。大概的思路如下： 新增提醒任务: 1.插入保质期提醒任务表2.插入通知表3.插入通知log表4.上传服务器通知提醒数据 编辑提醒任务： 1.更新保质期提醒任务表2.更新通知表3.更新通知log表4.上传服务器编辑后的通知提醒数据 需要注意本地通知的官方文档是否有最近的跟新 ，待续……","tags":[{"name":"开源","slug":"开源","permalink":"http://XibHe.github.io/tags/开源/"},{"name":"待办事项","slug":"待办事项","permalink":"http://XibHe.github.io/tags/待办事项/"}]},{"title":"第一次面试别人是怎样的体会","date":"2017-02-25T16:00:00.000Z","path":"2017/02/26/第一次面试别人是怎样的体会/","text":"不安的开始自从去年后半年以来，iOS开发相关工作就被唱衰。很多人抱怨裸辞后找不到工作，可谓是哀鸿遍野。看到了太多这样的帖子，身边也有相识的人遭遇了公司解散，失业后迟迟找不到工作的窘境。这也直接导致了我内心的忐忑和不安，不禁要问，iOS从业者的未来在哪里？我又该何去何从呢？这样的疑问，这样的不安，一直伴随着我。在结合别人的现实的遭遇后，分析了一下造成现阶段初级，中级iOS从业者找工作难的原因: 市场过度饱和，培训机构追求自身利益，在iOS开发人员相对稀缺阶段，培训了大量的从业人员，扰乱了市场正常的供需关系，导致从业人员供大于需； 鱼龙混杂的从业者，很多开发者并不是科班出身，只是听说iOS开发者的薪资待遇高，才决定去培训机构学习，经过四五个月左右的强制灌输和培训机构的包装后，摇身一变成了具有两年开发经验的iOS开发者,其本身不具备计算机专业相关的基础知识； 资本市场资金的收紧，导致流向互联网领域的热钱迅速减少，相比前几年互联网行业的创业潮，很多创业者张口闭口我们是颠覆者，一定会替代某某某，只要嘴炮一番就能忽悠到投资人的钱，今年的资本市场回归了理性。那些没有清晰盈利模式的初创公司迅速倒闭，相关中小互联网公司的用人需求在萎缩； 市场需求的理性回归，很多培训班出身，或者工作年限不足三年，或者是一年工作经验用了三年的初中级开发者满足不了市场上很多公司对于中高级开发者相关的技术要求，于是，被市场无情的淘汰； 行业内薪资待遇的降低，iOS开发已经结束了早期因从业者稀少而造成的市场红利时期，进入到了一个稳步发展的相对稳定时期。因此，薪资待遇回归到了一个正常的水准。那些早期享受到这种红利的开发者，一时间接受不了薪资待遇的降低； 技术层面方面，iOS开发依托苹果提供的平台，该平台的封闭性决定了开发者所接触的技术面比较狭窄，脱离了苹果，不能完全胜任其他技术工作； 我所遇到的一个例子带着这些不安，对于已经结束的16年，我做了一份总结，也包括17年的一些计划。或许是心志不坚，或许是颓废太久，这种不安仍旧存在，直到上周面试了一个来公司应聘iOS开发的应聘者…… 周五下午，人事和我说能不能帮忙面试一下，本来是另一个项目组需要的人，但恰巧他们的负责人不在，就让我去面了。第一次面试别人还是有些紧张，好像自己第一次被别人面试一样紧张。但左等右等还是等不到人事通知我去面试，后来大概半小时后被人事告知那个来面试的人已经走了，据她说面试题只做了一半，人就走了，可能是被我们的面试题吓走了。但面试题我也看过，是四十道很基础的面试题呀！表示不解啊！本以为这次安排的面试就这样结束了，后来人事通知还有一个已经写完了面试题，在沙发区等着，于是我就开始了这次面试之旅。 短暂的两分钟的沉默，我简单看了一下他的简历，上面工作经验写着三年。心里便盘算着从哪些知识点入手可以探出对方是不是真的有三年工作经验。先是让对方做了一个简单的自我介绍，然后开始对着简历问一些问题，简历上写了四个项目，每个项目所用到的技术都是一些大众化的技术，比如，网络请求库AFNetworking，图片加载库SDWebImage，数据库FMDB，刷新库MJRefresh，适配库Masonry等各种三方库的使用。于是我便问了以下的问题: NSOperation与GCD的区别 GCD中如何避免死锁和数据竞争 Block的使用及如何避免循环引用 使用过哪些设计模式 单例，什么是单例，单例的作用 内存管理 网络请求库的使用 JS与原生应用是如何交互的 了解过RunTime吗 通知是异步还是同步 该如何对tableView进行优化，实现滑动的流畅性，以及如何避免tableView代理方法中冗长的代码 SDWebImage的运行机制 App中的多用户逻辑 如何实现一个可以循环滚动的轮播图(类似于京东，淘宝首页顶部效果) 给你一个新项目你会怎么做 是否能看一下你的技术博客或是GitHub上的开源项目 对方对上述问题的回答模棱两可，十分的模糊。其中涉及到GCD那块的问题，只说了用过，GCD的如何避免数据竞争和死锁，以及它与NSOperation的区别只是把什么是NSOperation用名词解释了一下，而对于Block的循环引用问题，支支吾吾想了半天回答的文不对题。设计模式是典型的MVC，倒是提到了MVVM，但这里也只是简单的提到，就没有什么下文了。单例的使用，边想边说，整了半天也没有将声明单例的具体方法说明白。内存管理这块，据他说，学iOS开发时MRC已经没人用了，他就直接用的ARC。JS与原生应用交互这块说没有用过。那么RunTime呢?说是底层的东西没有怎么了解过。tableView的优化方面，说是用的原生API的代理方法，这个还需要优化吗?SDWebImage的运行机制，把它的使用方法说了一遍。App中的多用户逻辑，说是服务器的事，客户端不需要考虑。轮播图功能的实现，说的是使用NSTimer。给你一个新项目你会怎么做，说的是先花一周进行需求分析，再新建工程，使用CocoaPods把那些要用到的三方库引入到工程中。问完了这些问题，我还是抱有一丝幻想的，心想也许是太过紧张了，再看看他做的项目吧！ 看了下对方手机上他参与开发的项目，是一些与美食推荐相关的项目，有一个已经停止维护，拉取不到任何数据了。剩下的都是一些数据使用tableView展示的普通项目，没有什么逻辑特别复杂或是需要使用很高明技术的功能。自此，我仍然没有放弃，心想或许对方还研究过其他的技术点，于是就问对方，是否能看一下你的技术博客或是GitHub上的开源项目。对方回答说，没有。此刻，我也只能道了两声谢谢，说有结果人事会通知你。心里想着，本来还想问有没有使用过Swift，可是现在看来，已经没有问的必要了。 结束 红利已经结束了，那个只要会使用tableView等常用控件就能找到工作的时代结束了。曾听一位前辈说过， “感觉每个做技术的一开始都是一粒沙子，不断修炼学习吸收营养变成大颗粒的沙子。 再学习其他东西把自己变成土块儿，时间是一把大筛子，每次过滤掉小沙粒，只留大块儿在上面，在你被筛掉之前要么变的比网眼大留下来，要么赶紧被筛掉转行吧!” 最后来个总结吧！猥琐发育，别浪！","tags":[{"name":"面试","slug":"面试","permalink":"http://XibHe.github.io/tags/面试/"},{"name":"心得体会","slug":"心得体会","permalink":"http://XibHe.github.io/tags/心得体会/"},{"name":"iOS开发没人要了","slug":"iOS开发没人要了","permalink":"http://XibHe.github.io/tags/iOS开发没人要了/"}]},{"title":"适配器模式初探","date":"2017-02-18T20:23:06.000Z","path":"2017/02/19/适配器模式初探/","text":"初衷解决ViewConctroller里冗余代码过多的问题，将公用模块抽离出来。这里将项目中用到的拍照，调用相册，录像，定位等功能单独抽离出来放在一起。 使用步骤 第一步: 定义一个delegate，用来返回一个遵守该协议的数据，不管传过来的数据是什么类型，只要服从这个协议，实现协议里的方法，就处理这个数据。 @protocol MediaHandleDelegate &lt;NSObject> @optional - (void)returnMedidaData:(id)mediaData; @end 第二步: 创建继承于NSObject的根适配器类MediaHandleAct，该类遵守第一步中的协议，并实现该协议的方法，但只是空实现。 // MediaHandleAct.h #import \"MediaHandleDelegate.h\" @interface MediaHandleAct : NSObject { id &lt;MediaHandleDelegate> _delegate; } // MediaHandleAct.m #import \"MediaHandleAct.h\" - (void)returnMedidaData:(NSString *)data{ } 第三步: 构建根适配器类MediaHandleAct中注册特定Action的方法，并获取注册的Action。 #import &lt;Foundation/Foundation.h> #import \"MediaHandleDelegate.h\" @interface MediaHandleAct : NSObject { id &lt;MediaHandleDelegate> _delegate; } // 动态注册新的Action + (void)registerMediaHandleAction:(MediaHandleAct *)mediaHandleAct andKey:(NSString *) actKey; // 获取注册的Action + (NSDictionary *)mediaHandleActions; // 传递Action的具体执行方法 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass; @end // MediaHandleAct.m #import \"MediaHandleAct.h\" static NSMutableDictionary * mediaHandleActs = nil; @implementation MediaHandleAct + (void)registerMediaHandleAction:(MediaHandleAct *)mediaHandleAct andKey:(NSString *)actKey { @synchronized(self){ if (!mediaHandleActs) { mediaHandleActs = [NSMutableDictionary dictionary]; [MediaHandleAct registerCommonAction]; } [mediaHandleActs setObject:mediaHandleAct forKey:actKey]; } } + (NSDictionary *)mediaHandleActions { NSDictionary * acts = nil; @synchronized(self){ if (!mediaHandleActs) { mediaHandleActs = [NSMutableDictionary dictionary]; [MediaHandleAct registerCommonAction]; } acts = mediaHandleActs; } return acts; } // 具体的执行方法 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass{ } @end synchronized 这个主要是考虑多线程的程序，这个指令可以将{ } 内的代码限制在一个线程执行，如果某个线程没有执行完，其他的线程如果需要执行就得等着。@synchronized 的作用是创建一个互斥锁，保证此时没有其它线程对self对象进行修改。这种机制确保了同一时刻对于每一个类，至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。一般在公用变量的时候使用，如单例模式或者操作类的static变量中使用。 第四步: 针对不同功能的类，创建继承于MediaHandleAct的类适配器。使用适配器的时候，分为类适配器和对象适配器。类适配器针对每一个数据类型或某个功能模块创建一个适配器，并继承于根适配器。 // 调用相册功能 #import &lt;Foundation/Foundation.h> #import \"MediaHandleAct.h\" @interface MediaHandleAlbum : MediaHandleAct @property (nonatomic, assign) NSInteger maxCount; // 最多可添加照片数 // 注册Action + (void)load; @end // MediaHandleAlbum.m #import \"MediaHandleAlbum.h\" #import \"JKImagePickerController.h\" @interface MediaHandleAlbum ()&lt;JKImagePickerControllerDelegate> { UIViewController * _parentController; } @end @implementation MediaHandleAlbum + (void)load { [MediaHandleAct registerMediaHandleAction:[[MediaHandleAlbum alloc] init] andKey:@\"album\"]; } #pragma mark - 拍照和调用相册功能 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass { _parentController = controller; _delegate = (id)callbackClass; UIActionSheet *actionSheet = [[UIActionSheet alloc] initWithTitle:nil delegate:(id)self cancelButtonTitle:nil destructiveButtonTitle:nil otherButtonTitles:@\"拍照\",@\"从相册选择\",@\"取消\",nil]; [actionSheet showInView:_parentController.view]; } #pragma mark - ActionSheetDelegate - (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex { switch (buttonIndex) { case 0: { // 拍照 UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.sourceType = UIImagePickerControllerSourceTypeCamera; picker.editing = YES; picker.allowsEditing = YES; picker.delegate = (id)self; [_parentController presentViewController:picker animated:YES completion:nil]; break; } case 1: { // 调用相册 JKImagePickerController *imagePickerController = [[JKImagePickerController alloc] init]; imagePickerController.delegate = (id)self; imagePickerController.showsCancelButton = YES; imagePickerController.allowsMultipleSelection = YES; imagePickerController.minimumNumberOfSelection = 1; imagePickerController.maximumNumberOfSelection = self.maxCount; //imagePickerController.selectedAssetArray = self.photosView.assetsArray; UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:imagePickerController]; [_parentController presentViewController:navigationController animated:YES completion:NULL]; break; } default: break; } } #pragma mark - UIImagePickerControllerDelegate - (void) imagePickerController: (UIImagePickerController*)picker didFinishPickingMediaWithInfo: (NSDictionary*) info { [picker dismissViewControllerAnimated:YES completion:nil]; UIImage *edit = [info objectForKey:@\"UIImagePickerControllerEditedImage\"]; UIImage *originalImage = [info objectForKey:@\"UIImagePickerControllerOriginalImage\"]; CLog(@\" EditedImage %@ \",NSStringFromCGSize(edit.size)); CLog(@\" OriginalImage %@ \",NSStringFromCGSize(originalImage.size)); UIImage *aImage = edit; NSData * imageData = UIImageJPEGRepresentation(aImage,0.5); if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(returnMedidaData:)]) { NSArray * photos = @[imageData]; [_delegate returnMedidaData:photos]; } } - (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker { [picker dismissViewControllerAnimated:YES completion:nil]; } #pragma mark - JKImagePickerControllerDelegate - (void)imagePickerController:(JKImagePickerController *)imagePicker didSelectAsset:(JKAssets *)asset isSource:(BOOL)source { [imagePicker dismissViewControllerAnimated:YES completion:nil]; } - (void)imagePickerController:(JKImagePickerController *)imagePicker didSelectAssets:(NSArray *)assets isSource:(BOOL)source { [imagePicker dismissViewControllerAnimated:YES completion:nil]; CLog(@\"assets == %@\",assets); NSMutableArray * photos = [[NSMutableArray alloc] init]; for (JKAssets * jkAssets in assets) { NSData * photoData = UIImageJPEGRepresentation(jkAssets.photo, 0.5); [photos addObject:photoData]; CLog(@\"groupPropertyID = %@, groupPropertyURL = %@, assetPropertyURL = %@, photo = %@\",jkAssets.groupPropertyID,jkAssets.groupPropertyURL,jkAssets.assetPropertyURL,jkAssets.photo); } if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(returnMedidaData:)]) { [_delegate returnMedidaData:photos]; } } 第五步: 调用适配器。 MediaHandleAlbum * album = [[MediaHandleAct mediaHandleActions] objectForKey:@\"album\"]; album.maxCount = imageCount; [album performActionWichController:self callbackClass:self]; 适配器模式的优缺点优点: 耦合度低，可以扩展多种不同功能的适配样式。缺点: 代码量相应增多，文件增多。 源码下载地址 注意该Demo中使用调用相机，相册，录制视频的功能，当系统为iOS 10以上访问权限的设置有所不同，需要在工程中的plist文件中添加对应的描述。Demo中的plist，如图， 其他功能访问权限设置， iOS 10 - Changes in asking permissions of Camera, microphone and Photo Library causing application to crash","tags":[{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://XibHe.github.io/tags/设计模式/"},{"name":"适配器","slug":"适配器","permalink":"http://XibHe.github.io/tags/适配器/"}]},{"title":"再见! 2016!","date":"2017-01-15T13:25:10.000Z","path":"2017/01/15/再见！2016/","text":"结婚2016年注定是不平凡的一年，我和花花（我媳妇的外号）在2月14日领的结婚证，这天也是西方的情人节。从这天起我要履行法律赋予我作为一个丈夫的责任和义务。我和花花是大学同学，相识六年，经历了种种磨难和阻力，最终走到了一起。她是我的福星，我的天使，没有花花的鼓励和支持我不敢想象我会变成什么样子。谢谢你包容我的时不时的坏脾气，容忍我的懒散，不思进取，选择和我在一起。承担起本不该属于你的忧愁和压力。我的挚爱，我的血肉。谢谢你一路的陪伴。 生子16年，给了我太多的惊喜和感动。我又办成了人生的另外一件大事—孕育下一代。我们家小宝贝的出生好似给我注入了一剂强心剂，让我感到内心无比的强大。前期的彷徨无措，以及不知该如何适应父亲这个新角色的焦躁不安随着我们家小宝贝的降生，被一扫而空。又是一个给我带来好运的小天使，每每想到小家伙那粉嫩的面庞，心中就为之躁动起来。他的一举一动都牵动着我，同时，也感到肩上的责任越来越重了。我会更加努力为你打下一片大大的疆土。我的小宝贝。 新工作因为种种原因，之前的公司主营业务出现了问题，于是，树倒猢狲散，我又开始了漫长的面试生涯。经过近一个月数十家公司的面试，最终入职了现在的公司。面试时也遇到很多自己之前没有深入去考录的问题，被打了几次脸之后，让我认识到自己的基础并不牢固，很多问题只有肤浅的认知。关于面试这一块的具体内容，需要整理成具体的内容，再发布到博客上，就当给自己提个醒，告诫自己前方还有一段很长的路要走。 新的工作，给我最大的感受就是流程上的统一与协调。在开发新版本前，会走一个需求分析-&gt;原型设计-&gt;需求评审-&gt;UI设计评审-&gt;制定开发计划-&gt;开发计划评审的流程。虽然起初感到繁琐，但对流程的把控可以形成有效的开发计划，掌握开发过程中不同的产出环节，随着对流程的适应以及团队磨合，最终这个流程的时间也会缩短。最重要的是当项目延期或是需求出现问题，可以追溯到流程中那个环节出现了问题。 刚接手现在正在做的这个项目时，觉得很烫手。不仅要面对开发进度的滞后，还要提防项目中随时可能出现的一些无以名状的Bug。觉得自己一个人有些力不从心，但又不得不咬牙顶上去。最终，通过不断加班加点的赶进度，不断的理解产品需求，迈过了这个坎。反而很享受这样解决问题的畅快，为自己以后填更大的坑积累的初始的经验。经过这五个多月的不断历练，最大的收货是：自己慢慢能把控好一个项目了。由最初的慌张，苦闷，到现在可以坦然的面对这些问题。在项目中对自己的要求更加严格了，对产品性能方面，有了一个基本的认识，并开始着手做一些性能上的优化工作。 家庭这半年时间，加班比较多，这就导致了陪在家人身边的时间少了很多。起初，我觉得我是在履行我养家糊口的责任，从这一点出发是无可厚非的。但事实上，我的家人更需要我的陪伴，我不能陪伴小家伙一天天的成长，是我作为父亲最大的遗憾；我不能换位思考，体谅我妻子带孩子的艰辛，是我作为丈夫的不称职。曾听说过一句话：把家当做事业来经营，把事业当做家来爱。如果真正做到了这句话所说的那样，那么家庭与工作二者之间就会找到平衡点，一切的矛盾将会迎刃而解。同时，沟通的不及时也会加剧这种矛盾，所以，今年无论工作再忙也要抽出时间关心下我的妻子和儿子，让她们能感受到我对她们的爱。 读书16年初，1月份读了一刀推荐的 《把时间当做朋友》 ，尝试从心智层面上控制自己，告别拖延症。开始尝试制定每个月的工作学习计划。4月初读了一刀推荐的 《Effective Objective-C 2.0:编写高质量iOS与OS X代码的52个高效方法》和 《Objective-C高级编程:iOS与OS X多线程和内存管理》 对编写高质量的代码，提高代码质量有了初步的了解，对线程底层实现的原理有了一个大概的轮廓。但看这两本书时，太着急了些，未能将书中的精髓全部掌握，同时，也遗留了很多一知半解的问题。今年计划再拿出半个月的时间回顾一下这两本书中未搞懂的内容。五月中旬看了 《GitHub入门与实践》 一书，书的内容很简单，浅显的讲了一下GitHub的原理和流程，如果想进一步了解Git的详细使用及具体操作，可以看Pro Git，GitBook上已经有第二版简体中文的翻译了。六月份还看了 &lt;&gt; 一书，不过是跳着看的，跳过了那些自己已经掌握的内容，看后，对现有知识进行了一些拓展。双十一的时候，在网上买了几本书，如下： 《传习录》 《编程珠玑》 《人类简史》 《软技能:代码之外的生存指南》 《Head First设计模式(中文版)》 《啊哈!算法》 《图解HTTP》 《黑客与画家》 这几本书里有之前听别人说起过的，也有一刀推荐的。这几本书中 《软技能:代码之外的生存指南》， 《啊哈!算法》， 《图解HTTP》这三本书已经看了有些日子了。这些书有些是对现有知识的拓展和升华，打破我固有的思维，有的是个人喜好。读书的时间，开始时是早上在公交车上看，有时看某一本书看得厌烦了，就换另一本书看。个人觉得看纯技术书籍时，可以根据自己的口味搭配一本非技术的书籍来一起读，这样可以缓解因长期看一本书而造成的疲劳和厌烦。 以前认为读书的时间是千方百计的挤出来的，现在看来这样的想法有失偏颇。当我想偷懒，放松下来时，或是想玩手机时，就在心里告诫自己用这些时间来看书，反复这样几次后，竟然发现在这些时间内，比我千方百计挤出来的时间看的书还多。看来平时的时间都被浪费在了这些琐碎，无意义的事情上了。 博客关于博客，16年初开始写，一直到7月份才写了第二篇文章，全年只写了7篇文章。很多想写的东西，都只是被记录下来，并没有梳理成一篇文章，最后，都化作了尘埃，消失不见了。最开始时，想着什么都往博客上写，但那样纯粹是为了凑字数，可读性并不强。浪费了自己的时间，也对读这篇博客的人造成了困扰。到后来，太过于浅显东西没有写的必要，未经深入研究的东西，或是从别处直接复制粘贴别人的观点。这些都不是在写博客，而是在记流水账。因此，给自己定下了一个三不写的要求: 所描述的内容，逻辑不清，不写 没有经过自己验证过的内容，不写 对别人没有帮助，只是在记流水账的内容，不写 2017年会继续坚持写博客，写那些真正经过自己深入研究过的东西，写那些日常项目中真正遇到并最终解决的问题，写对自己对别人有用的东西。只有这样才能提高文章的质量，付出的时间才能得到最大化的利用。 新技术16年8月初，学习了最新的Swift 3.0，当然，现在最新的是Swift 3.01。从官网下了The Swift Programming Language(Swift 3.01)，通过官网下载时会跳转到iBooks，但由于一些众所周知的原因，iBooks中国区是无法下载的，需要使用美区账号登录iBooks。可以结合极客学院Wiki简体中文翻译看。目前，自己只看到了 Functions 这章，17年还需要继续学习剩下的部分，再使用Swift编写一个具体的项目。17年计划学习一些热更新的技术，并计划在自己做的项目中使用一种热更新技术，实现动态化的修改项目中的代码。17年，希望自己能在iOS之外，能入门一种新的技术，拓宽自己的视野，达到自己心中设定的新的高度，看到之前看不到风景。 挑战17年是公司发展历程中重要的一年，也是我所在项目组所开发的项目大范围推广的一年，我们将迎来更多的用户，更大的并发量，会根据市场反应快速迭代产品。我们渴望在项目中使用新的技术，不断的提高用户体验，同时，又能不影响项目上线时间。希望我们产品被更多的人使用，得到大家的认可。同时，希望我们团队 永远年轻，永远热泪盈眶。","tags":[{"name":"2016","slug":"2016","permalink":"http://XibHe.github.io/tags/2016/"},{"name":"年终总结","slug":"年终总结","permalink":"http://XibHe.github.io/tags/年终总结/"}]},{"title":"调试蓝牙扫码枪遇到的问题","date":"2016-12-06T10:31:54.000Z","path":"2016/12/06/iOS蓝牙开发简介  /","text":"iOS蓝牙开发简介蓝牙 4.0出现之前，蓝牙 2.0时只有iOS设备和苹果认证的MFI设备才可以被iOS设备检索到。蓝牙 4.0之后（硬件要4S，系统要iOS6以上才支持蓝牙 4.0），苹果开放了BLE(蓝牙4.0以低功耗著称，所以一般被称为BLE（bluetooth low energy））通道，没有MFI认证的蓝牙设备也可以连接非越狱的iOS设备了。 总结了一下，一共有五种方式可以实现蓝牙通信: 使用MFI认证的蓝牙模块的蓝牙产品 —— 开发使用ExternalAccessory框架，如果你的蓝牙模块还没设计，打算在AppStore上发布，打算使用蓝牙4.0以下（IOS设备都兼容），那你就抓紧找MFI认证的蓝牙模块吧。 使用苹果提供的CoreBluetooth framework框架 —— 只适用于支持蓝牙4.0的设备，无需越狱，无需使用MFI，可以发布在AppStore上。 GameKit framework —— 只能在iOS设备之间同一个应用内连接，从iOS7开始过期了，通过蓝牙可以实现文件的共享（仅限设备沙盒中的文件），此框架一般用于游戏开发（比如五子棋对战）。 Private API —— 使用私有API的应用程序不被允许在AppStore上发布。 Jailbreak 这里我使用的是第二种方式 —— CoreBluetooth。 核心概念CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类。 CBCentralManager：中心设备（用来连接到外部设备的管家） CBPeripheralManager：外部设备（第三方的蓝牙4.0设备） 这两组api分别对应不同的业务场景，左侧叫做中心模式，就是以你的app作为中心，连接其他的外设的场景，而右侧称为外设模式，使用手机作为外设别其他中心设备操作的场景。 服务和特征，特征的属性(service and characteristic):每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。 外设、服务、特征间的关系 连接测试检测蓝牙设备的连接强度，查询一定范围内的蓝牙设备列表。可以通过一款名为LightBlue的手机端软件来确定。在开启蓝牙的状态下，打开LightBlue搜索到当前范围内的设备列表，可以点击查看当前设备的UUID以及特征和服务的UUID，如图， 连接蓝牙扫码枪项目中需要连接蓝牙扫码枪，通过扫码枪扫描商品的条码，将得到的条码值传给终端设备。终端设备根据该条码值搜索该商品的全部信息。iPad开启蓝牙，通过设置蓝牙扫描枪，连接上iPad，但发现在调试状态下，并没有调用CBCentralManager的代理方法。使用LightBlue搜索当前范围内的蓝牙设备，无法找到当前连接到iPad上的蓝牙扫描枪。蓝牙扫描枪使用的是富立叶（cilico）ci6800这款。最后，看了产品说明，发现它的蓝牙模块是蓝牙2.0 + EDR。而不是最新的蓝牙4.0。在未做任何处理的情况下，iPad端任然可以所接收到扫码枪扫描条码后的到的码值。原来是扫码枪默认开启了HID模式，在该模式下iPad默认当前通过蓝牙连接的扫码枪为一个外接键盘，因此扫描后得到码值相当于通过敲击键盘输入。 这样也造成了一个问题，iPad上所有带有输入功能的操作，都无法通过点击输入框弹出软键盘。因为系统会将扫码枪当做键盘，所有软键盘的弹出或者隐藏都是通过扫码枪做操作。但事实上扫码枪并不能控制键盘的弹出。通过google找到了一种据说是可以解决该问题的方法点击查看。但该方法极不稳定，当扫码枪的连接状态在休眠/唤醒两种状态下来回切换时就会失效。偶尔会成功弹出键盘。 最后，在联系厂家需求帮助无果的情况下，不得不停止了该款扫码枪的适配。 连接蓝牙血压计为了验证自己的代码没有问题，是由于蓝牙扫码枪的蓝牙模块版本过低不支持CoreBluetooth。我又找来了一台据说支持蓝牙4.0的蓝牙血压计做测试。 代码实现的步骤 第一步，创建CBCentralManager。第二步，扫描可连接的蓝牙外设（必须在蓝牙模块打开的前提下）。第三步，连接目标蓝牙外设。第四步，查询目标蓝牙外设下的服务。第五步，遍历服务中的特性，获取特性中的数据或者保存某些可写的特性，或者设置某些特性值改变时，通知主动获取。第六步，在通知更新特性中值的方法中读取特性中的数据（再设置特性的通知为YES的情况下）。第七步，读取特性中的值。第八步，如果有可写特性，并且需要向蓝牙外设写入数据时，写入数据发送给蓝牙外设。 引入 CoreBluetooth头文件 #import &lt;CoreBluetooth/CoreBluetooth.h&gt; 声明属性 @property (nonatomic, strong) CBCentralManager *manager; @property (nonatomic, strong) CBPeripheral *peripheral; @property (strong ,nonatomic) CBCharacteristic *writeCharacteristic; @property (strong,nonatomic) NSMutableArray *nDevices; @property (strong,nonatomic) NSMutableArray *nServices; @property (strong,nonatomic) NSMutableArray *nCharacteristics; 遵守协议 @interface ViewController () &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt; 初始化数据 - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.manager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; _cbReady = false; _nDevices = [[NSMutableArray alloc]init]; _nServices = [[NSMutableArray alloc]init]; _nCharacteristics = [[NSMutableArray alloc]init]; count = 0; } 实现蓝牙的协议方法 (1)检查蓝牙状态 -(void)centralManagerDidUpdateState:(CBCentralManager *)central { switch (central.state) { case CBCentralManagerStatePoweredOn: { [self updateLog:@&quot;蓝牙已打开,请扫描外设&quot;]; [_activity startAnimating]; [_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@&quot;FFF0&quot;]] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }]; } break; case CBCentralManagerStatePoweredOff: [self updateLog:@&quot;蓝牙没有打开,请先打开蓝牙&quot;]; break; default: break; } } 注：[_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@”FF15”]] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }];中间的@[[CBUUID UUIDWithString:@”FFF0”]]是为了过滤掉其他设备，可以搜索特定标示的设备。 （2）检测到外设后，停止扫描，连接设备 //查到外设后，停止扫描，连接设备 -(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI { [self updateLog:[NSString stringWithFormat:@&quot;已发现 peripheral: %@ rssi: %@, UUID: %@ advertisementData: %@ &quot;, peripheral, RSSI, peripheral.identifier, advertisementData]]; _peripheral = peripheral; [_manager connectPeripheral:_peripheral options:nil]; [self.manager stopScan]; [_activity stopAnimating]; BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) { CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) { [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; } } if (!replace) { [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; } } （3）连接外设后的处理 //连接外设成功，开始发现服务 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]); [self updateLog:[NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]]; [self.peripheral setDelegate:self]; [self.peripheral discoverServices:nil]; [self updateLog:@&quot;扫描服务&quot;]; } //连接外设失败 -(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;%@&quot;,error); } -(void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;%s,%@&quot;,__PRETTY_FUNCTION__,peripheral); int rssi = abs([peripheral.RSSI intValue]); CGFloat ci = (rssi - 49) / (10 * 4.); NSString *length = [NSString stringWithFormat:@&quot;发现BLT4.0热点:%@,距离:%.1fm&quot;,_peripheral,pow(10,ci)]; [self updateLog:[NSString stringWithFormat:@&quot;距离：%@&quot;, length]]; } （4）发现服务和搜索到的Characteristice //已发现服务 -(void) peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ [self updateLog:@&quot;发现服务.&quot;]; int i=0; for (CBService *s in peripheral.services) { [self.nServices addObject:s]; } for (CBService *s in peripheral.services) { [self updateLog:[NSString stringWithFormat:@&quot;%d :服务 UUID: %@(%@)&quot;,i,s.UUID.data,s.UUID]]; i++; [peripheral discoverCharacteristics:nil forService:s]; if ([s.UUID isEqual:[CBUUID UUIDWithString:@&quot;FFF0&quot;]]) { BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) { CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) { [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; } } if (!replace) { [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; } } } } //已搜索到Characteristics -(void) peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error{ [self updateLog:[NSString stringWithFormat:@&quot;发现特征的服务:%@ (%@)&quot;,service.UUID.data ,service.UUID]]; for (CBCharacteristic *c in service.characteristics) { [self updateLog:[NSString stringWithFormat:@&quot;特征 UUID: %@ (%@)&quot;,c.UUID.data,c.UUID]]; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF01&quot;]]) { _writeCharacteristic = c; } if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) { [_peripheral readValueForCharacteristic:c]; [_peripheral setNotifyValue:YES forCharacteristic:c]; } } } } - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { [self updateLog:[NSString stringWithFormat:@&quot;已断开与设备:[%@]的连接&quot;, peripheral.name]]; } （5）获取外设发来的数据 //获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF02[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[1] == 0) { }else if (resultByte[1] == 1) { [self updateLog:@&quot;未知错误&quot;]; }else if (resultByte[1] == 2) { [self updateLog:@&quot;鉴权失败&quot;]; } } if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF04&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF04[%d] = %d\\n&quot;,i,resultByte[i]);} if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF05&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF05[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[0] == 0) { // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆撤防状态&quot;]; }else if (resultByte[0] == 1) { // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆设防状态&quot;]; } } } //中心读取外设实时数据 - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@&quot;Error changing notification state: %@&quot;, error.localizedDescription); } // Notification has started if (characteristic.isNotifying) { [peripheral readValueForCharacteristic:characteristic]; } else { // Notification has stopped // so disconnect from the peripheral NSLog(@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic); [self updateLog:[NSString stringWithFormat:@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic]]; [self.manager cancelPeripheralConnection:self.peripheral]; } } //用于检测中心向外设写数据是否成功 -(void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@&quot;=======%@&quot;,error.userInfo); [self updateLog:[error.userInfo JSONString]]; }else{ NSLog(@&quot;发送数据成功&quot;); [self updateLog:@&quot;发送数据成功&quot;]; } /* When a write occurs, need to set off a re-read of the local CBCharacteristic to update its value */ [peripheral readValueForCharacteristic:characteristic]; } 后记厂商一般会提供一份蓝牙血压计通信指令控制数据格式(通讯协议) 可根据该协议中定义的返回的十六进制数据，定义当前外设发送的不同数据的意义。最主要是用UUID来确定你要干的事情，特征和服务的UUID都是外设定义好的。我们只需要读取，确定你要读取什么的时候，就去判断UUID是否相符。 一般来说我们使用的iPhone都是做centralManager的，蓝牙模块是peripheral的，所以我们是want datas，需要接受数据。 判断状态为powerOn，然后执行扫描 停止扫描，连接外设 连接成功，寻找服务 在服务里寻找特征 为特征添加通知 通知添加成功，那么就可以实时的读取value[也就是说只要外设发送数据[一般外设的频率为10Hz]，代理就会调用此方法]。 处理接收到的value，[hex值，得转换] 之后就自由发挥了，在这期间都是通过代理来实现的，也就是说你只需要处理你想要做的事情，代理会帮你调用方法。[别忘了添加代理] 参考资料蓝牙相关基础知识 hacksugar: Bringing back the on-screen keyboard 蓝牙交互CoreBlueTooth iOS and bluetooth iOS蓝牙，CoreBluetooth框架简介及入门使用 想做iOS Bluetooth產品但又不想過MFI的討論 CoreBluetooth cannot find devices but iOS can 请教熟悉iOS的朋友一个问题 【译】iOS蓝牙编程指南 – 核心蓝牙概述","tags":[{"name":"蓝牙开发","slug":"蓝牙开发","permalink":"http://XibHe.github.io/tags/蓝牙开发/"},{"name":"iOS BLE 开发","slug":"iOS-BLE-开发","permalink":"http://XibHe.github.io/tags/iOS-BLE-开发/"}]},{"title":"记一个在使用Masonry时遇到的问题","date":"2016-09-18T12:35:34.000Z","path":"2016/09/18/记一个在使用Masonry时遇到的问题/","text":"使用Masonry的场景在“我的”界面顶部区域用来展示用户的登录信息，顶部有两种样式的变换，即，由未登录—-&gt;已登录。如图所示， 其中头像区域是UIImageView，”登录/注册”是UILabel。登录成功后，头像区域会显示由服务器返回的头像地址生成的图片，并且其位置发生变化，不在居中显示，显示”登录/注册”的UILabel变为显示用户昵称，并且坐标位置发生改变。如图所示， 我的问题来了，在设置头像和标题位置时使用mas_remakeConstraints设置二者的约束，代码如图， 当从未登录切换到已登录时，已登录的头像位置会发生改变，变得特别大，不受约束控制。控制台会报如下错误， 刚开始没有意识到改变UIImageView的约束导致的新旧两种约束冲突造成的问题。在一个小时未解决该问题后，放弃了使用Masonry，改为使用代码做布局。今天，再回头看看这个问题，联想到忽略了什么东西，就打开Masonry文档从头开始仔细往下看，结果就看到了这句话， Sometimes you need modify existing constraints in order to animate or remove/replace constraints. In Masonry there are a few different approaches to updating constraints. 文档上列举了三种修改现有约束的方法， References你可以引用一个特定约束条件的约束，使表达式的结果分配给一个局部变量或一个类属性。 mas_updateConstraints作为一种选择，如果你只是去更新固有的约束值，你可以使用mas_updateConstraints这种便利的方法替换mas_makeConstraints。 mas_remakeConstraintsmas_updateConstraints用于更新一组约束，但要做那些费力的超出超出常量值的约束更新。这时就需要选择mas_remakeConstraints。mas_remakeConstraints类似于mas_updateConstraints，但它不是更新常量值，当再次为这些已经存在约束的视图设置约束前，它会移除掉该视图上的所有约束。这就让你可以为视图设置新的约束，而不用考虑移除之前已经存在的其他约束。 于是，我使用文档中提到的第三种方法，将所有的mas_makeConstraints换成了mas_remakeConstraints，就解决了约束错乱的问题。 参考文档Masonry使用 造成这个问题的主要原因是我没有认真看Masonry的文档，文档上说的已经很清楚了。","tags":[{"name":"Masonry","slug":"Masonry","permalink":"http://XibHe.github.io/tags/Masonry/"},{"name":"iOS适配","slug":"iOS适配","permalink":"http://XibHe.github.io/tags/iOS适配/"}]},{"title":"记一个关于线程的错误","date":"2016-09-11T15:23:34.000Z","path":"2016/09/11/记一个关于线程的错误/","text":"上周遇到一个问题，当前页面为一个UIWebView，当点该WebView上某个按钮进入下一个页面时，再通过该页面顶部返回按钮返回时，程序就会崩溃。（在开启了全局断点的情况下）控制台会输出如下提示： 程序崩溃在将要消失时，控制台给出 This application is modifying the autolayout engine from a background thread,whinch can lead to engine corruption and weird crashes.This will cause an exception in a future release. 的报错。 根据提示认为是后台线程在更新UI布局时，webView与JS的交互也在此时进行。交互操作会阻塞UI的显示及刷新。因此，又回到了一个老生常谈的准则上来了， 要在主线程刷新UI布局 。在调用本地应用于H5交互的方法时，要放到主线程中。 #pragma mark - 跳转购物车 - (void)goCart:(NSString *)shopNum { CLog(@&quot;jsString = %@&quot;,shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum]; dispatch_async(dispatch_get_main_queue(), ^{ [self.navigationController popToRootViewControllerAnimated:NO]; MallHomeViewController *mallHome = [LYSingle sharedSingle].mallVC; [mallHome setCurrentSelectIndex:3]; }); } #pragma mark - 商品上架(未开通店铺不能上架) - (void)cannotShelves { CLog(@&quot;cannotShelves&quot;); UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;要在主线程刷新UI&quot; delegate:self cancelButtonTitle:@&quot;我知道了&quot; otherButtonTitles:nil]; dispatch_async(dispatch_get_main_queue(), ^{ [alertView show]; }); }","tags":[{"name":"线程","slug":"线程","permalink":"http://XibHe.github.io/tags/线程/"},{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://XibHe.github.io/tags/iOS多线程/"}]},{"title":"使用 cocoapods 时遇到的错误及错误的解决方案","date":"2016-08-21T07:58:00.000Z","path":"2016/08/21/关于cocoapod的二三事/","text":"1.The dependency AFNetworking (= 2.6.3) is not used in any concrete target.在cocoapods version 1.0 之后，默认生成的Podfile文件类似于 pod &#39;Alamofire&#39;, &#39;~&gt; 3.1.4&#39; pod &#39;SwiftyJSON&#39;, &#39;~&gt; 2.3.2&#39; 这样的默认设置。为了不发生如标题那样的错误，需要手动用 target “TargetName” do end 把需要 pod 的库包括进来。 target &quot;TargetName&quot; do pod &#39;Alamofire&#39;, &#39;~&gt; 3.1.4&#39; pod &#39;SwiftyJSON&#39;, &#39;~&gt; 2.3.2&#39; end 2.ios None of your spec sources contain a spec satisfying the dependency: IQKeyboardManager (~&gt; 4.0.0).报这个错误，可能是由于Cocoapods的配置库有损坏，Cocoapods建议删除本地副本重新clone。根据cocoapods官方博客的方案，在终端做出如下操作 (依照次序) 第一步: sudo rm -fr ~/Library/Caches/CocoaPods &amp;&amp; \\ 第二步: $ sudo rm -fr ~/.cocoapods/repos/master gem update --system &amp;&amp; \\ gem update &amp;&amp; \\ gem cleanup &amp;&amp; \\ pod setup 参考资料Pod install displaying error in cocoapods version 1.0.0.beta.1 intergating New Firebase.. error cocoapods pod repo update does not happen error in cocoapods Repairing Our Broken Specs Repository","tags":[{"name":"cocoapod","slug":"cocoapod","permalink":"http://XibHe.github.io/tags/cocoapod/"}]},{"title":"关于iOS 7 Background Remote Notification(推送唤醒)","date":"2016-08-09T15:30:48.000Z","path":"2016/08/09/iOS 7 Background Remote Notification/","text":"更新说明更新记录: 2016 年 8 月，第一版 2017 年 8 月，增加配置极光推送的注意事项 Background Remote Notification简介Remote Notifications是 iOS7 在推送方面最大的变化，它允许应用收到通知后在后台（background）状态下运行一段代码，可用于从服务器获取内容更新。功能使用场景：（多媒体）聊天，Email更新，基于通知的订阅内容同步等功能，提升了终端用户的体验。 如何设置Remote notifications客户端设置需要在Xcode 中修改应用的 Capabilities 开启Remote notifications，如图： 当注册了Backgroud Modes -&gt; Remote notifications 后，notification 处理函数一律切换到下面函数，后台推送代码也在此函数中调用。 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler 这个函数也是iOS8之后获取远程推送调用的方法。 服务端设置 这个很重要，推送消息携带 content-available: 1 是Background 运行的必须参数，如果不携带此字段则与iOS7 之前版本的普通推送一样。服务端payload格式:aps增加content-available字段，类似于： payload example: {&quot;aps&quot;:{&quot;alert&quot;:&quot;example&quot;, &quot;sound&quot;:&quot;default&quot;, &quot;badge&quot;: 1, &quot;category&quot;:&quot;reply&quot;,&quot;content-available&quot;:&quot;1&quot; }} 这里集成的是极光推送，参考极光推送 Push API v3 的文档，发现了iOS 平台上发送 APNS 通知的规范。其中支持的字段中关键字 content-available 的类型为 boolean 。如果该字段为 true 说明是 Background Remote Notification ，如果不携带此字段则是普通的 Remote Notification 。这里需要特别注意的是服务器在配置 content-available: ture 时的正确性。如图，后台以java为例。 尚未传图 最后，当应用在后台挂起时，发起一个 Background Remote Notification(推送唤醒) 。客户端获取的数据，如下: userInfo = { &quot;_j_msgid&quot; = 2632357907; aps = { alert = &quot;\\U6717\\U81f4\\U96c6\\U56e2\\U9738\\U5dde\\U5e02(\\U53bf\\U7ea7)\\U603b\\U4ee3\\U7406\\U5546\\U5bb6\\U60a8\\U597d\\Uff01\\U60a8\\U7684\\U5e97\\U94fa\\U53c8\\U6709\\U65b0\\U8ba2\\U5355\\U4e86\\Uff0c\\U8ba2\\U5355\\U53f73cef6682b73ca,\\U8bf7\\U53ca\\U65f6\\U767b\\U5f55\\U5546\\U57ce\\U8fdb\\U884c\\U8ba2\\U5355\\U5ba1\\U6838\\U3002&quot;; badge = 1; category = identifier; sound = default; content-available = 1; }; } 参考资料极光客户端SDk教程 极光服务器端Push API v3 三种方式使得iOS应用能够在后台进行数据更新和下载 配置极光推送的注意事项使用极光测试生产环境下的推送时，发现无论通过我们自己的后台还是极光的后台使用Register ID发送通知，手机都无法收到通知。而在开发环境下是可以收到的。后来查了下极光文档中使用JPush iOS SDK注意事项: 如果你是直接运行安装到测试设备（运行调试状态），那你的安装的应用的证书环境只有可能是开发环境或者通配的。 而我恰恰是通过Xcode装的程序。 生产环境的正确测试姿势 常见问题-JPush合集 后记关于 Background Remote Notification(推送唤醒) 早在一年前就使用过，当时调研调试花费了大量时间。没想到现在又遇到了这个问题。结果，我又在阴沟里翻了船。可见做笔记，写博客总结的重要性。希望第三次闭着眼睛就能跳过这个坑。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"}]},{"title":"Objective-C与JS交互","date":"2016-07-12T16:00:00.000Z","path":"2016/07/13/JavaScriptCoreMutualH5/","text":"更新说明更新记录: 2016 年 7 月，第一版。 2017 年 8 月，增加OC调用JS方法相关介绍。 JavaScriptCore简介JavaScriptCore是iOS7引入的新功能，使用JavaScriptCore后可以实现js代码与本地native代码进行相互调用。 要使用JavaScriptCore，首先我们需要引入它的头文件 #import &lt;JavaScriptCore/JavaScriptCore.h&gt; 这个头里面引入了几个重要的对象 #import \"JSContext.h\" #import \"JSValue.h\" #import \"JSManagedValue.h\" #import \"JSVirtualMachine.h\" #import \"JSExport.h\" JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口 JSValue是JSContext执行后的返回结果，他可以是任何js类型（比如基本数据类型和函数类型，对象类型等），并且都有对象的方法转换为native对象。 JSManagedValue是JSValue的封装，用它可以解决js和原声代码之间循环引用的问题 JSVirtualMachine 管理JS运行时和管理js暴露的native对象的内存 JSExport是一个协议，通过实现它可以完成把一个native对象暴漏给js 具体的交互过程可以参见这篇博客https://imciel.com/2016/06/18/oc-js-communication/ OC与JS交互的方式OC与js交互，主要涉及到两方面: OC调用JS方法，将本地JS需要的值传递过去，供JS函数调用； JS调用OC的native方法，将JS函数中的返回值传递给本地方法，执行相应操作；下面将针对以上两条交互方式，展开来说。OC调用JS方法通过UIWebView展示JS页面，在UIWebView的代理方法中通过执行stringByEvaluatingJavaScriptFromString方法将JS代码执行结果以字符串方式返回， - (void)webViewDidFinishLoad:(UIWebView *)webView { NSString *text = aControl.titleLabel.text; NSString *jsMethod = [NSString stringWithFormat:@\"ocScrollToElementByName('%@')\", text]; [self.contentView stringByEvaluatingJavaScriptFromString:jsMethod]; } 也可以在当前加载webView页面类的 - (void)viewWillAppear:(BOOL)animated 方法中调用JS方法，执行相关操作，如: 传递参数 // JS交互，传gid,刷新JS页面商品数量 NSString *gid = [[NSUserDefaults standardUserDefaults] objectForKey:@\"GoodInfoH5Gid\"]; if (gid &amp;&amp; gid.length > 0) { NSString *jsMethod = [NSString stringWithFormat:@\"updateGoodNum('%@')\",gid]; [_webView stringByEvaluatingJavaScriptFromString:jsMethod]; } 局部刷新列表 // 局部刷新 [_webView stringByEvaluatingJavaScriptFromString:@\"updatecartnumAndTotalPay()\"]; JS调用OC的native方法通过JavaScriptCore进行交互，需要在webView的加载完成的代理方法中设置交互上下文-JSContext,并将JS中的交互对象赋给当前类。下面将叙述如何使用JSExport设置引用名称来进行交互，使用JSExport引用名称空间后，对于调用了哪些JS方法就一目了然了。 JSExport引用名称空间交互设置js那边统一使用一个名为jsObject的对象来调用js的方法进行传值或触发某一特定的事件。在 js 中定义一个方法: &lt;html> &lt;head> &lt;title>Demo&lt;/title> &lt;script type=\"text/javascript\"> function setContent(){ jsObject.shopCartNumChanged(totalNum); } &lt;/script> &lt;/head> &lt;body onload=\"javascript:setContent('ios is: ' + typeof ios)\"> &lt;/body> &lt;/html> 当点击 js 界面上的一个 “+” 号时，js 那边会查找 OC 代码通过JSContext注册的名为jsObject.shopCartNumChanged的调用方法。现在问题来了，在 OC 中该如何注册该方法呢?答案是使用语言穿梭机—JSExport协议。比如，我有一个 ShopCarViewController 的类。在.h中声明一个名为 MallJSExports 的协议。 // ShopCarViewController.h #import &lt;JavaScriptCore/JavaScriptCore.h> @protocol MallJSExports &lt;JSExport> - (void)shopCartNumChanged:(NSString*)shopNum; //购物车数量变化 - (void)orderGoBackToNative; //订单返回按钮 @end @interface ShopCarViewController : MallViewController @end 在.m中当然要声明并实现该协议的方法。 @interface ShopCarViewController()&lt;UIWebViewDelegate,MallJSExports>{ } @property (nonatomic, strong) UIWebView *webView; @property (nonatomic, copy) NSString *shopNum; //商品数量 @end @implementation ShopCarViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. self.navigationItem.title = @\"购物车\"; _webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, screenWidth, self.view.height-49)]; [_webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:_webUrl]]]; _webView.delegate = self; _webView.detectsPhoneNumbers = NO; [self.view addSubview:_webView]; } #pragma mark - 在webView加载完成的代理方法里设置JSContext - (void)webViewDidFinishLoad:(UIWebView *)webView { //JS上下文对象 JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; context[@\"jsObject\"] = self; } #pragma mark - 购物车数量变化 - (void)shopCartNumChanged:(NSString *)shopNum { CLog(@\"jsString shopNum = %@\",shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum]; } #pragma mark - 订单返回按钮 - (void)orderGoBackToNative { [self.navigationController popViewControllerAnimated:YES]; } 这里要注意的是 context[@ “jsObject” ] = self 中的的key值是和服务器商量好的, 即， js 中定义的回调方法 jsObject.shopCartNumChanged( )相一致。 在这里对 JSExport 的使用只是简单的设置了一下命名空间，将下标方法暴露给js对象方便服务器调用。其实， JSExport 协议主要用途是把objc复杂对象转换成JSValue并暴露给js对象。 JSExport 作为两种语言的互通协议。 JSExport 中没有约定任何的方法，连可选的(@optional)都没有，但是所有继承了该协议(@protocol)的协议（注意不是Objective-C的类(@interface)）中定义的方法，都可以在JSContext中被使用。 补充关于使用WKWebView进行交互。调用JS函数: [self.wkwebView evaluateJavaScript:@\"refreshList()\" completionHandler:^(id _Nullable rr, NSError * _Nullable error) { }]; 参考资料使用 JavaScriptCore 实现 JS和OC间的通信 JavaScriptCore框架在iOS7中的对象交互和管理 iOS JavaScriptCore使用 示例代码下载Demo","tags":[{"name":"JavaScriptCore","slug":"JavaScriptCore","permalink":"http://XibHe.github.io/tags/JavaScriptCore/"},{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"},{"name":"iOS与JS交互","slug":"iOS与JS交互","permalink":"http://XibHe.github.io/tags/iOS与JS交互/"}]},{"title":"路开始的地方","date":"2016-01-16T04:04:48.000Z","path":"2016/01/16/summary/","text":"特别鸣谢老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！并附上他的博客地址 前言博客页面的搭建是在2015年6月15日，在老郭的指导下完成的。搭建博客的初衷完全是因为看到别人都有博客，而且界面很炫，为了自己的虚荣心才觉得自己也要整一个这样的博客。可是等到自己动手的时候，完全无从下手。什么是Hexo，Homebrew，MarkDown等等。这些都没有听说过。还好有老郭，他手把手的教我如何去配置这些东东。那时候觉得自己好2B。最后，倒是整出来了，看到了久违的Hello World，还是当年的配方，还是熟悉的味道。好吧，我承认我只是一时的冲动和虚荣心在作怪，我的博客在2015年6月15日止步于Hello World，从此，再也没有爬起来过。 自己思考原来就是件很快乐的事情，而教别人思考则是学习思考，锻炼思维的最好办法。 为什么写博客或许我并不是一个喜欢记录，总结的人。但还是因为工作的原因(每个周五都要发一份周报给老大)，还是养成了一个记录的习惯。我把周一到周五每天都做了什么事情，记录在一个黑色的笔记本上。 把那些未经整理的，杂乱无章的，解决的问题的过程和代码复制到了印象笔记上。以备以后查阅方便。遇到类似的问题就打开笔记，复制出一份代码。也未深究这段代码的意义何在，为什么可以解决问题。久而久之，便不会思考，真的就成为了代码的搬运工了。没有了思考，发现不了自己的短板，便陷在了这样一种自我满足的境地当中了。每天看似在前进，实际上是在原地绕弯。日复一日，剩下的只有惶恐和迷茫。变得越来越不自信。杂乱无章的笔记和随处存放的代码片段并不能引导我去思考制造这些Bug的原因。我要思考，要分享我的思考过程，希望得到别人认可的同时也能指出我的不足和错误。 解决问题的核心思想只有一个———一切都靠积累。 博客的开始回顾过去的2015年，我已经在新公司待了快一年了，虽然，不知道自己究竟都有哪些提升。但是，冥冥中又觉得自己还是有些收获的。当然这些收获都来自于师傅他老人家的谆谆教导。我不想忘记那些和师傅一起加班的日日夜夜里所带来的收获，我要把这些冥冥中的收获写下来，记录我在这些项目中的收获，以及那些尚未解决的问题所留下的遗憾。 期望以后能弥补这些遗憾。留住这些青春的记忆。","tags":[{"name":"路的开始","slug":"路的开始","permalink":"http://XibHe.github.io/tags/路的开始/"}]}]