[{"title":"直播业务集成及再开发","date":"2021-06-11T16:00:00.000Z","path":"2021/06/12/直播业务集成及再开发/","text":"在项目中集成直播功能，提高运营端营销效率、下单转化率、增加营销方式并成为客户沉淀的重要手段。 直播技术点视频直播，可以分为 采集，前处理，编码，传输，解码，渲染 这几个环节。 推流端：采集、前处理、编码、推流 服务端：转码、录制、截图、鉴黄 观众端（播放器）：拉流、解码、渲染 互动：聊天室、礼物系统、点赞、弹幕等 直播技术点： 直播 App 架构： 业务流程（观众端）观众端拉流播放功能，基于腾讯云直播基础版（Smart），基础版仅包含直播推流（TXLivePusher）和直播播放（TXLivePlayer）两项功能，对 App 的安装包体积增量最小，适合仅使用移动直播相关功能的客户。 直播间主要包含四部分功能： 直播拉流播放功能 点播回放功能 IM 消息收发展示及处理特殊自定义消息 不同直播状态 UI 样式之间切换及展示 交互流程1. 首先需要在 AppDelegate 中对腾讯云直播 SDK 和 IM 进行初始配置[TXLiveBase setLicenceURL:@&quot;&quot; key:@&quot;&quot;]; // 腾讯云 IM SDK 初始化 V2TIMSDKConfig *config = [[V2TIMSDKConfig alloc] init]; BOOL isinitSDK = [[V2TIMManager sharedInstance] initSDK: config:config listener:nil]; NSLog(@&quot;isinitSDK = %@&quot;, isinitSDK ? @&quot;YES&quot; : @&quot;NO&quot;); 2. 通过首页 CMS 或短信链接或者微信分享的直播链接打开包含 roomId 信息的路由链接。直播间新增直播间对应路由 eg. XXX://activity/live?roomId=12345683. 进入直播间调用获取房间详情接口获取直播间信息，根据接口返回的直播状态决定是拉流播放还是点播回放，并展示不同状态的 UI 样式。目前共有101、103、106、108、110、115、206 等 7 种状态。通过返回字段 pullUrl 获取直播拉流地址，若直播状态为 101 则则直接进行拉流播放；否则，根据不同状态展示不同 UI 视图。4. 已登录情况下，进入直播间三步走： 调用接口 getUserSig 获取用户 Sig； 拿着获取到的用户 Sig 登录 IM ； 在 IM 登录成功后，调用加入直播间群组 API。 ⚠️在以上三步成功走完后，就可以在直播间发送文本消息或者自定义点赞消息了。 直播后台推流及状态 103 暂停中(或异常): 若上一个状态为 106 待开播，则提示：主播正在赶来的路上，请稍候，否则，提示：主播暂时离开，请稍候。并展示“点击重试” 按钮。可以提过该按钮，触发重试拉流逻辑。 106 待开播，该状态展示开播倒计时（开播时间戳为xxx分钟xxx秒、xxx秒触发倒计时）及展示“开播提醒”按钮，点击会调用订阅及提醒接口 108 已结束，回放生成中，展示已结束提示：“直播已结束”、“回放生成中” 并触发商品弹窗（固定位置且不可关闭） 110 云点播(回放)，根据回放地址播放视频，展示自定义播放进度控制条、商品按钮、分享 115 已结束，无回放。展示已结束提示：“直播已结束” 并触发商品弹窗（固定位置且不可关闭） 206 禁播。展示“主播暂时离开，请稍候”及 “看看其他直播”按钮。 ⚠️由状态 101 到 108 需要更新“xxxx人观看”视图，而直接为 108 不需要，即，展示“xxxx人观看” 直播 SDK 推流状态腾讯云直播 拉流端异常处理：基于直播 SDK 状态码 2003、2004、2006、-2301 等对直播异常状态进行特殊处理。 -2301 及其他导致连接失败的异常：此时，更新后台推流状态码为 103 暂停中(或异常) 触发异常逻辑 weakSelf.livePlayerWrapper.playErrorBlock = ^(int event, NSString *msg) { dispatch_async(dispatch_get_main_queue(), ^{ // [weakSelf.livePlayer pause]; // [MCToast hideLoadingToastInView:weakSelf.playToolBarView]; [MCKitLoading mcStopLoadingInView:weakSelf.playToolBarView]; // 暂停中(或异常) [weakSelf.livePlayer removeVideoWidget]; [weakSelf.roomInfoDict mcSetInteger:103 forKey:@&quot;liveStatus&quot;]; [weakSelf.playToolBarView handleRoomId:weakSelf.roomId roomInfo:weakSelf.roomInfoDict]; [weakSelf.playToolBarView.liteStatusView configRetryTitle]; // MCStrongSelf // weakSelf.playToolBarView.liteStatusView.retryBlock = ^{ //// [MCToast showLoadingToastInView:strongSelf.view]; // NSString *pullUrl = [strongSelf.roomInfoDict mcObjectForKey:@&quot;pullUrl&quot;]; // [strongSelf startPlayWithView:strongSelf.videoPlayerView pullUrl:pullUrl]; // }; }); }; 2003、2004、2006 这三种状态，主要用来处理由播放异常到开始播放或者播放结束的过度状态。对应不同的服务端播放状态及 UI 处理逻辑。 // 播放事件回调 weakSelf.livePlayerWrapper.playEventBlock = ^(int event, NSDictionary * _Nonnull param) { switch (event) { case EVT_RENDER_FIRST_I_FRAME: { // 渲染首个视频数据包（IDR） dispatch_async(dispatch_get_main_queue(), ^{ [MCKitLoading mcStopLoadingInView:weakSelf.playToolBarView]; [weakSelf.roomInfoDict mcSetInteger:101 forKey:@&quot;liveStatus&quot;]; [weakSelf.playToolBarView handleRoomId:weakSelf.roomId roomInfo:weakSelf.roomInfoDict]; }); } break; case EVT_VIDEO_PLAY_BEGIN: { // 视频播放开始 dispatch_async(dispatch_get_main_queue(), ^{ [MCKitLoading mcStopLoadingInView:weakSelf.playToolBarView]; }); } break; // case EVT_VIDEO_PLAY_PROGRESS: { // // 视频播放进度 // dispatch_async(dispatch_get_main_queue(), ^{ // [MCKitLoading mcStopLoadingInView:weakSelf.playToolBarView]; // }); // } // break;; case EVT_VIDEO_PLAY_END: { // 视频播放结束 dispatch_async(dispatch_get_main_queue(), ^{ [MCKitLoading mcStopLoadingInView:weakSelf.playToolBarView]; [weakSelf.roomInfoDict mcSetInteger:108 forKey:@&quot;liveStatus&quot;]; [weakSelf.playToolBarView handleRoomId:weakSelf.roomId roomInfo:weakSelf.roomInfoDict]; }); } break; default: break; } ⚠️：原有直播开始回调逻辑，在从异常中断到再次连接开始播放过渡时，不是每次都百分百调用。因此，才需要在 playEventBlock 中处理多种过度状态。 iOS 直播功能目录结构及对应类：主要分为三部分：直播间管理类及IM 消息管理类、直播间控制器、直播不同状态 UI 视图。 直播间管理类及 IM 消息管理类： XXX 主要处理直播间普通及自定义 IM 消息，包括 IM 登录、加入群组、普通或自定义消息接收及处理、群消息接收、收到强制关闭直播的消息 (1: 后台强制结束 2: 主播涉黄 3: 超时被强制结束 4: 超时未开播)、获取在线人数、退出直播间 (退出 IM 群组)、删除消息 // 收到强制关闭直播的消息 (1: 后台强制结束 2: 主播涉黄 3: 超时被强制结束) - (void)onRecvRESTRoomID:(NSString *)roomID status:(int)status; 观众播放主控制器，处理直播间不同的直播状态、IM 消息、监听主播端推流状态、配置直播间 View 目录下为直播间 UI：IM 消息列表、点赞、分享、商品等所在的观众播放页面工具视图（点赞、评论、分享、点播时的进度条）、顶部视图 （展示观看人数等信息)、直播状态视图、回到直播间悬浮、新的直播间商品弹窗等 UI 视图。 直播推拉流 推流端（主播端）小程序推 拉流端（观众端） 基于腾讯云直播 SDK 的二次开发。 IM 普通消息及自定义消息体处理&#124; 使用自定义消息体payload中的data字段来传输数据，data为字符串Json，约定cmd来做类型区分 eg. 1. 点赞 cmd: LIKE num：当前点赞了几次 约定num字段来记录当前用户点赞点了几下，接收方会拿自己本地当前的点赞数累加该num 2. 删除 （只删除 user_id 不是自己的他人发送的消息） 由于小程序端消息体中的 messageId 与 iOS 及 Andriond 两端算法不一致，导致三端无法通过 messageId 删除特定消息体。因此，最后方案是：通过匹配字符串的方式，删除当前消息列表中的消息。 cmd: DELETE_MESSAGE msg_text: 当前消息的文本 user_id: 当前消息体的发送方id IM 管理类 MCTXIMManager 中定义的消息体的不同 CMD，用以区分不同的自定义消息体 #define CMD_PUSHER_CHANGE @&quot;notifyPusherChange&quot; #define CMD_CUSTOM_TEXT_MSG @&quot;CustomTextMsg&quot; #define CMD_CUSTOM_LIKE @&quot;LIKE&quot; // 点赞 #define CMD_DELETE_MESSAGE @&quot;DELETE_MESSAGE&quot; // 删除消息 #define CMD_LIVE_STATUS_NOTICE @&quot;LIVE_STATUS_NOTICE&quot; // 主播端主动通知的状态 遗留问题iOS、Andriond、小程序三端进入直播间获取的实时在线人数不一致的问题； 注意事项 iOS 集成腾讯云直播基础版，相比之下，直播专业版本继承了 实时音视频 SDK、超级播放器（Player+） 和 短视频（UGSV）等音视频相关的核心功能。根据目前业务需求基础版完全够用了； 为避免 SDK 版本不一致导致功能性问题，iOS 与 Andriond 直播 SDK 版本固定为：pod ‘TXLiteAVSDK_Smart’, ‘8.7.10102’ 两端而 IM SDK 版本固定为： pod ‘TXIMSDK_iOS’, ‘5.1.62’； TXIMSDK_iOS 中包含新旧两套 IM API，为了保证稳定性。iOS 和 Andriond 使用最新的 IM API。iOS 使用调用方法名以 V2TIMManager 为开头的新 API； 点播回放功能并没有集成腾讯单独提供的超级播放器(通过 pod ‘SuperPlayer’ 引入) 而是通过对TXLiteAVSDK_Smart 提供的 TXVodPlayer 点播播放器进行自定义。在 TXVodPlayer 基础之上按照 UI 设计稿样式自定义播放进度条实现； 未登录可以进入直播间，注意项目中未登录到登录状态的处理逻辑； 通过 CMS 列表商品从直播间跳转商品详情页的浮窗逻辑； iOS 发布 App Store 需要经营范围包含“表演”或“网络表演”的《网络文化经营许可证》 参考文档腾讯云移动直播 SDK 即时通讯 IM IMSDK （V2TIMManager 版） 即时通讯客户端 SDK API –EOF– 若无特别说明，本篇文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"直播","slug":"直播","permalink":"http://XibHe.github.io/tags/直播/"},{"name":"推拉流","slug":"推拉流","permalink":"http://XibHe.github.io/tags/推拉流/"}]},{"title":"Swift 与 OC 混编注意事项","date":"2020-08-30T16:00:00.000Z","path":"2020/08/31/Swift_OC_mix/","text":"为了使 Objective-C 代码更好的符合 Swift 的使用习惯，主要有以下几种处理方式： 遵循编译器的某些规则 在头文件里进行特殊标注 用 Swift 做中间层，重新封装原有代码 根据自己的喜好进一步优化 快速查看 Xcode 基于 OC 代码生成的 Swift 接口在需要转换的 OC 类的 .h 头文件中，点击左上角的 Related Items 按钮，选择 Generated Interface 后，就会出现几种不同 Swift 版本的接口文件选择其中某个版本的 Swift 接口文件，如下图所示： 选择其中某个版本的 Swift 接口文件，最终自动生成对应版本的 Swift 接口 API Objective-C 与 Swift 混编的一些问题：1. 过多的隐式解析可选类型默认情况下 Swift 会把 Objective-C 里的指针当做隐式解析可选类型，因为它认为这个值大部分情况下不会是 nil，但它也不完全确定。 这样做会导致两个问题： 大量的隐式解析可选类型让代码变得意图模糊 隐式解析的存在，导致了容错能力的下降。只要服务端回传的参数中有一个空字段或者类型错误，就有可能引发 Crash 解决以上问题的方式：在 OC 代码中使用 nonnull (不可为空)和 nullable (可为空)关键字，根据这两个关键字决定转换后的 Swift 是否使用隐式解析。除了 nonnull 和 nullable 以外，还有一对配合使用的宏 NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END 可以让我们的代码更清爽。(新建类会自带这一对宏) 2. 某些转换后的属性里 Any 定义过于模糊可以通过在 OC 里添加 NSArray，NSDictionary 中存储的固定类来改善这个问题。例如， -(void)setRecommendArray:(nullable NSArray&lt;MCHomeGoodModel *&gt; *)recommendArray andSpace:(CGFloat)space andsectionInset:(UIEdgeInsets)sectionInse; 转换为： open func setRecommendArray(_ recommendArray: [MCHomeGoodModel]?, andSpace space: CGFloat, andsectionInset sectionInse: UIEdgeInsets) 3. 一些初始化构造器或者方法命名不够优雅Swift 和 Objective—C 的命名风格是有所不同，例如 Swift 的 API 是由基名（previousMissionsFlown）和参数标签（by）组成的，⽽ Objective—C 基本上只有参数标签(previousMissionsFlownByAstronaut)，没有单独的基名，所以基名的信息会包含在第⼀个参数标签⾥，这也导致了 Objective—C 的方法名会显得略长一些。 4. 对于数字处理统一使用 Int (重要！！！)NSUInteger 是无符号的，即没有负数。在 OC 中多以 NSUInteger 返回 index 或者设置枚举类型 由于 NSUInteger 的大小会因架构不同而产生一些变化，Swift 采取的策略是在进⾏有符号运算时，要求开发者必须将⽆符号类型转换为有符号类型，如果 Swift 在处理⽆符号运算时，产⽣了负值，就会直接停⽌运算。 对于 Apple 自己的框架，他们设置了一个白名单用于将 NSUInteger 转换为 Int。对于开发者而言，决定权在我们自己手里，我们可以⾃⾏选择是否使⽤ NSInteger，但 Apple 的工程强烈推荐你这么做。或许在 Objective-C ⾥⾯差距不是很⼤，但在 Swift ⾥⾯很重要！ 5. 将字符串类型的常量变得更有条理在 Swift ⾥通常会把这些常量变成⼀个具有字符串原始值的枚举或者结构体，然后改变函数的入参类型，使其接受相应的枚举或者结构体类型。不加任何处理的 OC 代码无法将设置的多个常量聚拢在一起，无法生成 Swift 中的结构体。 在 typedef 后⾯加上 NS_STRING_ENUM 即可, 此时，原有的字符串常量将以结构体的⽅式导⼊到 Swift 中. (这条验证后没有效果) 6. 关于构造器的相关约定这个约定的大体内容是这样的，将初始化器分为两类，designated 和 convenience。你需要覆盖所有 designated 初始化器，以便安全地继承 convenience 的初始化器。 这个约定和 Swift 里面的构造器约定十分相似，但它们有个本质的区别！OC 的这种构造器约定不是语⾔级别的强制规则，更多的是⼀个开发者之间的约定，例如 convenience 必须选择⼀个 designated 的接口，但实际上很多 OC 的类并没这么做，这也意味着如果有⼦类的话，如何正确构造它会成为⼀个头⼤的问题！ 通常 designated 构造器会调⽤ [super init] 这个方法，而 convenience 构造器会调⽤⾃⾝的某个 designated 构造器。我们需要在 designated 构造器后面添加 NS_DESIGNATED_INITIALIZER, 对于 convenience 类型的构造器，你不需要做任何事情 注意事项1. nonull 和 nullable 只能在方法和属性上使用，如果想拓展其使用场景，就需要直接调用这两关键字底层的内容，也就是 _Nonnull 和 _Nullable。2. 对于数字处理统一使用 Int，工程中混编 MCRollingNoticeView 中 index 转化后为 UInt 类型，因其 OC 中使用了 NSUInteger 类型。转化后可能导致的越界问题。(注意!!!)3. 除了关注父类的 designated 构造器，开发者也需要关注 convenience 类型的构造器。总结虽然查看编译器生成的 Swift 头文件是一个好的方法。但⽣ 成的接口并不是全部，真正重要的是使用者在实际使⽤过程中写出的调⽤代码。所以当我们在思考如何打造一个更适合 Swift 使用的接口时，不光要看看⽣成的接口。也应该考虑实际的使用场景。 参考文档让 Objective-C 框架与 Swift 友好共存的秘籍 通过在 Objective-C 中设置 api 的特定宏来定制 Objective-C 代码并将其导入 Swift WWDC2020 Refine Objective-C frameworks for Swift –EOF– 本篇文章主要参照了 让 Objective-C 框架与 Swift 友好共存的秘籍 转载请保留原作者文章链接，谢谢！","tags":[{"name":"Swift","slug":"Swift","permalink":"http://XibHe.github.io/tags/Swift/"},{"name":"混编","slug":"混编","permalink":"http://XibHe.github.io/tags/混编/"}]},{"title":"AFN弱网环境下接口请求超时或被 cancel 问题分析","date":"2020-05-07T16:00:00.000Z","path":"2020/05/08/AFN_error_cancel/","text":"在弱网络环境下启动 App 进入首页，网络请求超时或者被 cancel 后，不会走网络请求失败的 failure 回调，导致该回调中隐藏假首页 (模态首页) 的代码不会执行，最终无法进入真正首页的问题。 测试流程 弱网环境 （可以使用 iPhone 的开发者模式或者通过 Charles 模拟弱网环境） 建议使用真机测试 建议使用生产环境数据进行测试 模拟弱网环境测试项目中网络请求框架对超时时间和重连次数的设置：当前 AFNetworking 的超时时间 MCNetworkRequestTimeoutInterval = 20.f，重连次数 MCNetworkRetryTimes = 3 开发者 —&gt; Network Link Conditioner —&gt; Very Bad Network失败接口，error.code == -999，Error Domain=NSURLErrorDomain Code=-999 “已取消”。对应接口以下 6 个接口： UserInfo={NSErrorFailingURLStringKey=https://test.com/api/ad/get} UserInfo={NSErrorFailingURLStringKey=https://test.com.com/mall_trade/api/cart/list} UserInfo={NSErrorFailingURLStringKey=https://test.com/api/account/salesinfo} UserInfo={NSErrorFailingURLStringKey=https://test.com/api/cms/getmodulesbyroute} UserInfo={NSErrorFailingURLStringKey=https://test.com/api/cms/gettabbar} UserInfo={NSErrorFailingURLStringKey=https://test.com/api/im/getgroupinfo} 需要注意的是：在该 Very Bad Network 环境下，所有进入失败的接口请求都为 -999，即，已被取消的接口请求。具体代码如下： } failure:^(NSError *error) { if (error.code == -999) { //request cancel. nothing todo } else { //网络不通 if (failure) { failure(error); } } } repeatCancel:repeatCancel]; 此网络状态下，超时重连后会正常回调 failure 的的方法。 开发者 —&gt; Network Link Conditioner —&gt;90% Loss (自定义 In Packet Loss 90，Out Packet Loss 0)触发网络框架的重连机制，通过网络框架中的扩展方法 AFHTTPSessionManager+MCRetryPolicy.h 进行重连， // #import &quot;AFHTTPSessionManager+MCRetryPolicy.h&quot; - (NSURLSessionDataTask *)requestUrlWithRetryRemaining:(NSInteger)retryRemaining maxRetry:(NSInteger)maxRetry retryInterval:(NSTimeInterval)retryInterval progressive:(bool)progressive fatalStatusCodes:(NSArray&lt;NSNumber *&gt; *)fatalStatusCodes originalRequestCreator:(NSURLSessionDataTask *(^)(void (^)(NSURLSessionDataTask *, NSError *)))taskCreator originalFailure:(void(^)(NSURLSessionDataTask *task, NSError *))failure { if (retryRemaining &gt; 0) { void (^addRetryOperation)(void) = ^{ [self requestUrlWithRetryRemaining:retryRemaining - 1 maxRetry:maxRetry retryInterval:retryInterval progressive:progressive fatalStatusCodes:fatalStatusCodes originalRequestCreator:taskCreator originalFailure:failure]; }; if (retryInterval &gt; 0.0) { dispatch_time_t delay; if (progressive) { delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(retryInterval * pow(2, maxRetry - retryRemaining) * NSEC_PER_SEC)); [self logMessage:@&quot;Delaying the next attempt by %.0f seconds …&quot;, retryInterval * pow(2, maxRetry - retryRemaining)]; } else { delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(retryInterval * NSEC_PER_SEC)); [self logMessage:@&quot;Delaying the next attempt by %.0f seconds …&quot;, retryInterval]; } // Not accurate because of &quot;Timer Coalescing and App Nap&quot; - which helps to reduce power consumption. dispatch_after(delay, dispatch_get_main_queue(), ^(void){ addRetryOperation(); }); } else { addRetryOperation(); } } else { [self logMessage:@&quot;No more attempts left! Will execute the failure block.&quot;]; failure(task, error); } } 问题定位埋点库 MCStatisticsManager 由于传递 protobuf 格式的数据，在上报埋点请求时其序列化的类型被设置为：MCRequestSerializerTypeProtobuf，响应序列化 serializer = [AFProtobufResponseSerializer serializer]; 而正常的非上报埋点请求的序列化为 MCRequestSerializerTypeJSON。所以当遇到弱网和非弱网访问时，会造成两种截然不同的处理结果： 弱网情况下： 因网络原因导致请求超时，会触发重连机制，在重新连接网络时，会 resume 重启之前被 suspend 暂停的网络请求 task，再次调用单例 MCNetworkManager 序列化方法，此时，由于是异步执行网络请求，在此之前，埋点上报 MCStatisticsManager已经将网络请求序列方式修改为MCRequestSerializerTypeProtobuf。 在调用非上报埋点的网络接口时，因其请求需要被序列化为 MCRequestSerializerTypeJSON，序列化类型与现有MCNetworkManager序列化类型不匹配，导致报错： 序列化失败 = Error Domain=com.alamofire.error.serialization.request Code=-1016 &quot;The `parameters` argument is not valid Protobuf.&quot; UserInfo={NSLocalizedFailureReason=The `parameters` argument is not valid Protobuf.} url = https://mallapi-stage.yunshanmeicai.com/api/auth/loginbytickets 时间 = 2020-05-08 09:27:22 +0000 此时，序列化错误 serializationError 会造成 task 请求返回 nil 的 NSURLSessionDataTask， // #import &quot;AFHTTPSessionManager.h&quot; - (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure { NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; NSLog(@&quot;\\n序列化失败 = %@\\nurl = %@\\n时间 = %@\\n&quot;, serializationError, URLString, [NSDate date]); if (serializationError) { if (failure) { dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); } return nil; } __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { NSLog(@&quot;\\n网络回来了 = %@\\n失败是什么 = %@\\ndataTask = %@&quot;, URLString, error, dataTask); if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; return dataTask; } 当因序列化失败触发 failure 的 block 回调返回空的 NSURLSessionDataTask， dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); 该失败回调会触发最后一步 MCNetworkManager 中对应 post 请求的 failure 中的回调方法， // #import &quot;MCNetworkManager.h&quot; - (void)executeDataTaskWithURL:(NSString *)url parameters:(id)parameters timeoutInterval:(NSTimeInterval)timeoutInterval requestType:(MCRequestType)requestType requestSerializerType:(MCRequestSerializerType)requestSerializerType requestHeader:(NSDictionary *)requestHeader responseSerializerType:(MCResponseSerializerType)responseSerializerType progress:(NetworkProgressBlock)progress success:(NetworkSuccessBlock)success failure:(NetworkErrorBlock)failure repeatCancel:(BOOL)repeatCancel { case MCRequestTypePost: { if (requestHeader.allKeys.count &gt; 0) { for (NSString *key in requestHeader.allKeys) { id value = [requestHeader objectForKey:key]; [self.manager.requestSerializer setValue:value forHTTPHeaderField:key]; } } task = [self.manager POST:url parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) { } success:^(NSURLSessionDataTask *task, id responseObject) { [weakSelf removeExecutingTaskWithKey:url]; if (success) { success(responseObject); } } failure:^(NSURLSessionDataTask *task, NSError *error) { // NSLog(@&quot;task是 = %@ 错误原因 = %@ url是 = %@&quot;, task, error, url); if (task.state == NSURLSessionTaskStateCompleted) { [weakSelf removeExecutingTaskWithKey:url]; if (failure) { failure(error); } } } retryCount:MCNetworkRetryTimes retryInterval:0 progressive:false fatalStatusCodes:nil]; } break; } 需要注意⚠️的是：该方法判断了传递过来的 task 的 state 是否为 NSURLSessionTaskStateCompleted才会返回最终的网络请求失败的 failure 回调，但是此时传递过来的 task 因为序列化失败而为 nil，这样就不会触发 failure 回调。因此，在弱网情况下，因接口请求超时，导致接口请求失败的 failure 回调方法中对失败处理的代码就不会执行了。造成弱网络启动时，因超时接口请求失败，模态首页无法在失败回调中移除。 通过输出重连时，请求序列化不同类型的时间，对比同一接口在重连前后序列化成功或者失败的情况。 // #import &quot;MCNetworkManager.h&quot; - (AFHTTPRequestSerializer *)requestSerializerWithType:(MCRequestSerializerType)type timeoutInterval:(NSTimeInterval)timeoutInterval { NSLog(@&quot;request 序列化 = %@, 类型为 = %@&quot;, [NSDate date], @(type)); AFHTTPRequestSerializer *serializer = [AFHTTPRequestSerializer serializer]; if (type == MCRequestSerializerTypeJSON) { serializer = [AFJSONRequestSerializer serializer]; } else if (type == MCRequestSerializerTypePropertyList) { serializer = [AFPropertyListRequestSerializer serializer]; } else if (type == MCRequestSerializerTypeProtobuf) { serializer = [AFProtobufRequestSerializer serializer]; } serializer.timeoutInterval = timeoutInterval; return serializer; } 对比重连机制序列化改变时间输出 log 日志如下： 2020-05-08 17:25:35.770423+0800 MeicaiStore[69492:1057810] request 序列化 = 2020-05-08 09:25:35 +0000, 类型为 = 1 request 序列化 = 2020-05-08 09:25:35 +0000, 类型为 = 3 request 序列化 = 2020-05-08 09:25:41 +0000, 类型为 = 3 request 序列化 = 2020-05-08 09:25:49 +0000, 类型为 = 3 序列化失败 = (null) url = https://mallapi-stage.yunshanmeicai.com/api/auth/loginbytickets 时间 = 2020-05-08 09:25:35 +0000 序列化失败 = Error Domain=com.alamofire.error.serialization.request Code=-1016 &quot;The `parameters` argument is not valid Protobuf.&quot; UserInfo={NSLocalizedFailureReason=The `parameters` argument is not valid Protobuf.} url = https://mallapi-stage.yunshanmeicai.com/api/auth/loginbytickets 时间 = 2020-05-08 09:27:22 +0000 在 09:25:35 时接口 auth/loginbytickets 的序列化类型为 1 即，MCRequestSerializerTypeJSON，此时，序列化成功未报错。 在 09:25 时，序列化类型已经变为3，即，MCRequestSerializerTypeProtobuf 在网络重连后的 09:27:22 时，序列化失败，此时 MCNetworkManager 序列化类型已经被改变，报parameters` argument is not valid Protobuf 序列化不匹配的错误。最终导致接口请求的 failure 回调不被执行。 非弱网情况下：非弱网情况下，不会触发网络连接超时的重连机制。每个网络请求都对应当前设置的序列化类型 解决方案在埋点库 — MCStatisticsManager 中重新初始化一个新的用于网络上报埋点的 MCNetworkManager，而不是之前的单例 [MCNetworkManager sharedInstance]，去执行上报埋点数据的网络请求。 遗留问题超时时间设置为 20 秒，重连次数为 3 次。导致在弱网情况下，网络请求failure 回调处理等待时间过长的问题。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://XibHe.github.io/tags/AFNetworking/"},{"name":"弱网","slug":"弱网","permalink":"http://XibHe.github.io/tags/弱网/"}]},{"title":"React Native 父子组件间通信","date":"2019-06-19T16:00:00.000Z","path":"2019/06/20/RN 父子组件通信/","text":"props 父组件-&gt;子组件，父组件调用并传值给子组件 父组件通过 props 把数据传给子组件，子组件通过 this.props 去使用相应的数据。例如，在父组件标签中定义 props 及对应的值， 在子组件中解构获取 props 传递过来的值并赋给对应的组件 render () { const { saleClassTwoData } = this.props return ( this.renderItem(item, index)} keyExtractor={(item) =&gt; item.id} /&gt; )}ref 父组件可以通过使用 ref 来直接调用子组件实例的方法， 在 constructor 定义一个全局变量，并创建 refthis.leftListRef = React.createRef()将 1 中定义的 this.leftListRef 以属性形式传递给子组件， 在父组件中通过 this.leftListRef 调用子组件中的函数并传递参数refreshSKUListForSwitch = (position) =&gt; { const { saleClassOneData, saleClassTwoData } = this.state // 切换二级分类 this.leftListRef.current.setSelectItem(this._classTwoIndex - 1)}其中，setSelectItem 为子组件 DishesLeftList 中定义的函数 若无特别说明，本站文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://XibHe.github.io/tags/ReactNative/"},{"name":"RN 组件","slug":"RN-组件","permalink":"http://XibHe.github.io/tags/RN-组件/"}]},{"title":"iOS内存泄漏检测","date":"2019-05-26T16:00:00.000Z","path":"2019/05/27/iOS内存泄漏检测/","text":"最近对项目中存在的内存泄露问题的检测做了一些总结，一些检测工具的使用及简单内存泄露问题的处理。 内存泄漏排查，三步走： Analyzer（静态分析） MLeaksFinder (第三方工具) Instruments Leaks (动态检测) Analyaer不需要运行程序，通过 Product-&gt;Analyze 或快捷键 command+shift+B 进行代码分析。 分析代码上下文的语法结构和内存情况，找出代码中潜在错误 Analyzer主要分析四种问题： 逻辑错误：访问空指针或未初始化的变量等； 内存管理错误：如内存泄漏等； 声明错误：从未使用过的变量； API 调用错误：未包含使用的库和框架。 后面提到的 CoreLocation 框架的需要手动释放问题，就是通过 Analyzer 检测出来的。 说明： Analyzer由于是编译器根据代码进行的判断, 做出的判断不一定会准确, 因此如果遇到提示, 应该去结合代码上文检查一下；还有某些造成内存泄漏的循环引用通过Analyzer分析不出来。 MLeaksFinder通过 pod &#39;MLeaksFinder&#39; 或将下载的 MLeaksFinder 文件导入工程中， 在 MLeaksFinder.h 中 设置是否开启内存泄漏检测，以及是在模拟器中开始还是在真机中开启。 //***内存泄漏控制开关，注释该行代码打开内存泄漏工具，打开该行代码关闭内存泄漏**** //#define MEMORY_LEAKS_FINDER_ENABLED 0 #ifdef MEMORY_LEAKS_FINDER_ENABLED #define _INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED #else //仅在模拟器打开内存泄漏检测 #if TARGET_IPHONE_SIMULATOR //模拟器 #define _INTERNAL_MLF_ENABLED DEBUG #elif TARGET_OS_IPHONE //真机 #endif//TARGET_IPHONE_SIMULATOR #endif//_INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED 具体操作步骤：不断重复 push 和 pop 同一个 UIViewController，一旦有疑似内存泄漏的地方，就会弹出提示框，控制台也会输出调用栈的层级信息： [文件:MLeaksMessenger.m 行数:36] Memory Leak: ( MCLocateAddressViewController, UIView, BMKMapView, BMKInternalMapView, BMKTapDetectingView, BMKAnnotationContainer ) [文件:NSObject+MemoryLeak.m 行数:54] Possibly Memory Leak. In case that BMKAnnotationContainer should not be dealloced, override -willDealloc in BMKAnnotationContainer by returning NO. View-ViewController stack: ( MCLocateAddressViewController, UIView, BMKMapView, BMKInternalMapView, BMKTapDetectingView, BMKAnnotationContainer ) 展示视图自上而下的调用层级，这里需要注意一些三方 SDK 控件导致的疑似泄漏，可能会因其内部的 cache 机制或者释放不及时而被误判为内存泄漏。 Instruments Leaks这里使用最新版 Xcode 10.3 进行 leaks 检测。 1. Xcode 中 按住 command + I 或者菜单栏 Product – Profile 2. 双击 Leaks 或者按 choose，打开 Leaks 面板 3. 在显示的 Leaks 面板中，点击左上角红色点，即可运行内存检测4. 在运行过程中如果发现Leak Checks（如图）出现红色X说明检测到内存泄露,将鼠标点击Leak Checks，在下方即可看到内存泄漏的相关信息 5. 定位内存泄漏代码位置1. 选择 Leaks 有时候默认是 Run lssues，这时需要将其切换为 Leaks2. 选择 call Three 3. 此时，仍然看不到具体的代码位置，需要选择底部的 Call Tree，在弹窗中选择 Invert Call Tree 和 Hide System Libraries，即可显示出具体内存泄漏的代码 Call Tree 四种选项具体含义： Separate by Thread：按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。 Invert Call Tree：反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。 Hide System Libraries：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。 Flattern Recursion：拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。 4. 双击选中行，即可跳转 Instrument 中具体的代码 5. 点击右侧 Xcode 图标跳转至 Xcode 中定位的内存未回收的代码 注意1. 注意 Core Foundation 等底层操作它们不支持 ARC，还需要手动内存管理对象的创建和释放。例如，美菜到家中绘制地图覆盖物的方法：// 根据范围数组 border 的个数初始化定位坐标 CLLocationCoordinate2D *coords = (CLLocationCoordinate2D *)malloc(sizeof(CLLocationCoordinate2D) * borderCount); BMKPolygon *polygon = [BMKPolygon polygonWithCoordinates:coords count:borderCount]; free(coords); CLLocationCoordinate2D 是 系统框架 CoreLocation 中 一个 C 的 结构体，包含经度和纬度两个值 (CLLocation 是一个 objc 的 对象)，需要通过 free 手动释放。这里需要注意以 Core 开头的系统框架的内存管理。 2. 如果第五步不出现定位箭头，无法定位到具体代码，则点击项目工程文件-Buidl Setting-All-搜索Debug Information Format-Debug里选择DWARF with dSYM File（如图） 默认情况下，只有 release 环境下为 DWARF with dSYM File，其他环境均为 DWARF。当 Debug Information Format 为 DWARF with dSYM File 的时候，构建过程中多了一步 Generate dSYM File，最终产出的文件也多了一个 dSYM 文件。然后，重新编译启动 Instruments Leaks，重复以上步骤即可定位到具体代码。 参考资料MLeaksFinder：精准 iOS 内存泄露检测工具 MLeaksFinder 新特性 Tencent/MLeaksFinder 浅谈 iOS Crash –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"Instruments","slug":"Instruments","permalink":"http://XibHe.github.io/tags/Instruments/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://XibHe.github.io/tags/内存泄露/"}]},{"title":"React Native 原生模块与 JS 模块交互","date":"2019-03-16T16:00:00.000Z","path":"2019/03/17/RN_Module/","text":"最近使用 RN 时，需要在 RN 端实现调用系统相册上传选中照片的功能。需要原生模块与 RN 模块进行交互，主要步骤： 调用原生系统相； 将选取的照片存到本地沙盒； 再将沙盒路径传给 RN。 注意： 这里之所以需要将获取的照片存到沙盒下，再将沙盒路径传递给 RN 是因为 RN 端不支持 iOS 中 NSData 二进制流的数据传输格式。而是通过 multipart/form-data 这种表单方式上传文件。 FormData 对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。 在原生与 RN 交互的过程中尝试了几种传递数据的不同方式，这里记录一下，其本质上都是通过实现 RCTBridgeModule 的协议来进行数据交互的。 为了实现 RCTBridgeModule 协议，你的类需要包含 RCT_EXPORT_MODULE() 宏。这个宏也可以添加一个参数用来指定在 Javascript 中访问这个模块的名字。你必须明确的声明要给 Javascript 导出的方法，否则 RN 不会导出任何方法。 按传递数据的不同方式，分为以下三种： Callbacks 回调函数； 原生模块使用 promise 简化代码； RCTEventEmitter — 向 JS 模块发送事件。 Callbacks提供一个函数把返回值传回给 JavaScript 在原生模块中， RCT_EXPORT_METHOD(testCallback:(RCTResponseSenderBlock)callback) { NSArray *items = @[@&quot;callback &quot;, @&quot;test &quot;, @&quot;array&quot;]; callback(@events); } RCTResponseSenderBlock 只接受一个参数 — 传递给 JavaScript 回调函数的参数数组。 在 RN 中调用， testBack.testCallback((items) =&gt; { this.setState({items: items}); }) 原生模块通常只应调用回调函数一次。但是，它可以保存 callback 并在将来调用。如果你想传递一个 Error 类型的对象给 Javascript，可以用 RCTUtils.h提供的 RCTMakeError 函数。 promisepromise 涉及 ES6 的语法，搭配 ES2016(ES7) 标准的async/await语法则效果更佳。具体使用，桥接原生方法的最后两个参数是 RCTPromiseResolveBlock 和RCTPromiseRejectBlock，则对应的 JS 方法就会返回一个 Promise 对象。 RCT_EXPORT_METHOD(getState:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject){ SEPrinterManager *manager = [SEPrinterManager sharedInstance]; CBCentralManager *central = [manager valueForKey:@&quot;centralManager&quot;]; resolve([self successMessage:@{ @&quot;state&quot;: @(central.state == CBCentralManagerStatePoweredOn)}]); } - (NSDictionary *)successMessage:(id)data{ NSMutableDictionary *response = [NSMutableDictionary dictionary]; response[@&quot;code&quot;] = @(kBluetoohSuccessCode); response[@&quot;data&quot;] = data; return response; } 现在 JavaScript 端的方法会返回一个 Promise。 import { NativeModules } from &#39;react-native&#39;; class ConnectBLEPrinter extends Component { NativeModules.MCRNBlueTooth.getState.then(res =&gt; { console.log(&#39;BLE state:&#39; + res. state); }).catch((error) =&gt; { }); } 通过 Callbacks 和通过 Promises 的方式，都可以向 JS 模块传递数据，但都是只能传递一次。如果需要多次向 JS 模块传递数据，可以尝试 RCTEventEmitter 的方式。 RCTEventEmitter发送事件的方法 sendEvent 定义在 原生 module 类中，在需要发送事件的地方调用 sendEvent 方法就可以将事件通知发给 RN 端。类似于 iOS 中的通知方法的是实现。 iOS 端与 Android 不同，不使用 DeviceEventEmitter 做监听，而是用 NativeEventEmitter。具体实现方案如下： 自定义的模块类头文件要继承自 RCTEventEmitter， #import &lt;React/RCTEventEmitter.h&gt; #import &lt;React/RCTBridgeModule.h&gt; NS_ASSUME_NONNULL_BEGIN @interface MJTBlueToothManager : RCTEventEmitter &lt;RCTBridgeModule&gt; @end NS_ASSUME_NONNULL_END 声明事件， RCT_EXPORT_METHOD(scanBLEList){ SEPrinterManager *manager = [SEPrinterManager sharedInstance]; [manager startScanPerpheralTimeout:10 Success:^(NSArray&lt;CBPeripheral *&gt; *perpherals,BOOL isTimeout) { NSLog(@&quot;Test-----------&quot;); self.deviceArray = perpherals; } failure:^(SEScanError error) { NSLog(@&quot;请检查蓝牙状态&quot;, nil); }]; // 触发事件（不断将扫描到的外设列表传递给 RN 页面） [self sendEventWithName:@&quot;scanBLEList&quot; body:self.deviceArray]; } RN 端监听事件， import { NativeModules, NativeEventEmitter } from &#39;react-native&#39;; const NativeModule = new NativeEventEmitter(NativeModules.MCRNBlueTooth); class ConnectBLEPrinter extends Component { componentDidMount () { // 获取当前设备列表 MCRNBlueTooth.scanBLEList(); this.listener = NativeModule.addListener(&#39;scanBLEList&#39;,(data) =&gt; { console.log(&#39;输出 test&#39; + data.list); this.setState({ perpheralList: data.list }); }); // 检测蓝牙是否开启 NativeModules.MCRNBlueTooth.getState.then(res =&gt; { console.log(&#39;BLE state:&#39; + res. state); }).catch((error) =&gt; { }); } } // 移除监听 componentWillUnmount() { NativeEventEmitter.removeListener(&#39;scanBLEList&#39;,this.listener); } 为避免原生模块发出事件后，RN 中多次收到该事件。需要在 RN 页面声明周期结束后移除对事件的监听。 后记最开始与原生交互使用的是 promise 的方式，但在扫描蓝牙外设的场景下通过 promise 不断将扫描（设置 10 秒的扫描超时时间）出的设备列表传递给 RN 时，RN 页面报错： Illegal callback invocation from native module. This callback type only permits a single invocation from native code. 正如上文所说，Callbacks 和 Promises 只能传递一次数据。调用一次后就会被立即释放掉。使用 RCTEventEmitter 固然可以实现扫描外设，多次调用方法回传数据。但为了统一项目中数据的调用方式为 Promises，需要修改 Promises 调用方法中的逻辑。 可以在扫描完成后，先停止扫描，再将当前扫描结果返回给 RN 。 参考资料docs/native-modules-ios React Native原生模块向JS传递数据的几种方式 FormData 对象的使用 在React Native Module数据多次回调 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://XibHe.github.io/tags/ReactNative/"},{"name":"Module","slug":"Module","permalink":"http://XibHe.github.io/tags/Module/"}]},{"title":"TextInput 二三事","date":"2019-01-03T16:00:00.000Z","path":"2019/01/04/RN_TextInput/","text":"记录下这两天使用 TextInput 时遇到的问题及一些注意事项。 TextInput 键盘遮挡视图 KeyboardAvoidingView import { KeyboardAvoidingView, ScrollView } from &#39;react-native&#39;; &lt;View style={[styles.container]}&gt; &lt;KeyboardAvoidingView behavior=&quot;padding&quot; style={{ flex: 1 }}&gt; &lt;ScrollView style={[styles.scrollViewStyle]} keyboardShouldPersistTaps=&quot;handled&quot; &gt; // 视图布局 &lt;/ScrollView&gt; &lt;/KeyboardAvoidingView&gt; &lt;/View&gt; 这里单纯的添加 KeyboardAvoidingView 只会移动 TextInput 的坐标，但输入框下面还有其他视图，为了不遮挡其他视图，在将整个布局放到ScrollView 中。 react-native-keyboard-aware-scroll-view TextInput 中一些需要注意的属性 某些属性 iOS 与 Android 的取值或展示样式的差异 TextInput 在安卓上默认有一个底边框，同时会有一些 padding。如果要想使其看起来和iOS上尽量一致，则需要设置padding: 0，同时设置 underlineColorAndroid=&quot;transparent&quot; 来去掉底边框。 keyboardShouldPersistTaps 操作键盘 如果当前界面有软键盘，那么点击 scrollview 后是否收起键盘，取决于本属性的设置。（注意：很多人反应 TextInput 无法自动失去焦点/需要点击多次切换到其他组件等等问题，其关键都是需要将 TextInput 放到ScrollView中再设置本属性） keyboardType 的不同取值，iOS 和 Android 不同之处 无法通过在 TextInput 标签中定义 ref 调用 clear( )通过 ref 在 TextInput 标签中定义不同的引用类型，然后发现无法根据 定义的 ref 调用 TextInput 的 clear( ) 方法。 react-native info 为： Environment: OS: macOS High Sierra 10.13.6 Node: 8.6.0 Yarn: 1.12.3 npm: 5.3.0 Watchman: 4.9.0 Xcode: Xcode 10.1 Build version 10B61 Android Studio: 3.2 AI-181.5540.7.32.5014246 Packages: (wanted =&gt; installed) react: 16.3.1 react-native: 0.55.3 代码如下： export class LoginSceneComponent extends Component { constructor(props) { super(props) this.codeTextInputRef = React.createRef() } changeLoginType = () =&gt; { this.codeTextInputRef.current.clear() } render () { return ( &lt;ScrollView style={[styles.scrollViewStyle]} keyboardShouldPersistTaps=&quot;handled&quot; &gt; &lt;TextInput ref={this.codeTextInputRef} style={[styles.inputStyle]} secureTextEntry={this.state.loginTypeFlag} value={this.state.passWord} onChangeText={text =&gt; this.setState({ passWord: text })} /&gt; &lt;/ScrollView&gt; ) } } 最终通过在 onChangeText={txt =&gt; this.setState({ passWord: txt })} 方法中重新 setState 参数清除了输入框中内容。 注意： React 16.3 更新了 创建 Ref 的方法。 参考资料textinput keyboardavoidingview facebook/react-native/issues/18843 facebook/react-native/issues/18272 refs-and-the-dom –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://XibHe.github.io/tags/ReactNative/"},{"name":"TextInput","slug":"TextInput","permalink":"http://XibHe.github.io/tags/TextInput/"}]},{"title":"回望2018","date":"2018-12-30T16:00:00.000Z","path":"2018/12/31/2018year-endsummary/","text":"2018转眼间就要过去，回首这一年的经历，在这里做个总结，让自己审视（Review、复盘）自己的表现，以决定下一步要怎么做。曾经，好好安放；未来，一步步来! 新工作10月份从干了两年多的公司离职，月底入职新公司。从提出离职到入职新公司中间不超过一周，也就是休息了一个周末后就到新公司上班了。这是我代码生涯中第一次以这样一种方式转变。想来没有什么比 热插拔 这个计算机用语更合适的词来形容了。 入职新公司，终于有机会学习自己一直想深入理解的 React Native 跨平台开发技术。可以学习团队最近几年在混合开发领域不断积累的技术沉淀，不用再自己摸石头过河，是一件多么幸运的事情啊！顺便推广一波我们团队在掘金的技术博客 — WirelessSprucetec 原生客户端开发的关注点应该放在移动设备 Web 应用程序上（例如使用 PWA）和 React Native，Flutter 等引领的混合开发领域。 种一棵树最好的时间是十年前。其次是现在。 学习新技术总是要亲手敲一敲，多踩踩坑才能有自己的一番理解，也只有将遇到的坑填平才能有所收获，自己这两年的技术提升也正是建立在解决问题之上的。 总结与收获回想最近这两年的经历，心中百感交集。再次审视自己之前写的代码，其中不乏有闪光的地方，这些代码多少为解决某些棘手的问题而做的优化或者特殊处理。比如： 使用WKWebView进行性能调优 从一个数据量过多的优化说起 https://xibhe.com/2018/05/28/Compiling/ 技术上的提升也是建立在解决某些疑难问题上的，有时觉得这些需要花费很多时间才能解决的问题，甚至根本不算是问题。因为产生这些疑难 bug 的根本原因是：自己没有将知识点掌握通透。 学习的第一步是知道自己学习的这个知识问题是什么，答案是什么，然后找到这些问题和答案之间的关系，这个关系是我们需要学习的东西，最后能把这个关系通过通俗易懂的语言输出出来，那么这个知识你就学会了。 2019年将继续总结自己在开发中遇到的问题，将心得体会写成博客分享出来。同时，也发现以往博客的一些问题，要么是在某一方面将操作步骤写的特别细致，但又没有触及到问题的本质；要么在某一点上一笔带过，没有罗列出具体流程。同时，研究的技术点比较分散，没有形成一个前后呼应的体系。今年，一定要尝试将不同的技术点分析清楚，形成一个完整的技术体系。 不足认识到目前的不足之处： HTML 、CSS 和 JavaScript 是必须掌握的，需要补足前端基础的短板。既然选择了前端开发相关的技术栈就需要制定一个学习周期和学习计划。 计划技能 — 深入学习前端 HTML 、CSS 和 JavaScript 等前端基础技术。 心态 — 放松 + 自我激励。 工具 — 前端开发工具（IDE）的熟练使用。 共勉不怕路长，就怕心老！ 保持好奇，继续热爱！ 自己重新定位，选择真正适合自己的方向，重新出发，发现更好的自己。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://XibHe.github.io/tags/年终总结/"}]},{"title":"离线与同步","date":"2018-10-24T16:00:00.000Z","path":"2018/10/25/OffLineWithSync/","text":"在弱网环境下，将要面对一些问题：频繁请求网络造成请求超时；完全没有网络导致请求失败。那么，针对这种特殊而又普遍的现象，需要做一些额外的功能去弥补弱网环境下的操作体验。于是，针对某些重要功能的离线模式就诞生了！ 离线功能是为了满足用户在较短时间断网（离线时间最长支持15天）或无法访问服务器的情况下，可以正常的进行部分业务开展；从而保证对核心业务不会造成较大影响。 支持离线模式的模块 登录 看病开方 新增处方支持离线 处方列表支持离线 零售卖药 新增售药单支持离线 售药列表支持离线 患者管理 新增患者支持离线 患者管理支持离线 药房管理 新增药品支持离线 药品管理支持离线 我的 诊所管理支持离线 系统设置支持离线 账号设置支持离线 离线业务的具体步骤1. 监听当前设备所处的网络状态？离线模式切换所经历的三个过程： 提示用户 “失去网络连接，3秒后重试”，之后进入 “网络连接中…” 状态； 如果重试3次均失败，提示用户 “重新连接失败，进入离线状态”； 1秒后，提示信息变更为 “因当前网络不可用，您已进入离线状态；离线状态只可使用部分功能！”。 离线状态切换的三种状态， typedef NS_ENUM(NSInteger,offlineNetType) { Off_line,//离线 In_the_Internet,//联网中 Network_retry//联网重试 }; 监听当前网络的连接状态，若此时未发现可靠网络连接或网络连接失败，则需要经历以上三个阶段，进行离线模式的转换。具体监听步骤如下： 增加一个单利，并在单利中声明一个 BOOL 值的属性； @interface Singleton : NSObject @property(nonatomic,assign)BOOL hasNet;//是否有网络 @end 初始化时设置该属性默认值为 YES, static Singleton *share = nil; @interface Singleton() @end @implementation Singleton - (instancetype)init { self = [super init]; if (self) { self.hasNet = YES; } return self; } + (instancetype)shareInstance { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ share = [[Singleton alloc] init]; }); return share; } @end 在工具类中增加判断网络 SimplePing 是苹果封装好的关于 ping 的类，用于检测网络的连接状态。SimplePing 是一个封装低层级的 BSD Sockets ping 函数的类。使用这个类创建实例，设置委托然后调用 -start 方法开始在当前的 run loop (运行循环)中。如果顺利的话你很快就会得到 -simplePing:didStartWithAddress: 这个委托的回调。之后在这个回调里你就可以调用 -sendPingWithData: 来发送一个 ping，然后等待接收回调 -simplePing:didReceivePingResponsePacket:sequenceNumber: 和 -simplePing:didReceiveUnexpectedPacket: 首先新建单利类 LZNetworkAvailability，在初始化方法中指定要 ping 的主机名称， static LZNetworkAvailability *share = nil; @interface LZNetworkAvailability()&lt;SimplePingDelegate&gt; @end + (void)shareInstanceNetworkAvailability{ share = [[LZNetworkAvailability alloc] init]; } -(instancetype)init{ if (self = [super init]) { NSString *host = @&quot;usersystem.test.com&quot;; SimplePing *pinger = [[SimplePing alloc] initWithHostName:host]; pinger.delegate = self; pinger.addressStyle = SimplePingAddressStyleAny; self.pinger = pinger; [self.pinger start]; } return self; } @end 接下来实现 SimplePing 的代理方法，SimplePingDelegate 一共有6个方法，分别对应 ping 的不同状态： //开始进行网络检测 - (void)simplePing:(SimplePing *)pinger didStartWithAddress:(NSData *)address; //网络检测失败 - (void)simplePing:(SimplePing *)pinger didFailWithError:(NSError *)error; //发送网络包成功 - (void)simplePing:(SimplePing *)pinger didSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber; //发送网络包失败 - (void)simplePing:(SimplePing *)pinger didFailToSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber error:(NSError *)error; //收到网络包回应 - (void)simplePing:(SimplePing *)pinger didReceivePingResponsePacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber; //收到错误的网络包 - (void)simplePing:(SimplePing *)pinger didReceiveUnexpectedPacket:(NSData *)packet; 然后分别在开始进行网络检测和网络检测失败的代理方法中设置单利类 Singleton 中 hasNet 属性的值， /** * start成功，也就是准备工作做完后的回调 */ - (void)simplePing:(SimplePing *)pinger didStartWithAddress:(NSData *)address { // 发送测试报文数据 [self.pinger sendPingWithData:nil]; Singleton *sin = [Singleton shareInstance]; if (!sin.hasNet) { sin.hasNet = YES; [[NSNotificationCenter defaultCenter] postNotificationName:networkCanBeUsedNotification object:nil]; } } 网络检测失败, //网络检测失败 - (void)simplePing:(SimplePing *)pinger didFailWithError:(NSError *)error { NSLog(@&quot;didFailWithError&quot;); [self.pinger stop]; Singleton *sin = [Singleton shareInstance]; sin.hasNet = YES; if (sin.isOverdue) { if ([[UIViewController getCurrentVC] isKindOfClass:[[LZMediator sharedInstance] LZLoginComponents_loginViewController].class] || [[UIViewController getCurrentVC] isKindOfClass:[[LZMediator sharedInstance] LZLoginComponents_forgetPwdViewController].class]) { if (sin.hasNet) { sin.hasNet = NO; [[NSNotificationCenter defaultCenter] postNotificationName:networkCanNotUsedNotification object:nil]; } return; } LZCustomAlertView *alertView = [[LZCustomAlertView alloc] initWithTitle:@&quot;温馨提示&quot; content:@&quot;很抱歉，过期诊所不可进入离线模式&quot; close:nil certain:@&quot;我知道了&quot; closeButtonBlock:nil certainButtonBlock:^(LZCustomAlertView *alertView) { [LZMainHandler loginOutInitRemovePwd:NO backToLogin:YES]; if (sin.hasNet) { sin.hasNet = NO; [[NSNotificationCenter defaultCenter] postNotificationName:networkCanNotUsedNotification object:nil]; } }]; [alertView show]; }else{ if (sin.hasNet) { sin.hasNet = NO; [[NSNotificationCenter defaultCenter] postNotificationName:networkCanNotUsedNotification object:nil]; } } } 2. 使用LZNetworkAvailability测试网络连接状态基于 SimplePing 的 LZNetworkAvailability 类可以在任何线程上使用，但是用作单例必须限制在指定的开启运行循环的线程。由于在应用程序启动时，就需要实现网络的检测，所有，在 AppDelegate 里进行初始化， - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { //开始网络检测 [LZNetworkAvailability shareInstanceNetworkAvailability]; } 注意：这里需要特别注意的一点，网络请求会存在失败的情况，而网络连接问题同样会导致请求失败。这里就需要对这种情况失败情况进行检测，在封装的网络请求方法中，调用 shareInstanceNetworkAvailability 进行检测， //基本请求接口，是否发送token失效通知 + (void)baseRequestWithParam:(NSDictionary *)param path:(NSString *)path method:(LZHttpRequestType)method loseEfficacy:(BOOL)loseEfficacy success:(void(^)(LZHttpResponseModel *responseModel))success failure:(void(^)(NSError *error))failure{ [[LZHttpClient defaultClient] requestWithPath:path method:method parameters:[self getDetailDicWithParam:param] prepareExecute:^{ } success:^(AFHTTPRequestOperation *operation, id responseObject) { LZHttpResponseModel *model = [LZHttpResponseModel mj_objectWithKeyValues:responseObject]; NSLog(@&quot;\\n****************response***********:\\n%@\\n *******************url************:\\n%@ \\n*****************param**********\\n%@&quot;,responseObject,operation.request.URL,param); if ([model.body.code isKindOfClass:[NSString class]] &amp;&amp; ![model.body.code isEqualToString:SUCCESS_CODE] &amp;&amp; ![model.body.code isEqualToString:SUCCESS_CODE_NEW] &amp;&amp; ![model.body.code isEqualToString:@&quot;0330&quot;] &amp;&amp; ![model.body.code isEqualToString:@&quot;0336&quot;] &amp;&amp; ![model.body.code isEqualToString:@&quot;0798&quot;]) { } if (success) { success(model); } } failure:^(AFHTTPRequestOperation *operation, NSError *error) { Class class = NSClassFromString(@&quot;LZNetworkAvailability&quot;); BeginUndeclaredSelectorWarning [class performSelector:@selector(shareInstanceNetworkAvailability) withObject:nil]; EndUndeclaredSelectorWarning if (failure) { failure(error); } }]; } 这里通过 NSClassFromString 找到动态加载的类，直接调用类中的方法。 3. 为确保您数据的准确性，请尽快恢复设备的网络连接!离线数据的保存最长时间是多少？ 离线登录需要判断离线时间，并给出提示？ 离线数据在有网环境下的同步利用 GCD 中的 dispatch_semaphore 即，信号量来实现不同模块数据的同步。 GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。Dispatch Semaphore 提供了三个函数。 离线数据上传， #pragma mark - 离线数据上传 - (void)offLineAllDataUploadWithSync:(BOOL)sync { //每次上传都需要新创建一个数组来保存成功返回的流水号 NSMutableArray *serialNumberMuArr = [[NSMutableArray alloc]init]; [LZUserDefaults setObject:serialNumberMuArr forKey:PreferenceKey_OffLine_SerialNumberMuArr]; //保存一个开关 [LZUserDefaults setObject:@&quot;0&quot; forKey:PreferenceKey_OffLine_OfflineUploadComplete]; //顺序执行 信号量 dispatch_semaphore_t sem = dispatch_semaphore_create(1); dispatch_queue_t queue = dispatch_queue_create(&quot;OfflineDrugReductionInventoryoffLineAllDataUpload&quot;, NULL); dispatch_async(queue, ^{ dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;WX患者模块&quot;); [self offLineNetWorkWithType:@&quot;CP&quot; withSem:sem]; // dispatch_semaphore_signal(sem); }); if (sync) { dispatch_async(queue, ^{ dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;WX设置模块&quot;); [self offLineNetWorkWithType:@&quot;CE&quot; withSem:sem]; // dispatch_semaphore_signal(sem); }); } dispatch_async(queue, ^{ dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;WX处方模块&quot;); [self offLineNetWorkWithType:@&quot;RP&quot; withSem:sem]; // dispatch_semaphore_signal(sem); }); dispatch_async(queue, ^{ dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;WX零售模块&quot;); [self offLineNetWorkWithType:@&quot;RS&quot; withSem:sem]; // dispatch_semaphore_signal(sem); }); dispatch_async(queue, ^{ dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;WX预约挂号&quot;); [self offLineNetWorkWithType:@&quot;RE&quot; withSem:sem]; // dispatch_semaphore_signal(sem); }); dispatch_async(queue, ^{ dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;WX数据上传完毕&quot;); [LZUserDefaults setObject:@&quot;1&quot; forKey:PreferenceKey_OffLine_OfflineUploadComplete]; if (sync) { [self queryResultFromBackStage]; }else { dispatch_async(dispatch_get_main_queue(), ^{ self.actionBlock(); }); } dispatch_semaphore_signal(sem); }); } 数据同步遇到的一些问题成功请求一些编辑信息的接口后，会调用相应模块的同步接口。（这样做的利与弊？是否适用于每个数据同步操作？） 后续的优化现在生产上一半的问题是数据同步引起的，新的方案是引入第三方IM，诊所所有账户加入到聊天室，当数据产生并上传服务器成功后，发消息到聊天室，其他账户收到消息数据并处理。 写在最后未完，待续…… 参考资料ping iOS-ping 网络小工具 SimplePing –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"数据同步","slug":"数据同步","permalink":"http://XibHe.github.io/tags/数据同步/"}]},{"title":"(译)重写代码会失败的几个征兆","date":"2018-08-09T16:00:00.000Z","path":"2018/08/10/RebuildFlagsSignaling/","text":"总有一个理由去重构项目。也许你是一个的取得了一些成功，而你的工程师们吵着平台需要改进，要从头开始进行项目重构的CEO。也许你是主管或IT领导，在反复权衡重写老旧项目需要付出多大的成本。也许你是一个已经开始重写老项目的主程(我是疯了吗?)。无论如何，你可能已经知道重构老项目，像关于税收改革或无政府状态的讨论一样，只是稍微有点危险，你永远不知道自己在重构时实际遇到的难题和之前想象中会遇到的根本不是那么回事。 但是，尽管一些德高望重的人（当然，其实只是 Joel Spolsky ），对项目进行重构，即使在某些时候，这是正确的选择。但重建仍是一场危险的旅程，你的重构工作很可能由于一些无法预知的难题而失败。 因此，我们提出 “为达到目的，该如何去做”，以下五个标志决定了重构最终的成功与否，你究竟是不是疯了，要看你最终重构的结果如何。 1. 没有清晰的重构目标，为重构而重构。重构必须增加新的价值。事实上，如果在重构的前6个月仍看不到项目重构所带来的价值，你就应该思考项目重构的意义是什么？需要慎之又慎，因为进行大规模的重构工作会耗费大量的资源，老项目30个人花费一年多的时间写的，而现在却只花费6个月的时间进行重构。除非你的部门是 Google X 能够负担起长时间开发的费用。你最好能考虑一下。 如果你是一名经理，你自己不知道项目重构能带来的价值是什么，也许是时候结束重构了，或者如果你已经确定你想得到什么，做设计的冲刺与实际用户清楚地捕捉这一愿景和然后重新评估，如果重建的轨道上与您的用户想要什么。 进行 design sprint 与实际应用场景结合重新进行项目评估。 2. 你将面对大范围的转换式重写项目功能的转变很容易。只需要切换DNS记录和BOOM就能看到，应用程序在每个方面的全面变化是美学上令人愉快的。项目整体功能转换的重构是所有重构中最需要警惕的。它仅适用于非常简单的系统。有它仅适用于非常简单的系统的前期准备工作要做，这就是为什么渐进式的重构方式更好，因为：一个大的功能性重构等效于瀑布式方法。 如果你是一名经理，你需要让你的开发人员认识这一点，因为他们很可能正在努力推动一个大的功能性重构。当然，他们从来没有使用这些词，而是选择像“干净的石板”或“重新构架”的词语，但询问他们，我们还要多久可以将这些代码部署到生产环境？如果答案是3个多月了……那么他们很可能在做一个大范围的功能性重构。 3. 重构后的新系统速度比老系统慢这很简单：如果你在进行重构的同时，也在改进现有的老项目，以对冲重构风险并保持竞争优势(这是一个好主意)，但重建您现有的传统产品是不是能以更快的速度添加相同的特性，重构将永远也无法完成。 您的重建团队需要由技术优秀的开发人员组成，他们了解最新的技术，并有足够的脑力去理解遗留系统的复杂性(有趣的是，这似乎是由 **Kernighan 定路和 Peter Principle 混合而成的)。 此外，请确保你的重构小组（一个或多个）能够持续进步更快！不要基于第2-3个月的重建速度来判断。一个项目在初期总是进行的很快，因为复杂的问题尚未考虑，但在进行一段时间后速度就会减缓： 4. 你是不是和那些旧系统中的专家合作。任何专家都可以提供帮助 —— 旧系统的前开发人员，财务部的Marge，甚至是高级用户。这些人对重建至关重要，因为他们一开始就知道应用程序的所有问题。没有这些人，你会成为特斯勒定律的受害者。最终生成新系统的价值低于老版本。 可以将它们看作人类测试套件。他们会在几分钟内发现在重新构建中可能永远不会发现的细微实现错误。 涉及到的人。让他们觉得他们对重建是有帮助的(因为他们是参与者)。尽早得到他们的反馈。 5. 你打算删除那些很难用的功能假设您正在重建一个系统，该系统已经取得了一些成功，并且正在积极地为用户提供价值。在“精简化”构建的名义下，很容易陷入使用更少特性进行重构的陷阱。但是，这是否有意义？是的，传统的应用程序可能是缓慢的和丑陋的。但仔细想想，你的用户愿意忍受缓慢的和丑陋的使用这个系统！如果删除，他们使用的功能，你的用户会恨你。 这是否意味着你应该盲目地复制遗留系统的特性？当然不是！遗留技术所必需的一些特性已经变得僵化。现在有一些类似OCR的东西，可以取代表单字段的页面。这意味着你可以自由地重新想象这些特性或创建一个新的流程，该流程允许你删除操作，但是你不能删除需要完成的任务/整个流程，无论多么诱人。 让我们做个总结我希望你能注意到，在重构过程中，我们关注的是真实的、当前的价值交付。这就是为什么每次重新构建都要从彻底的设计冲刺开始，挖掘所有的增值特性。这次sprint 的核心方法是通过访谈获得最终用户和涉众的反馈，并通过原型确认你的发现。这确保了产品仍然以你所期望的方式满足市场需求，并在基于真实用户反馈的重构过程中留下了创新的空间。 如果你觉得必须在通过重新构建复制一个特别繁重的旧特性和添加新特性之间进行选择，那么你有一些选择。一种选择是使用 Martin Fowler’s strangler pattern 模式，通过这种模式，你可以在重新构建中创建新的功能，这些新功能可以同时且相对无缝地与旧功能集成，从而保留了那些功能，而无需重新创建它们。 有什么问题或意见吗？有什么问题吗？请随时联系我们! 原文地址5 Red Flags Signaling Your Rebuild Will Fail 附录Google X Google X，是谷歌公司最神秘的一个部门，位于美国旧金山的一处秘密地点，该实验室的机密程度堪比CIA，仅少数几位谷歌高层掌握情况，在其中工作的人，都是谷歌从其他高科技公司、各大高校和科研院所挖过来的顶级专家。Google的X实验室在联合创始人布林的带领下开发过谷歌眼镜和无人驾驶汽车等项目。 Design Sprint 设计冲刺（Design Sprint）是近些年从敏捷开发（Agile）延展出来的一种产品创新方法。由于谷歌创业部门（Google Venture）和用户体验设计部门（Google UX）、研发部门的充分运用和大力推广，因此在业界它也常常被称为Google Design Sprint。 与更早一些诞生的设计思维（Design Thinking）对照，我们注意到二者都是面向产品和服务的快速创新、解决棘手问题的体系，它们拥有高度相似的运作流程，分享完全一致的、以用户为中心的创意理念。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"重构","slug":"重构","permalink":"http://XibHe.github.io/tags/重构/"}]},{"title":"组件化初探","date":"2018-07-17T16:00:00.000Z","path":"2018/07/18/ModuleFirstExplore/","text":"项目经过三年多的迭代，总共有三拨人接手，代码整体风格各异，迭代后的旧代码与新代码揉在一起，难解难分。各功能模块间相互依赖，头文件多次重复引用，编译一次大概花费5分钟。不得不进行代码组件化后重构。关于应用架构以及组件化的方案 casatwy 已经说得很透彻了，在这里我就没有必要再班门弄斧了。这篇文章主要是记录自己项目组件化时如何拆分各个功能模块？抽离组件遇到了哪些问题？阶段性测试时遇到了哪些棘手的问题？因此，这篇文章的实践性较强，希望可以解决各位在组件化过程中遇到大部分问题。 更新说明更新记录: 2018 年 07 月，第一版。 2018 年 08 月，补充组件化架构图及一些说明。 现在项目中存在的问题代码不够整齐，目录结构混乱，分类不够明确，随着一次次的版本迭代，增加了不同的业务线，开发人员变动比较频繁，工程越来越臃肿。莫名其妙的继承关系，Base类，Expand类，Category混乱，三者之间存在重复的功能，这也为后面提到的在组件化过程中遇到一个棘手问题埋下了炸弹。 期望达到的效果 解除各个功能模块间的依赖； 可以单独引入并测试某一个功能组件； 功能与功能之间不再相互引用重复的未使用到的类； 将一个单一的工程项目，分解成各个独立的组件，然后按照某种方式，任意组合成一个拥有完整业务逻辑的工程。 组件划分粒度及其相互间的依赖组件化是为了解决项目中遇到的问题，不是为了组件化而组件化。模块的划分，以及模块的扩展性，可以增加新的模块，为将来业务的拓展留有余地。基础模块的划分很重要，其他的模块都是建立在基础模块之上的。 兵马未动，基础组件先行。 基础组件(LZBasisComponents)：基本配置(常量，宏)，分类(各类系统类的拓展)，网络(AFN的封装)，工具类(loading，字符串操作，日期格式处理，文件操作等) 数据库组件(LZDataBaseComponents)：封装了各个功能模块的数据库增，删，改，查的基本操作，基于 FMDB 封装了基本的 SQLite 数据库操作； 功能组件(LZFunctionComponents)：主要用来存放一些自定义控件，eg.自定义弹出窗，错误信息提示View，自定义KeyBoardView，一些按钮和label； 登录组件(LZLoginComponents)：项目中通过登录操作初始化一些基本配置，配置账号体系下用户所能使用的权限。基于登录功能业务上衍生了广告页，热门活动宣传页，某个版本需要强制升级的弹出窗，以及用户协议等功能。 工具箱组件(LZToolsComponents)：项目中处理不同设备间数据同步的功能，页面展示的权限控制功能。 自顶向下设计，自底向上实现，先测量，后优化。— casatwy 以上所列的 6 个组件可以统称为项目基础组件，自基础向上延伸到其他功能模块，为其他模块提供底层支持，同时，在生成私有库时，其他功能模块也要与之建立起依赖关系。 这里数据的持久化基于数据库组件，其中公共类的维护 (以数据库组件为例，每个人维护自己模块下的数据库操作类。eg.LZDatabaseHelper+PatientModel 即为，患者组件下对应的所有患者的数据库操作，处理后的数据以 PatientModel 为存储形式。) 找到所有需要的模块， 把模块放在该放的地方。 — casatwy 一个公共模块，如果多个模块都会用到，那么最好是将它抽成一个组件。eg. LZToolsComponents 组件中，就存放了一些工具类，这些工具类无法下沉到基础组件中。但其它模块却会用到。 高内聚，低耦合。 接下来按功能模块划分组件就比较直观了，比较典型的就是根据 TableBar 来划分，这里适用于大部分 App 的功能模块。以下这些功能组件的划分才是组件化划分的核心所在，也只有将功能组件独立出来，才能达到高内聚，低耦合的目的。 工作台组件(LZWorkTableComponents)：主要处理项目中核心功能 — 开方，该模块下由三个小模块组成； 药房管理组件(LZPharmacyComponents)：涉及到药品库存管理的模块； 患者管理组件(LZPatientManageComponent)：管理患者个人就诊信息； 个人中心组件(LZMineComponents)：配置用户的个人信息，设置处方模板，管理诊所子账号，增值服务，账号设置，配置外接硬件(蓝牙打印机，激光打印机，扫码枪)等 所有H5功能组件(LZWebViewComponents)：该组件统一管理统计报表，专家咨询，知识课堂，活动商城等功能模块的 web 页面。 以上各功能组件都分别对应各自的中间件，用来同其他功能组件进行通讯。如下， 登录中间件(LZLoginComponents_Category)：主要用来处理登录组件(LZLoginComponents)与主工程之间的数据通讯； 工作台中间件(LZWebViewComponents_category) 药房管理中间件(LZPharmacyComponents_Category) 患者管理中间件(LZPatientManageComponent_Category) 个人中心中间件(LZMineComponents_Category) H5交互中间件(LZWebViewComponents_category) 项目最终的架构图如下， 其中，webView组件处理了三个H5功能模块的页面展示及数据交互，这里把它归为业务组件的范畴。 以上是基础组件和功能组件的划分，正是有了这些泾渭分明的区分，才能为组件化之间解耦提供基础的支持。 MVC VS MVVM对于组件化后继续使用 MVC 架构还是替换为 MVVM架构。这二者只是代码层次划分，主要是针对数据流动的方向而言。这里以解决问题为主，而不是生搬硬套架构。本片文章主要用来介绍组件化的实现流程，这里就不对架构做详细叙述了。但随着组件化的深入，这二者间终会有一个抉择，后续计划单独整理出二者之间关系的文章。 CoCoaPods 私有库通过 cocopods 把组件打包成单独的 私有pod 库来进行管理，这样就可以通过 podfile 文件，进行动态的增删和版本管理了。 1.使用模板快速创建测试工程（组件所在的工程） $ pod lib create LZBasisComponents 按照提示，填写完以上信息后， Xcode 会自动打开创建的测试工程，在测试工程的文件夹下，可以看到的路径如下， 其中，将抽离出的基础组件 LZBasisComponents 托至 Classes 文件夹下，此时，cd 到模板工程 Example 所在目录，执行 $ pod install 我们就可以在测试组件的模板工程中修改文件了。 2.在 GitLab 上创建一个用来存放基础组件的仓库LZBasisComponents这里使用开源的 GitLab 作为代码托管的 git 服务器，安装完成后可以在上面新建组件。当然也可以付费使用基于 GitHub 托管，免费的有 码云 和 码市。 3.配置私有库的 .podspec 文件在上文中生成模板工程的同时，也会生成一个 . podspec 的文件。我们需要单独设置该文件，之所以配置 .podspec 文件，是为了将本地私有库与 GitLab 上远程私有库进行关联，多人开发时通过远程私有组件库进行代码的同步。远程索引库 . podspec 即，组件描述文件，里面描述了组件文件的源码地址，框架简介，私有库作者，版本号，资源文件路径等信息。我们使用 $ pod search 检索索引文件，找到 . podspec 中的源码地址，然后将项目down到本地。其主要配置如下， s.name = &quot;LZBasisComponents&quot; s.version = &quot;1.2.2.1&quot; s.summary = &quot;LZBasisComponents.&quot; s.homepage = &quot;http://192.168.11.11/CloudOfficeModulization/LZBasisComponents&quot; s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; } s.author = &quot;xibHe&quot; s.platform = :ios, &quot;8.4&quot; s.source = { :git =&gt; &quot;http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git&quot;, :tag =&gt; s.version.to_s } s.source_files = &quot;LZBasisComponents/LZBasisComponents/Classes/**/*.{h,m}&quot; s.resource_bundles = { &#39;LZBasisComponents&#39; =&gt; [&#39;LZBasisComponents/LZBasisComponents/Assets/*.{png,plist}&#39;] } s.requires_arc = true s.dependency &quot;Masonry&quot;, &#39;~&gt; 1.1.0&#39; s.dependency &quot;YYKit&quot;, &#39;~&gt; 1.0.9&#39; s.dependency &quot;ReactiveObjC&quot; 具体的配置如下： s.homepage 组件在 GitLab 的主页面 s.source 真实组件的地址，在 GitLab 中新建库时会生成该地址 s.source_files 组件中对应目录下的文件夹 s.resource_bundles 存放资源文件的类型 s.dependency 依赖其他的框架或组件 这里是组件中用到的主要的配置，还有其它的与私有 pod 相关的配置。 注意: 组件的依赖关系，各个组件中的 .podspec 文件中通过 s.dependency 设置了该组件与其他三方框架或者其他业务组件的依赖关系，这里各个组件前期可以暂时依赖其他业务组件，但后期当所有组件抽出后，需要解除与其他业务组件的依赖关系。即，将 s.dependency 下的依赖注释掉。 4.将上面创建的模板工程，提交到 GitLab 上创建的远程代码仓库中主要是通过 git 命令上传，如下 1. cd 到 模板工程所在的 Example 对应的私有库目录2. 可以先查看当前工程文件的状态，红色为未提交 git status 3. 提交到暂缓区 git add . 4. 将本地库与远程代码仓库进行关联 git remote add origin http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git 5. 初始化提交 git commit -m “Initial commit” 6. 将本地分支的更新，推送到远程主机 git push -u origin master 7. 给远程组件库打 tag git tag -a 1.2.2.1 -m ‘v1.2.2.1’ git push origin master 保持 s.version = “1.2.2.1” 的版本与远程私有库的 tag 一致。 5.主工程中使用 CoCoaPods 导入私有组件库打开并编辑主工程中的 Podfile 文件，如下， platform :ios, &#39;8.4&#39; source &#39;http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git&#39; source &#39;https://github.com/CocoaPods/Specs.git&#39; workspace &#39;CloudOffice.xcworkspace&#39; #use_frameworks! inhibit_all_warnings! def common_pods pod &#39;LZBasisComponents&#39;, :path =&gt; &#39;/Users/huahua/Documents/Module/LZBasisComponents&#39; end target ‘CloudOffice’ do common_pods end target ‘CloudOfficeTest’ do common_pods end target ‘CloudOfficeTrial’ do common_pods end 通过命令 pod repo 查看本地已存在的索引库， 14-cloudofficemodulization-cloudofficespec - Type: git (master) - URL: http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git - Path: /Users/huahua/.cocoapods/repos/14-cloudofficemodulization-cloudofficespec master - Type: git (master) - URL: https://github.com/CocoaPods/Specs.git - Path: /Users/huahua/.cocoapods/repos/master GitLab 中远程私有库的地址： source &#39;http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git&#39; 公有库的地址： source &#39;https://github.com/CocoaPods/Specs.git&#39; cd 到主工程 Podfile 文件所在目录，执行 pod install 命令，再次打开项目就可以在 Pods 文件夹下的 Development Pods 文件夹中找到 LZBasisComponents 组件。 注意：pod ‘LZBasisComponents’, :path =&gt;’/Users/huahua/Documents/Module/LZBasisComponents’ 对应的路径可以是存放本地私有库(已update远程私有库)的路径，也可以是 步骤4 中对应的远程私有库，可以通过通过 tag 来导入不同的私有组件库的版本，如下： pod &#39;LZBasisComponents&#39;, &#39;~&gt; 1.2.2.1&#39; 也可以通过 SourceTree 或者 GitHub Desktop 等拥有可视化界面的项目版本控制软件，进行 git 项目私有库的管理。 组件之间及各组件与主工程间通讯(中间件)目前市面上有两种组件间的通讯方式： 利用 url-scheme 方案 利用 runtime 实现的 target-action 方法 两种方式都对应一些开源库，如下 URL-Scheme库： JLRoutes routable-ios HHRouter MGJRouter Target-Action库： CTMediator 采用 url-scheme 方案，要本地调用和远程调用之间如何相互调用？提供给 url 什么样的参数？如何处理非常规对象与本地组件间的调度？ 在iOS领域里，一定是组件化的中间件为openUrl提供服务，而不是openUrl方式为组件化提供服务。 — casatwy URL注册对于实施组件化方案是完全不必要的，且通过URL注册的方式形成的组件化方案，拓展性和可维护性都会被打折。 — casatwy 采用 runtime 实现的 target-action 方法 注册 URL 的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用 runtime 就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime 由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。 由于通过 runtime 做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。— casatwy 如图，target-action 模式，即，目标-行为，行为即要调用的方法，目标即消息的接收对象（Objective-C 语言使用消息机制，类似但不同于方法调用）。整个过程为：用户点击按钮，触发某事件发生，该消息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对象，但通常为控制器（Controller）。 target-action 的代码实现逻辑： 运行时，runtime是一套底层的C语言api，可以通过runtime获取类的私有变量；动态增加类、成员变量和方法；动态修改类、成员变量和方法；对换两个方法的实现（Swizzle） NSInvocation 和 performSelector：withObject：，直接调用某个对象的消息 调用methodSignatureForSelector：方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取到，则返回非nil，创建一个NSInvocation并传给forwardInvocation: 调用编译器指令，返回一个给定类型编码为一种内部表示的字符串 提供外部模块调用的方法。 组件之间的交互，通过 Action 暴露可调用接口，所有组件都通过组件自带的Target-Action 来响应，也就是说，模块与模块之间的接口被固化在了 Target-Action 这一层，避免了实施组件化的改造过程中，对业务层的侵入，同时也提高了组件化接口的可维护性。 基于以上原因，这里我推荐 Target-Action 方案。具体操作流程如下， 新增基于 CTMediator 的组件 LZMediator基于 CTMediator 新建用于传递组件讯息的组件 LZMediator，该组件参考 CTMediator 中的 CTMediator 类，做了一些简化处理。具体创建操作参照上文中使用 CoCoaPods 建立私有库，这里就不再赘述了。 新建与其它组件通讯的中间件这里的所说的中间件也是以 pod 私有库的形式存在于项目中，其仍是代表不同功能模块的组件。以工作台组件（LZWorkTableComponents）为例，其它组件若想调用工作台组件中的某个控制器时，不能直接调用，而是需要通过工作台中间件（LZWorkTableComponents_Category）暴露的接口调用。同上文中使用CoCoaPods 建立私有库一样，先生成模板工程，然后上传到 GitLab 远程代码厂库中。唯一需要注意的是：需要在工作台中间件的 .podspec 文件中，增加对 LZMediator 组件的依赖，如下： s.dependency &quot;LZMediator&quot; 通过这种依赖关系，将 LZMediator 引入到工程中。 在中间件中新增用于通讯的 LZMediator 类别在上面新建的工作台中间件（LZWorkTableComponents_Category）中新建基于 LZMediator 的类别，注意统一类别的名称，以工作台中间件为例，最终生成的类名为：LZMediator+LZWorkTableComponents.h 和 LZMediator+LZWorkTableComponents.m 接下来就是按照基于 Mediator 的一套逻辑，通过实现 target-action 的方法来进行不同组件间的通讯。例如，某个组件需要调用工作台组件中的某个控制器时， LZMediator+LZWorkTableComponents.h 中声明中间件调用的返回工作台组件中某个控制器的实例方法： #pragma mark - 患者管理组件调用 /** 看病开方详情页面 @return 返回实例 */ - (UIViewController *)LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic:(NSDictionary *)params; LZMediator+LZWorkTableComponents.m 中实现该方法： #pragma mark - 统一前缀 NSString *const kLZMediatorTarget_LZWorkTableComponents = @&quot;LZWorkTableComponents&quot;; #pragma mark - 方法名称 NSString *const kLZMediatorAction_newDoctorPrescribingViewController = @&quot;newDoctorPrescribingViewController&quot;; // 看病开方详情页面 - (UIViewController *)LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic:(NSDictionary *)params { UIViewController *viewController = [self performTarget:kLZMediatorTarget_LZWorkTableComponents action:kLZMediatorAction_newDoctorPrescribingViewController params:params shouldCacheTarget:NO]; if ([viewController isKindOfClass:[UIViewController class]]) { return viewController; } return [UIViewController new]; } 这里需要注意方法中传递的参数 kLZMediatorTarget_LZWorkTableComponents 和 kLZMediatorAction_newDoctorPrescribingViewController 分别对应工作台组件中 target-action 所在的模块 (也就是提供服务的模块，这也是单独的repo，但无需被其他人依赖，其他人通过category调用这里的功能），这两个参数，前者对应的是 target-action 所在组件中的以 Target_ 为前缀的类，后者对应该类里的具体的以 Action_ 为前缀声明的某个方法。前面所说的利用 runtime 实现的 target-action 方法，指的正是这个地方。 注意: 这两个参数值，一定要与工作台组件中 Target 目录下的类名相一致!!! 切记！ 切记！ 切记！ 在 target-action 所在的组件中增加提供服务的类在工作台组件（LZWorkTableComponents）中 Target 目录下新建名称为： Target_LZWorkTableComponents 继承于 NSObject 的类，这个类的命名规则与上面说的 kLZMediatorTarget_LZWorkTableComponents 参数相一致，然后新增方法，方法名以前缀 Action_ 开头，同样需要与上面说的kLZMediatorAction_newDoctorPrescribingViewController 参数相一致。如下： Target_LZWorkTableComponents.h 中声明中间件调用的返回工作台组件中某个控制器的实例方法： #pragma mark - 患者管理组件调用 /** 返回LZNewDoctorPrescribingViewController实例 */ - (UIViewController *)Action_newDoctorPrescribingViewController:(NSDictionary *)param; Target_LZWorkTableComponents.m 中实现该方法： #import &lt;LZDataBaseComponents/PationModel.h&gt; #import &quot;LZNewDoctorPrescribingViewController.h&quot; /** 返回LZNewDoctorPrescribingViewController实例 @param param 患者dictionary @return LZNewDoctorPrescribingViewController实例 */ - (UIViewController *)Action_newDoctorPrescribingViewController:(NSDictionary *)param { PationModel *pationModel = [[PationModel alloc] init]; [pationModel setValuesForKeysWithDictionary:param]; LZNewDoctorPrescribingViewController *newDoctorPrescribinVC = [[LZNewDoctorPrescribingViewController alloc] init]; newDoctorPrescribinVC.model = pationModel; return newDoctorPrescribinVC; } 这里 PationModel 为数据库组件中的类，需要注意一下这里使用尖括号引入的头文件，LZNewDoctorPrescribingViewController 控制器为工作台组件中的类。 在其它组件中调用中间件的方法进行通讯这里仍以工作台组件（LZWorkTableComponents）为例，比如，在患者组件中想跳转至工作台组件中的看病开方详情页（LZNewDoctorPrescribingViewController），需要通过上面的工作台中间件（LZWorkTableComponents_Category）进行通讯，而不是直接导入 #import “LZNewDoctorPrescribingViewController.h” 头文件调用。具体事例，如下： 在患者管理组件中， #import &lt;LZWorkTableComponents_Category/LZMediator+LZWorkTableComponents.h&gt; NSDictionary *pationModelDic = model.mj_keyValues; UIViewController *newDoctorVC = [[LZMediator sharedInstance] LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic :pationModelDic]; [weakSelf presentViewController: newDoctorVC animated:YES completion:nil]; 这里通过一个 LZMediator 的单例来调用工作台中间件（LZWorkTableComponents_Category）中 LZMediator 的类别(LZMediator+LZWorkTableComponents) 中的方法，获得 view controller 之后，在这种场景下，到底 push 还是 present ，其实是要由使用者决定的，mediator 只要给出 view controller 的实例就好了。 原工程中资源文件的处理这里所说的资源文件指的是项目中的图片，现在主工程中的 Assets 存放全部的资源文件，需要将其移动到各个组件中去。在上文新建模板工程时，对应文件夹下也会生成一个 Assets 文件夹，这个文件夹就是用来存放组件中使用到的图片文件的。 针对这个文件夹中图片资源的存放和使用，有两种方式： 直接将图片 copy 到模板工程中 Assets 文件夹下，包括 @2x, @3x 图片； 在工程中组件下 Resources 目录下，新建 Assets.xcassets 文件，直接将图片拖放到 Assets 文件中，与主工程中 Assets 文件的用法一致。 针对以上两种存放图片的方式，在文件中读取图片的方式也完全不同。方式一： s.resource_bundles = { &#39;LZBasisComponents&#39; =&gt; [&#39;LZBasisComponents/LZBasisComponents/Assets/*.{png,plist}&#39;] } 需要在对应组件的 .podspec 文件中设置访问图片资源的路径及资源文件类型，然后在项目中导入所要访问的图片，最后访问图片，如下： [UIImage imageWithName:@&quot;xtsz_N&quot; bundleName:@&quot;LZBasisComponents&quot;]; 访问图片时需要在方法 bundleName: 后面加上图片所在的组件名称。可以写一个 UIImage 的类别统一加载组件图片资源， @interface UIImage (Image) //组件之间加载图片资源 + (UIImage *)imageWithName:(NSString *)imageName forClass:(Class)sourceClass; + (UIImage *)imageWithName:(NSString *)imageName bundleName:(NSString *)bundleName; + (UIImage *)imageWithName:(NSString *)imageName bundleName:(NSString *)bundleName forClass:(Class)sourceClass; 方式二：相比方式一，更加简单，管理图片也更加直观。可以直接使用原来的方法imageWithName 来加载图片。但这里需要注意这个存放资源图片文件在组件中对应的路径并不在模板工程 Assets 路径下。 受工期影响 抽取组件前未将项目中冗余的类删除，导致这些类最后被抽到组件中； 在抽取组件时，版本仍在继续迭代，这就造成组件抽取完成后，需要再花时间合并新代码到组件中； 前期为了快速分离功能组件，往往将与该组件关联的其它功能模块的代码也抽到组件中； 出现 2 中的情况，就需要记录一下新版本迭代修改了组件中的哪些类，还要记录提测后修改 QA 提出的 bug 时修改了哪些类，最后，再对比 Git 和 svn 的提交日志，查看修改了哪些类。 组件化过程中遇到的问题及解决方式抽离业务组件，一般分为四步，这里以抽离患者管理组件为例： 将患者管理模块所有代码 copy 到新建的患者管理模板工程中（注意要将复制的代码放到 ReplaceMe.m 所在目录下）； 梳理患者管理中与主工程有交互的功能类，明确使用了哪些三方库和自定义控件，剔除未使用到的类，整理工程目录结构（这一步主要是整理现有的代码逻辑，结构，去除冗余的类）； 将模板工程中患者管理代码中涉及数据库操作，公用模块，全局自定义控件等其它组件的功能抽出来。那些暂时无法划分到其它组件中的类，暂时 copy 一份放到 Redundancy 文件夹下。患者管理组件只能导入其它组件并引用后，才能使用。不能再以直接引入主工程的头文件的方式调用类了（这一步主要是从组件角度斩断组件与主工程单方面的关联）； 将患者管理模块所在的模板工程上传至 GitLab，然后在已集成了基础组件的壳工程中引入该组件并调试。 第 4 步建立在壳工程之上，这里所谓的壳工程是指集成了主工程 AppDelegate 中初始化功能和基础组件，可以进行登录操作，同步用户的数据。有了数据就可以进行页面展示，就能进一步测试组件功能是否完整。 1. duplicate symbols for architecture arm64duplicate symbol_LZKanBingHomeViewController._closeImageV in: /Users/huahua/Library/Developer/Xcode/DerivedData/CloudOffice-enrpnhjeeqovpuffsdjmigxqovpi/Build/Intermediates.noindex/CloudOffice.build/Debug-iphoneos/CloudOfficeTest.build/Objects-normal/arm64/LZKanBingHomeViewController.o /Users/huahua/Library/Developer/Xcode/DerivedData/CloudOffice-enrpnhjeeqovpuffsdjmigxqovpi/Build/Products/Debug-iphoneos/LZWorkTableComponents/libLZWorkTableComponents.a(LZKanBingHomeViewController.o) ld: 31 duplicate symbols for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 根据错误提示，删除主工程中的重复类文件，因为这些类已经抽离到组件中了。这也是集成组件后联调出现最对，最常见的一种错误。 2. _OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o) ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation)objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o) ld: symbol(s) not found for architecture arm64 这个错误是由于向工程中某个组件下导入类时，未将导入类与与组件进行关联导致。根据错误提示 OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a 可以知道是工作台组件（LZWorkTableComponents）中的类（LZKanBingHomeViewController）未与组件建立关联。解决方式：在工程组件中选中 LZKanBingHomeViewController.m 切换到该类的 “Show the File inspector” 设置项中，检查文件的设置项。如图， 设置 “Target Membership” 下 “LZWorkTableComponents” 为选中状态，重新编译，即可。 3. Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’头文件重复引用的问题，可以在各个基础组件中新建 .h 头文件，用于存放其他类会用到类的头文件，使用时直接导入。例如： #import &lt;LZBasisComponents/LZBasisComponents.h&gt; #import &lt;LZDataBaseComponents/LZDataBaseComponents.h&gt; 4. [GlobalMethod showName:@”请输入正确手机号码” inView:self.headView.dianhuaView] 不执行这里 LZBasisComponents 中已经通过 GlobalMethod 类引入了MBProgressHUD，若在组件外重复引入新的 MBProgressHUD 会导致该代码不执行。 5. 暂时注释掉组件中跳转至其它组件控制器的方法由于组件间不能直接进行通讯，当用于处理组件间交互的中间件没有完成时，为了编译成功，可以先注释掉跳转到其它组件控制器的代码。 6. Reference to ‘LZHttpRequestPost’ is ambiguous+ (void)hasNewRemoteConsulationWithParam:(NSDictionary *)param success:(void(^)(LZHttpResponseModel *responseModel))success failure:(void(^)(NSError *error))failure{ [self baseRequestWithParam:param path:[LZHttpDomainManage sharedInstance].YCHZ method:LZHttpRequestPost success:success failure:failure]; } 很奇怪的一个问题，项目中顶一个一个网络请求类型的枚举 — LZHttpRequestType，项目中很多用到 LZHttpRequestPost 这个枚举类型就会报这个错误，但只要将该参数换成枚举所对应的整数值就行。暂时先这样解决，后来再看这个错误，觉得是头文件重复引用造成的，之前的老项目中有有一个叫 Foundation.h 的头文件，里面引用的是一些基本的配置类，工具类，还有一个很奇怪的引用，每个项目开发者都会在这个头文件里引入自己所编写功能的头文件。例如， /*************此.h 文件是用来导入公用的头文件的***************/ #import &quot;GlobalMacro.h&quot; #import &quot;URLMacro.h&quot; #import &quot;GlobalMethod.h&quot; #import &quot;PlaceholderTextView.h&quot; #import &quot;UIImageView+WebCache.h&quot; #import &quot;UIView+Frame.h&quot; #import &quot;MJRefresh.h&quot; #import &quot;HLNavigationController.h&quot; #import &lt;AdSupport/ASIdentifierManager.h&gt; #import &quot;NSString+MD5.h&quot; #import &quot;Masonry.h&quot; #import &quot;UILabel+LZLabel.h&quot; #import &quot;NSArray+LZAddition.h&quot; //多人开发，避免冲突 #import &quot;LWB.h&quot; #import &quot;DLN.h&quot; #import &quot;LYY.h&quot; #import &quot;XXL.h&quot; 注释是为了避免多人开发的冲突，在这些每个人姓名首字母缩写的头文件中，引入的是这个人所开发功能类的头文件，就这样一层套一层。在组件中如果引用了这个Foundation.h 头文件，很大几率会造成重复重复引用。而且还有一点需要注意：组件中若要引入其它组件类的头文件，最好以尖括号引入。例如，引入基本组件中的某个类， #import &lt;LZBasisComponents/LZHttpDomainManage.h&gt; 一些基本的配置类的引入，工具类的引入，则可以用包含这些类的所有头文件的一个总的 .h 头文件的形式引入， #import &lt;LZBasisComponents/LZBasisComponents.h&gt; 就这样一步步的将那些多余的头文件和姓名首字母缩写的头文件从 Foundation.h 中移除，去除重复引入的头文件。 7. iOS 9.3.5 系统下，页面布局错乱的问题组件拆分中遇到的一个很棘手的问题，在 iOS 9.3.5 的 ipad 上，左侧切换视图的选项显示不出来，同时，右侧页面布局错乱无法点击。运行项目， 点击Debug View Hierarchy 查看视图层级，发现左侧菜单所有切换按钮的布局都乱掉了，挤在一起了。主视图控制器中的 MainView 的 Frame 获取的一直都是错的，工程中 Frame 坐标的获取都是通过 UIView 的类别计算获取的，如果不通过类别获取是可以得到正确的值的。但即使将主视图和菜单中所有获取坐标的方式都通过系统方法获取，还是加载不出完整的视图。 最后搜索项目中所有与计算视图布局有关的类，发现了真相。主工程中有很多计算坐标的类别，这些类别重复定义了视图的坐标，需要移除未使用的类别。同时，将组件中计算坐标的 UIView+Frame 类移至主工程中，从 podFile 中移除 HandyFrame, 移除主工程中未使用到的 UIView+AutoLayout， UIView+TXFrame 等计算页面布局的类别。 8. Include of non-modular header inside framework module ‘LZBasisComponents.LZHttpClient’: ‘/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFURLRequestSerialization.h’Include of non-modular header inside framework module &#39;LZBasisComponents.AFHTTPRequestOperationManager_Synchronous&#39;: &#39;/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFHTTPRequestOperationManager.h&#39; AFN中头文件引用的包含了同一个头文件，删除报错类 .h 中一些重复的引用，改为 &lt; &gt; 引入。 AFHTTPRequestOperationManager+Synchronous.h 中引入 #import &lt;AFNetworking/AFHTTPRequestOperationManager.h&gt; AFHTTPRequestOperationManager+Synchronous.m 中引入 #import &lt;AFNetworking/AFNetworking.h&gt; LZHttpClient.h 中引入 #import &lt;AFNetworking/AFURLRequestSerialization.h&gt; LZHttpClient.m 中引入 #import &lt;AFNetworking/AFNetworking.h&gt; 9. 组件间的依赖关系组件间的依赖关系，若两个组件间存在依赖，则依赖于某个组件的另一个组件可以直接引用所依赖组件中类的头文件，不需要加 &lt; &gt; 导入（但为了明确组件中引用类的来源，同时避免头文件的重复引用，建议以 &lt; &gt; 的方式引入头文件）。同理，若两个组件间不存在依赖关系，即使，使用了 &lt; &gt; 引用也无法引入该组件的任何文件。 这里需要明确项目中哪些功能模块为核心模块，哪些模块依存于核心模块。以我们项目为例，工作台组件（LZWorkTableComponents）为核心组件，在组件化初期可以以工作台组件为主，在其 .podspec 文件中依赖于其它功能组件，而不是中间件， s.dependency &quot;LZLoginComponents&quot; s.dependency &quot;LZPatientManageComponent&quot; s.dependency &quot;LZPharmacyComponents&quot; s.dependency &quot;LZMineComponents&quot; 此时需要注意：这种依赖关系是单向的。即，工作台组件依赖于其它功能组件，而其他功能组件不能依赖于工作台组件。这样也是为了避免组件间形成相互依赖的循环，为后面解除组件间依赖提供便利。 10. 如何将两个组件之间通过代理交互替换为通过中间件交互项目中经常会用到代理处理两个不同功能间页面的跳转。在组件化过程中，也经常会遇到类似于 A组件 中的某个类需要调用 B组件 中的某个类，以完成从 A组件 push 或者 present 或者 addSubview 到 B组件 控制器的逻辑。 这里普通的组件间通讯可以通过上文所说的 中间件 ，复杂一些的，如将之前的代理替换为中间件需要做一些其他的处理，如下： 例如，工作台组件中 患者健康档案，需要调用患者管理组件中的 病例 模块，需要在患者管理中间件（LZPatientManageComponent_Category）中定义回调的方法，如下： 在类 LZMediator+LZPatientManageComponent 中， #pragma mark - 统一前缀 NSString *const kLZMediatorTarget_LZPatientManageComponent = @&quot;LZPatientManageComponent&quot;; #pragma mark - 方法名称 NSString *const kLZMediatorAction_LuHealthRecordsView = @&quot;LuHealthRecordsView&quot;; // 患者健康档案view #pragma mark - block回调 NSString * const LZPatientManageComponent_HealthRecordsViewBlock = @&quot;HealthRecordsViewBlock&quot;; // 患者健康档案block回调 @implementation LZMediator (LZPatientManageComponent) /** 创建患者健康档案实例 @param pationModelDic 患者model字典 @param prescriptionFlag 处方类型 @param recoresViewBlock 患者健康档案的block回调 @return 患者健康档案实例 */ - (UIView *)LZPatientManageComponent_LuHealthRecordsView:(NSDictionary *)pationModelDic withPrescriptionFlag:(NSString *)prescriptionFlag withHealthRecordsViewBlock:(void (^)(NSDictionary *dic))recoresViewBlock { NSMutableDictionary *params = [NSMutableDictionary dictionary]; if (recoresViewBlock) { params[LZPatientManageComponent_HealthRecordsViewBlock] = recoresViewBlock; params[@&quot;pationModelDic&quot;] = pationModelDic; params[@&quot;prescriptionFlag&quot;] = prescriptionFlag; } UIView *healthRecordsView = [self performTarget:kLZMediatorTarget_LZPatientManageComponent action:kLZMediatorAction_LuHealthRecordsView params:params shouldCacheTarget:NO]; if ([healthRecordsView isKindOfClass:[UIView class]]) { return healthRecordsView; } return [UIView new]; } @end 这里主要将代理替换为 Block 以实现方法的回调。主要传递了三个参数， pationModelDic，由于病例视图展示的数据是以 model 形式传递的，而中间件只能接收字典类型的参数，所以在调用方法前需要将 model 转化为 NSDictionary prescriptionFlag，该参数为临时添加的参数，用于判断处方类型。 recoresViewBlock，患者健康档案 block 回调，针对视图 show 之后的各种附加处理，如，网络请求，存储返回值。 这里需要在最终需要调用的患者病历视图类 (LuHealthRecordsView) 中增加对应的 Block 方法，当操作 LuHealthRecordsView 的实例触发视图上的事件时会有结果值回调。（这一步正是替代了原有的两个功能组件间用于交互的代理方法）。具体如下： 在 LuHealthRecordsView.h 中声明， typedef void (^HealthRecordBlock)(NSDictionary *dic); // 用于返回病史/过敏史的block回调(主要应用于患者中间件的传值) @property (nonatomic, copy) HealthRecordBlock healthRecordBlock; 在 LuHealthRecordsView.m 中触发回调， - (void)sureBtnClick { NSDictionary *recordsDic = @{@&quot;buttonType&quot;: @&quot;1&quot;, @&quot;userTag&quot;: [NSNumber numberWithInteger:self.userTag], @&quot;illHistory&quot;: self.contentView2.view1.textView.text, @&quot;allergicHistory&quot;: self.contentView2.view2.textView.text }; self.healthRecordBlock(recordsDic); } 这里同样是以字典方式返回操作结果，这也是组件化中很重要的一个点 —- 去 model 化。 在这里还要提一个点，这个大的 Action 方法的调用，传入的所有参数都需要与实际要调用的视图一一对应。也就是说用到什么参数，就在该方法中增加什么参数。 患者管理组件（LZPatientManageComponent）中，Target 目录下处理调用类实例方法，在类 Target_LZPatientManageComponent 对应方法下实现，如下： 在 Target_LZPatientManageComponent.m 中 /** 返回LuHealthRecordsView视图 */ - (UIView *)Action_LuHealthRecordsView:(NSDictionary *)param { LuHealthRecordsView *healthRecordsView = [[LuHealthRecordsView alloc] initWithFrame:CGRectMake(106/2, 70, SCREEN_WIDTH - 106, SCREEN_HEIGHT - 140)]; NSDictionary *pationModelDic = param[@&quot;pationModelDic&quot;]; PationModel *pationModel = [[PationModel alloc] init]; [pationModel setValuesForKeysWithDictionary:pationModelDic]; healthRecordsView.model = pationModel; healthRecordsView.prescriptionFlag = param[@&quot;prescriptionFlag&quot;]; [healthRecordsView showMe]; healthRecordsView.healthRecordBlock = param[@&quot;HealthRecordsViewBlock&quot;]; return healthRecordsView; } LuHealthRecordsView 为最终需要调用的视图类，在调用前需要将传过来的参数进行转化， param[@”pationModelDic”] 转化为对应的 PationModel param[@”prescriptionFlag”] 处方类型的标识 还有最为重要的一点，将 param[@”HealthRecordsViewBlock”] 的 block 赋给 healthRecordsView.healthRecordBlock 从而触发回调。 最后，在工作台组件中调用患者管理中间件进行通讯，如下： NSDictionary *pationModelDic = self.patientModel.mj_keyValues; __weak typeof(self) weakSelf = self; UIView *healthRecordsView = [[LZMediator sharedInstance] LZPatientManageComponent_LuHealthRecordsView:pationModelDic withPrescriptionFlag:@&quot;3&quot; withHealthRecordsViewBlock:^(NSDictionary *dic) { NSString *buttonType = dic[@&quot;buttonType&quot;]; weakSelf.illHistory = dic[@&quot;illHistory&quot;]; weakSelf.allergicHistory = dic[@&quot;allergicHistory&quot;]; if ([buttonType isEqualToString:@&quot;0&quot;]) { //键盘处理 // [IQKeyboardManager sharedManager].enable = YES; [self.healthRecordsBgView removeFromSuperview]; NSInteger userTag = [dic[@&quot;userTag&quot;] integerValue]; if (userTag != 3) { [weakSelf savePatientHealthRecords]; } } else if ([buttonType isEqualToString:@&quot;1&quot;]) { //键盘处理 // [IQKeyboardManager sharedManager].enable = YES; [weakSelf savePatientHealthRecords]; weakSelf.headerView.patientModel = weakSelf.patientModel; } }]; [_healthbg addSubview:healthRecordsView]; block 回调中处理了未进行组件化前代理方法的工作。最后，这里需要强调一个点，当用于通讯的中间件中需要新增与某个组件通讯的方法时，最好是遵循一个原则： 谁污染谁治理，谁调用谁新增。 即，哪个组件需要进行与其它组件通讯，则由有这个需要的组件的发起者，去他需要调用的组件的中间件中新增用于通讯的方法。 写在最后涉及到项目组件化还有一些收尾工作： 创建壳工程，配置App运行的基本环境 去除主工程 Assets.xcassets 目录下的多余资源文件(这些文件已抽到各个业务功能组件中) 组件化方案中的去 model 的设计 将各个功能模块中涉及到数据库组件，SQLite 的查询语句都移动到数据库组件中 5月初开始对项目进行重构，原以为只要项目完成组件化，重构工作就顺理成章的结束了。但现在看来组件化不是重构的结束，仅仅是一个开始。在我看来以私有 pod 为形式的组件化，只是一种强制解除各个功能模块之间耦合度的方式。它将一个复杂的项目按功能拆分成不同 pod 库，不同组件之前想要通讯，只能通过中间件。因此，我认为组件化的本质是对代码结构的整理，它无形中制定了一套编码规范，迫使开发者在编写代码时不能随心所欲的按照自己的喜好堆放代码。 如果你一开始都注意代码规范，同时又时时留意该如果降低工程中功能间的耦合度。那么，完全没有必要进行组件化。 组件化只是术，而非道。 组件化只是项目重构的第一步，项目重构之路道阻且长，但行则必至。这里为了在后续的重构工作中提醒自己，同时，打个疫苗（希望这次打的是真疫苗）预防一下后续重构中可能会遇到的问题。翻译了一篇文章 — 重写代码会失败的几个征兆 对比文章中的5个方面，结合正在开发的项目，希望有所帮助。 参考资料iOS应用架构谈 开篇 - Casa Taloyum iOS应用架构谈 view层的组织和调用方案 - Casa Taloyum iOS应用架构谈 网络层设计方案 - Casa Taloyum iOS应用架构谈 本地持久化方案及动态部署 - Casa Taloyum iOS应用架构谈 组件化方案 - Casa Taloyum CTMediator 组件化方案调研 模块化与解耦 服务器上的 Git - GitLab XCode 7.1 - Include of non-modular header inside framework Include of non-modular header inside framework module Reference to ‘enum_value’ is ambiguous Make AFNetworking compatible for an iOS 8 Cocoa Touch Framework –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"组件化","slug":"组件化","permalink":"http://XibHe.github.io/tags/组件化/"}]},{"title":"从一个蓝牙打印说起","date":"2018-05-27T16:00:00.000Z","path":"2018/05/28/Compiling/","text":"遇到在 Release 模式下 80mm蓝牙打印机 无法打印的问题，最终的解决方式都是围绕 Debug 和 Release 这两种模式展开的。 可能打造无法打印的原因1.需要打印的处方药品过多，排列太过复杂造成于是，构建一个最简单的打印模板，打印一行最简单的日期，将打印功能尽可能的简单化，看是否是由打印功能本身引起的。结果，仍然无法打印。 2.线程问题，未在主线程刷新UI导致每次选择蓝牙打印机打印处方单时，控制台就会输出线程相关的错误，如下： 2018-05-18 15:52:30.568985+0800 CloudOfficeTest[3340:1191905] [reports] Main Thread Checker: UI API called on a background thread: -[UIApplication windows] PID: 3340, TID: 1191905, Thread name: (none), Queue name: com.apple.root.default-qos.overcommit, QoS: 21 Backtrace: 4 LZBasisComponents 0x0000000101baad4c +[MBProgressHUD hideHUDForView:animated:] + 132 5 LZBasisComponents 0x0000000101baab9c +[MBProgressHUD(MJ) hideHUDForView:] + 72 6 LZBasisComponents 0x0000000101baabf0 +[MBProgressHUD(MJ) hideHUD] + 48 7 CloudOfficeTest 0x0000000100aee2c8 -[LZBluetoothPrintView startPrint] + 300 8 Foundation 0x00000001828de860 &lt;redacted&gt; + 996 9 libsystem_pthread.dylib 0x0000000181b1831c &lt;redacted&gt; + 308 10 libsystem_pthread.dylib 0x0000000181b181e8 &lt;redacted&gt; + 0 11 libsystem_pthread.dylib 0x0000000181b16c28 thread_start + 4 2018-05-18 15:52:38.876328+0800 CloudOfficeTest[3340:1191725] This application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes. Stack:( 0 Foundation 0x00000001829f266c &lt;redacted&gt; + 96 1 Foundation 0x00000001829f2350 &lt;redacted&gt; + 76 2 Foundation 0x0000000182822da0 &lt;redacted&gt; + 132 3 Foundation 0x00000001829f0458 &lt;redacted&gt; + 112 4 UIKit 0x000000018b610b18 &lt;redacted&gt; + 172 5 UIKit 0x000000018b32234c &lt;redacted&gt; + 1348 6 QuartzCore 0x0000000185edbec8 &lt;redacted&gt; + 184 7 QuartzCore 0x0000000185edffa8 &lt;redacted&gt; + 332 8 QuartzCore 0x0000000185e4ea98 &lt;redacted&gt; + 336 9 QuartzCore 0x0000000185e74eb4 &lt;redacted&gt; + 540 10 QuartzCore 0x0000000185e7559c &lt;redacted&gt; + 244 11 libsystem_pthread.dylib 0x0000000181b17680 &lt;redacted&gt; + 572 12 libsystem_pthread.dylib 0x0000000181b173d0 &lt;redacted&gt; + 88 13 libsystem_pthread.dylib 0x0000000181b17168 _pthread_wqthread + 1340 14 libsystem_pthread.dylib 0x0000000181b16c20 start_wqthread + 4 ) 这里报错是由于 MBProgressHUD 导致的，将打印时的 MBProgressHUD 都注释掉，仍然无法打印。 又因为在打印时使用了 NSThread 去更新打印状态，就怀疑是 NSThread 导致的问题。 if (thread == NULL) { [GlobalMethod showName:@&quot;正在打印中&quot; inView:_contentView delay:3]; thread = [[NSThread alloc] initWithTarget:self selector:@selector(startPrint) object:nil]; [thread start]; } else { [GlobalMethod showName:@&quot;正在打印中&quot; inView:_contentView delay:3]; } 这里索性就把 NSThread 的代码也注释掉。此时，编译后再次调用打印功能，后台虽然不会输出线程相关的错误了，但连接上的蓝牙打印机仍然没有任何反应。 3.当 Edit Scheme 中 Build Configuration 为 Debug 时，就可以调用蓝牙打印机进行打印。选择Xcode中，Product -&gt; Scheme -&gt; Edit Scheme，注意 Run 和 Archive 这两种编译方式，选择 Build Configuration 就可以切换 Debug 和 Release 这两种不同的模式。 这就需要对比 release 与 debug 两种模式的不同，尤其是在调用 CoreBluetooth 时的不同。 Release 是发行版本，比 Debug 版本多一些优化，文件比 Debug 文件小。 Debug 是调试版本，Debug 和 Release 调用两个不同的底层库。通俗点讲，我们开发者自己内部真机或模拟器调试时，使用 Debug 模式就好，等到想要发布时，也就是说需要大众客户使用时，需要构建 Release 版本，具体区别如下： Debug 是调试版本，包括的程序信息更多； 只有 Debug 版的程序才能设置断点、单步执行、使用 TRACE/ASSERT 等调试输出语句； Release 不包含任何调试信息，所以体积小、运行速度快。 简而言之，Release 版本会对最终发布的项目做优化，以提高 App 的运行速度。 //读取特征中的数据 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { NSLog(@&quot;enter didUpdateValueForCharacteristic!&quot;); NSLog(@&quot;read data=%@!&quot;,characteristic.value); } 如果将此处的 NSLog 输出注释掉是否也可以打印？ 控制台会一直输出打印类 LZBluetoothPrintView 的一个方法 &lt;LZBluetoothPrintView.m : 382&gt; -[LZBluetoothPrintView peripheral:didUpdateValueForCharacteristic:error:] 2018-05-18 15:52:38.778826+0800 CloudOfficeTest[3340:1191349] enter didUpdateValueForCharacteristic! - (void)viewDidLoad { [super viewDidLoad]; #ifdef DEBUG NSLog(@&quot;Test DEBUG mode&quot;); #else NSLog(@&quot;Test Release mode&quot;); #endif } 不同的解决方案方案一：将 Build Settings 里面的 Apple LLVM 9.0 - Preprocessing - Preprocessor Macros 这里。在 release 下增加配置项 DEBUG = 1，即可打印。只是暂时解决了打印问题，慎用！因为默认情况下 release 模式是不需要设置为 DEBUG 模式的。 这里有一个疑问？当设置 Edit Scheme 的 Archive 中 Build Configuration 为 Release 时，此时，Archive 后生成一个 ipa包，导出并安装后发现程序中调用的仍然 DEBUG 模式下的程序。代码如下： - (void)viewDidLoad { [super viewDidLoad]; UIView *backView1 = [[UIView alloc] initWithFrame:CGRectMake(self.view.center.x - 20, self.view.center.y - 20, 40, 40)]; [self.view addSubview:backView1]; #ifdef DEBUG backView1.backgroundColor = [UIColor redColor]; NSLog(@&quot;Test DEBUG mode&quot;); #else backView1.backgroundColor = [UIColor greenColor]; NSLog(@&quot;Test Release mode&quot;); #endif } 此时，打开通过 ipa 包安装的程序，展示的为红色的视图。 方案二：将 Build Settings 里面的 Optimization Level 的 release 对应的配置项改为 None[-OO]修改 release 模式下的编译策略为 -OO 即，不做任何编译优化。编译策略是对代码编译过程的优化（c-&gt;汇编），优化后的代码效率比较高，但是可读性比较差，且编译时间更长。 GCC_OPTIMIZATION_LEVEL = Fastest, Smallest [-OS] 优化级别： None： 不做优化使用这个设置，编译器的目标是减少编译成本，使调试产生预期的结果。 Fast：优化编译将为大函数占用更多的时间和内存使用这个设置，编译器将尝试减少代码的大小和执行时间，不进行任何优化，需要大量编译时间。 Faster：编译器执行几乎所有支持的优化，它不考虑空间和速度之间的平衡与“Fast”设置相比，该设置会增加编译时间和生成代码的性能。编译器不进行循环展开、内联函数和寄存器变量的重命名。 Fastest：开启“Faster”支持的所有的优化，同时也开启内联函数和寄存器变量的重命名选项 Fastest，smallest：优化代码大小这个设置启用“Faster”所有的优化，一般不增加代码大小，它还执行旨在减小代码大小的进一步优化。 方案三：将蓝牙打印页面的预览视图中所有 #define NSLog(format, …) do 对应的 NSLog 注释掉。最后发现将打印页面的所有输出语句注释掉不会起到任何作用，因此，只剩下 方案二 可行了。 方案四：从源码编译入手，利用 Clang 在编译为可执行文件前，过滤编译过程中影响打印的操作。相对而言，这种方式是最复杂，最有难度的一种方式。但却能追本溯源，从根本上明白为什么无法打印？ 从源码到可执行文件Low Level Virtual Machine (LLVM) 是一个开源的编译器架构，Clang 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。 利用LLVM 将源码编译为可被不同语言识别的中间表示(IR)。 可以用Clang做什么?1. libclang进行语法分析可以使用libclang里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。 2. LibTooling对语法树有完全的控制权，可以作为一个单独的命令使用，如：clang-format 3. ClangPlugin对语法树有完全的控制权，作为插件注入到编译流程中，可以影响build和决定编译过程。目录:llvm/tools/clang/examples 这里蓝牙打印的在release模式下无法打印的问题，涉及到编译器编译至可执行文件时，中间所做的优化处理。可以尝试从编译流程入手，进行相应的语法分析，过滤掉非必须但影响蓝牙打印的优化操作。 通过遍历语法树，去修改里面的方法名和返回变量名。 .cpp 文件，在编译源文件时，C++编译器会对符号(函数或变量)名作某些修正，修正后生成目标文件的后缀为.cpp。 基于 Pass，我们可以做什么？ 我们可以编写自己的 Pass 去混淆代码，以增加他人反编译的难度。 LLVM 编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件 基于 LLVM，我们可以做什么？ 做语法树分析，实现语言转换 OC 转 Swift、JS or 其它语言，字符串加密。 编写 ClangPlugin，命名规范，代码规范，扩展功能。 编写 Pass，代码混淆优化” 参考资料手把手教你给一个iOS app配置多个环境变量 XCode debug vs release build when debugging 初识 LLVM 结构化编译器前端 Clang 介绍 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"编译器","slug":"编译器","permalink":"http://XibHe.github.io/tags/编译器/"},{"name":"环境变量","slug":"环境变量","permalink":"http://XibHe.github.io/tags/环境变量/"}]},{"title":"从一个数据量过多的优化说起","date":"2018-04-17T16:00:00.000Z","path":"2018/04/18/SQLOptimize/","text":"前段时间遇到一个问题，程序中查询患者信息的功能，当患者数据量超过 30000 条时，会出现卡顿，APP 无响应的问题。在处理这个需求时，需要将本地数据库中的全部患者数据查询出来，然后按照从 A - Z 的患者首字母进行分组排序。对于不属于 A - Z 的数据，将其分为 # 组。 更新说明更新记录: 2018 年 04 月，第一版。 2018 年 06 月，补充后续的优化方案。 卡顿问题的解决原来的代码逻辑如下： // 全部患者数据 _allPatients = [[LZDatabaseHelper sharedInstance] getAllPatient]; NSMutableArray *tempArray = _allPatients.mutableCopy; for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) { LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init]; sectionModel.sectionTitle = [NSString stringWithFormat:@&quot;%c&quot;,a]; for (int i = 0; i &lt; _allPatients.count; i++) { PationMoedl *pationModel = _allPatients[i]; if (pationModel.userShortName.length &gt; 0) { char temp = [pationModel.userShortName characterAtIndex:0]; if (a == temp) { [sectionModel.patientList addObject:pationModel]; [tempArray removeObject:pationModel]; } } } if (sectionModel.patientList.count &gt;0) { [self.patientArray addObject:sectionModel]; } } LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init]; sectionModel.sectionTitle = @&quot;#&quot;; if (tempArray.count &gt; 0) { [sectionModel.patientList addObjectsFromArray:tempArray]; [self.patientArray insertObject:sectionModel atIndex:0]; } [_patientTableView reloadData]; 从上面的代码可以计算出排序的时间复杂度，第一个 for 循环执行 26 次，嵌套在内的第二个 for 循环会执行 30000 次。时间复杂度用大写字母 O 来表示，因此该排序的时间复杂度是: O(26 * 30000) 也就是说当点击对应的按钮查看患者后，会执行 780000 次 for 去遍历全部患者，并将符合首字母符合 A - Z 的患者添加到 sectionModel.patientList 数组中，然后刷新列表展示排好序的数据。这也是为什么会出现患者量少时没有问题，一但患者量达到上万条时就会出现点击对应按钮后，就会出现卡顿的问题。要解决这样的问题，需要从如何降低时间复杂度着手。 尝试了 4 种不同的方案，如下： 方案一:算法角度上，以空间换时间，一下子就创建好 26 个存放 A - Z 首字母排序的数组，以减少循环次数为目的，循环一次，找到对应首字母序列的数据，从数据源中移除这些数据；然后，继续开始下一次遍历，以此类推，直到查询出所有排序数组。（时间复杂度，空间复杂度） 桶排序算法 快速排序算法 方案二:几种不同遍历方式的比较，试图通过比较查询效率，找到最快的遍历方式。 经典 for 循环 for in (NSFastEnumeration) KVC 集合运算符 enumerateObjectsUsingBlock enumerateObjectsWithOptions(NSEnumerationConcurrent) 初始化 100 个对象的遍历操作所消耗的时间(毫秒级): 经典for循环 — 0.0023 for in (NSFastEnumeration) — 0.003090 makeObjectsPerformSelector — 0.001120 kvc集合运算符 — 0.004272 enumerateObjectsUsingBlock — 0.001145 enumerateObjectsWithOptions(NSEnumerationConcurrent) — 0.001605 这样并不能看出什么结论，当初始化 1000000 个对象时就会有很大差距 经典for循环 — 1.246721 for in (NSFastEnumeration) — 0.025955 makeObjectsPerformSelector — 0.068234 kvc集合运算符 — 21.677246 enumerateObjectsUsingBlock — 0.586034 enumerateObjectsWithOptions(NSEnumerationConcurrent) — 0.722548 可以看出当数据量少时，for in 的速度并不突出，但当数量达到一定量级后，for in 的遍历速度就体现出来了。 方案三:折中方案，为了避免查询时卡死主线程，将查询方法放在 异步线程 里，然后在 主线程 中刷新数据源。如下： dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) { LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init]; sectionModel.sectionTitle = [NSString stringWithFormat:@&quot;%c&quot;,a]; for (PationMoedl *pationModel in _allPatients) { // 根据数据库中的患者简称，将对应简称的model存入sectionModel.patientList中 if (pationModel.userShortName.length &gt; 0) { char temp = [pationModel.userShortName characterAtIndex:0]; if (a == temp) { [sectionModel.patientList addObject:pationModel]; [tempArray removeObject:pationModel]; } } } if (sectionModel.patientList.count &gt;0) { [self.patientArray addObject:sectionModel]; } } LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init]; sectionModel.sectionTitle = @&quot;#&quot;; if (tempArray.count &gt; 0) { [sectionModel.patientList addObjectsFromArray:tempArray]; [self.patientArray insertObject:sectionModel atIndex:0]; } dispatch_async(dispatch_get_main_queue(), ^{ [_patientTableView reloadData]; [MBProgressHUD hideHUDForView:self]; }); }); 方案四方案4也是最终采用的方案，主要时间排序的功能用 SQL 语句去实现，在每次遍历时，传入一个当前的序列，通过执行数据库查询语句得到一个分好的序列数组，这样就大大减少了 for 循环的次数，提高了速度。但为了不卡死线程，仍然需要与 GCD 结合起来使用。如下： [MBProgressHUD showMessag:@&quot;加载中&quot; toView:self]; // 1. 将整个查询的耗时操作放到 GCD 中 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 查询出所有患者数据，为搜索功能提供数据源 _allPatients = [[LZDatabaseHelper sharedInstance] getAllPatientForIndexes]; // 2. 从 A - Z 进行 26 次遍历 for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) { NSString *orderNumber = [NSString stringWithFormat:@&quot;%c&quot;,a]; // 3. 通过 SQL 语句查出对应首字母序列的返回的数组 NSArray *patientRankArray = [[LZDatabaseHelper sharedInstance] getPatientGroup:orderNumber]; // 4. 将查询到的某一序列数组与分组名称进行绑定 if (patientRankArray &amp;&amp; patientRankArray.count &gt; 0) { LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init]; sectionModel.sectionTitle = orderNumber; [sectionModel.patientList addObjectsFromArray:patientRankArray]; [self.patientArray addObject:sectionModel]; } } // 5. 通过 SQL 语句查出其他非 A-Z 的数据 NSArray *otherArray = [[LZDatabaseHelper sharedInstance] getPatientMistakeGroup]; // 6. 将查询到的非 A-Z 插入到患者数据源中 if (otherArray &amp;&amp; otherArray.count &gt; 0) { LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init]; sectionModel.sectionTitle = @&quot;#&quot;; [sectionModel.patientList addObjectsFromArray:otherArray]; [self.patientArray insertObject:sectionModel atIndex:0]; } // 7. 主线程中刷新列表 dispatch_async(dispatch_get_main_queue(), ^{ [_patientTableView reloadData]; [MBProgressHUD hideHUDForView:self]; }); }); 具体步骤如下： 将整个查询的耗时操作放到 GCD 中； 从 A - Z 进行 26 次遍历； 通过 SQL 语句查出对应首字母序列的返回的数组； 将查询到的某一序列数组与分组名称进行绑定； 通过 SQL 语句查出其他非 A-Z 的数据； 将查询到的非 A-Z 插入到患者数据源中； 主线程中刷新列表。 这里将最为耗时的对应首字母遍历数据操作，通过 SQL 查询语句来实现。那么 SQL 语句的查询速度究竟如何呢？可以在处理 SQL 查询的方法里增加计算方法执行耗时的代码： // 记录开始时间，放在方法执行的最前面 NSDate *startDate = [NSDate date]; // 记录结束时间，放到方法执行结束的位置 NSDate *finishDate = [NSDate date]; NSTimeInterval interval = [finishDate timeIntervalSinceDate:startDate]; NSLog(@&quot;查询全部患者数据耗时: %f&quot;,interval); 返回的时间戳大概为 0.45 毫秒。 关于数据库查询语句的优化 建立索引 不要把SQL语句写得太复杂 避免过度使用 Select * 查询所有数据 （实际使用时只需要某一个或几个字段） 统一 SQL 语句的写法 (主要区分大小写) REPLACE INTO 语句的使用 REPLACE 作用与 INSERT 完全一致，但如果旧表中的行具有相同的值作为一个新行 PRIMARY KEY 或 UNIQUE 索引，旧行插入新行之前删除。 REPLACE 是一个 MySQL 扩展 SQL 标准。它要么插入要么先删除再插入。 注意，除非表有一个 PRIMARY KEY 或 UNIQUE 索引，否则使用 REPLACE 语句是没有意义的。 SQL 语句的拓展 sqlite 截取字符串前几位后再进行查询 在 sqlite 中使用 regex 进行查询 SUBSTR()，SQL 中的 substring 函数是用来抓出一个栏位资料中的其中一部分。这个函数的名称在不同的数据库中不完全一样： MySQL: SUBSTR( ), SUBSTRING( )Oracle: SUBSTR( )SQL Server: SUBSTRING( ) upper()函数，将小写转化为大写；lower()函数，将大写转化为小写。 // 根据 A - Z 进行分组查询 NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, userName, userShortName, birthday, sex, phone, address FROM table_sickPerson WHERE clinicId = &#39;%@&#39; AND status like &#39;0&#39; AND isDelete like &#39;0&#39; AND SUBSTR(upper(userShortName),1,1) = &#39;%@&#39; &quot;,clinkId,orderNumber]; GLOB 用来连接正则表达式的关键字 // 查询非 A - Z 的数据 NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, userName, userShortName, birthday, sex, phone, address FROM table_sickPerson WHERE clinicId = &#39;%@&#39; AND status like &#39;0&#39; AND isDelete like &#39;0&#39; AND SUBSTR(upper(userShortName),1,1) GLOB &#39;[^A-Z]&#39; &quot;,clinkId]; 之前没有在 SQLite 中使用过 regex 还以为不支持呢，最后几经波折，在官网上找到了对应的文档！ ONE PIECE一个关于 CoreData 的问题Core Data 是 iOS5 之后才出现的一个框架，本质上是对 SQLite 的一个封装，它允许按照实体-属性-值模型组织数据，并以 XML，二进制文件或SQLite 数据文件的格式将其序列化。Core Data 允许用户使用代表实体和实体间关系的高层对象来操作数据。它也可以管理序列化的数据，提供对象生存期管理与 object graph 管理，包括存储。Core Data 直接与 SQLite 交互，避免开发者使用原本的 SQL 语句。 这里在尝试使用 Core Data 时遇到一个问题，在获取模型路径，创建模型对象时，一直报错： NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@&quot;testModel&quot; withExtension:@&quot;momd&quot;]; _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; return _managedObjectModel; *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;CoreData: Cannot load NSManagedObjectModel. nil is an illegal URL parameter&#39; Core Data 数据库的名字和封装类里的名字是一致的。 使用Blob存储NSData遇到的问题先通过 UPDATE 语句更新数据， // 更新faceFeatureData + (void)updateFaceFeatureData:(NSData *)faceFeatureData { FMDatabase *dataBase = [ConfigurateDB open]; [dataBase beginTransaction]; NSString *sql = [NSString stringWithFormat:@&quot;UPDATE Register SET faceFeatureData = &#39;%@&#39; WHERE id = &#39;1&#39;&quot;,faceFeatureData]; [dataBase executeUpdate:sql]; [dataBase commit]; } 再通过 SELECT 获取更新的值。 // 获取个人信息 + (AFRPerson *)getInformationWithUserID:(NSInteger)Id { FMDatabase *dataBase = [ConfigurateDB open]; NSString *sql = [NSString stringWithFormat:@&quot;SELECT * FROM Register WHERE id = &#39;%ld&#39;&quot;,Id]; FMResultSet * resultSet = [dataBase executeQuery:sql]; AFRPerson *person = nil; while ([resultSet next]) { person = [[AFRPerson alloc] init]; person.Id = [resultSet intForColumn:@&quot;id&quot;]; person.faceID = [resultSet intForColumn:@&quot;faceID&quot;]; person.faceFeatureData = [resultSet dataForColumn:@&quot;faceFeatureData&quot;]; person.name = [resultSet stringForColumn:@&quot;name&quot;]; person.attendanceStatus = [resultSet stringForColumn:@&quot;attendanceStatus&quot;]; } [resultSet close]; return person; } 发现 person.faceFeatureData 这个 NSData 类型的属性值，更新前与更新后再次获取的字节长度不一致，前者为：22020 bytes，后者为：48096 bytes。正常结果二者应是一致的。 小结 第一手资料永远是官方文档！！！ 算法真的真的很重要! ! ! 很多性能问题，首先可以先从算法角度进行思考； 使用 GCD 多线程技术来处理耗时任务； 算法，不同遍历方式进行比较，SQL查询语句的优化，GCD 这几种方式相结合总能给人意想不到的惊喜，没有一种解决方案是孤立存在的。 对症下药吧！将提高查询效率和减少遍历次数二者相结合。做完这次优化后，还是想问一句：这是最优的方案吗？还可以进一步优化吗? 后记最后，这种方式虽然可以缓解数据量达到 30000 条时的卡顿状况。但打开列表页面时，仍然会 loading 两三秒， 最终处理方案是：当数据量大于 5000 条时，进行分页加载，一次加载 200 条，此时就没有必要将数据按首字母缩写排序了，可通过搜索框搜索出对应患者；当数据量小于 5000 时，仍保持之前的逻辑。 参考资料sqlite.org Documentation w3cschool SQL 13.2.9 REPLACE Syntax Regex in SQLite and ObjectiveC Core Data –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"SQLite","slug":"SQLite","permalink":"http://XibHe.github.io/tags/SQLite/"},{"name":"性能优化","slug":"性能优化","permalink":"http://XibHe.github.io/tags/性能优化/"}]},{"title":"深入理解RunLoop","date":"2018-03-17T16:00:00.000Z","path":"2018/03/18/RunLoopAnalysis/","text":"上一篇博客介绍了使用 WKWebView 进行性能调优，以及使用中遇到的问题。当在弱网环境下频繁切换 H5 页面时，就会出现应用卡死的情况。使用WKWebView进行性能调优，控制台会报三个错误，其中一个错误是： 2018-02-01 11:09:01.952689+0800 CloudOfficeTest[614:68129] void SendDelegateMessage(NSInvocation *): delegate (webView:decidePolicyForNavigationAction:request:frame:decisionListener:) failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode 错误中出现了 main run loop mode: kCFRunLoopDefaultMode 的信息提示，最后虽然将项目中的 UIWebView 替换为 WKWebView ( WKWebView的内存消耗相比 UIWebView 低了一个数量级)。但却没有将这个报 RunLoop 的错误解释清楚，今天就结合一些实例叙述一下自己对 RunLoop 的浅见。 更新说明更新记录: 2018 年 03 月，第一版。 2018 年 04 月，补充利用 RunLoop 解决一些问题的 Demo。 RunLoop 是什么Runloop 是 iOS 底层机制，就是一个运行循环，确切的说是为了保证程序会一直运行不退出的死循环。 在 iOS 中的入口函数执行类似逻辑，这里打印只会输出 执行了!!!，并不会输出 有没有执行???，这里开启了一个和主线程相关的 RunLoop，导致 UIApplicationMain 不会返回，一直处在运行中。 int main(int argc, char * argv[]) { @autoreleasepool { NSLog(@&quot;执行了!!!&quot;); // 主线程死循环 --- RunLoop int a = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); NSLog(@&quot;有没有执行???&quot;); return a; } } 下面这段内容摘抄自 深入理解RunLoop 中 RunLoop的概念 中的叙述。 一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常代码逻辑是这样的： function loop() { initialize(); do { var message = get_next_message(); process_message(message); } while (message != quit); } 这种模型通常被称作Event loop。Event Loop 在很多系统和框架里都有实现，比如： Node.js 的事件处理 Windows 程序的消息循环 OSX/iOS 的 RunLoop 实现这种模型的关键的在于： 如何管理事件/消息，如何让线程在没有处理消息时休眠，以避免资源占用；在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的 Event Loop 逻辑。线程执行了这个函数后，就会一直处于这个函数内部 接受消息 –&gt; 等待 –&gt; 处理 的循环中，直到这个循环结束（比如，传入 quit 消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但这些 API 不是线程安全的。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C函数 的 API，所以这些 API 都是线程安全的。 RunLoop 的作用 保住程序不退出，持续运行； 负责监听程序中的各种事件，如：网络，触摸，定时器等； 渲染 UI； 节省 CPU 资源，提高程序性能； 线程间的通讯。 RunLoop 与线程的关系下面这段内容摘抄自 深入理解RunLoop 中 RunLoop 与线程的关系 中的叙述。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: /// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef static CFMutableDictionaryRef loopsDic; /// 访问 loopsDic 时的锁 static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。 CFRunLoopRef _CFRunLoopGet(pthread_t thread) { OSSpinLockLock(&amp;loopsLock); if (!loopsDic) { // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); } /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) { /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); } OSSpinLockUnLock(&amp;loopsLock); return loop; } CFRunLoopRef CFRunLoopGetMain() { return _CFRunLoopGet(pthread_main_thread_np()); } CFRunLoopRef CFRunLoopGetCurrent() { return _CFRunLoopGet(pthread_self()); } 线程和 RunLoop 是一一对应的； 线程刚刚创建时并没有 RunLoop，如果你不主动获取，那它一直不会有； RunLoop 的创建发生在第一次获取时，RunLoop 的销毁发生在线程结束时； 只能在一个线程的内部获取其 RunLoop (主线程除外)。 CoreFoundation 中 RunLoop 的组成结构CoreFoundation 中关于 RunLoop 有5个类： CFRunLoopModeRef // 运行模式，每次调用时只能选择一种，在不同模式中做不同的操作。 __CFRunLoop CFRunLoopRef; // 获得当前 RunLoop* __CFRunLoopSource CFRunLoopSourceRef*; // 事件源 __CFRunLoopObserver CFRunLoopObserverRef*; // 观察者 __CFRunLoopTimer CFRunLoopTimerRef*; // 定时器时间 下面这段内容摘抄自 深入理解RunLoop 中 RunLoop 对外接口 中的叙述。 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: CFRunLoopModeRef，一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop的主函数时，只能指定其中一个 Mode，这个 Mode 被称为 CurrentMode。如果需要切换 Mode，只能退出 RunLoop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef 是事件产生的地方。source 有两个版本：source0 和 source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。 CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是 toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到期时，RunLoop 会被唤醒一执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受这个变化。可以观察的时间点有以下几个： /* Run Loop Observer Activities */ typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 即将进入休眠 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU }; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以同时加入多个 mode。但一个 item 被重复加入同一个 mode 时，是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop的 Mode关于 RunLoop 的 Mode 可以通过下面的例子，展开来说， - (void)viewDidLoad { [super viewDidLoad]; NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerCurrentThread) userInfo:nil repeats:YES]; // 将timer加入到RunLoop中 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; } - (void)timerCurrentThread { static int a = 0; NSLog(@&quot;当前线程%@---%d&quot;,[NSThread currentThread],a++); } 这里将 timer 加入到 RunLoop 中，通过当前运行的 RunLoop观察事件的执行。这里需要注意给 timer 添加的是 NSDefaultRunLoopMode 模式。 那么，在上面例子的基础上，我再添加一个 UITextView 控件，编译运行后，当滑动控件时，发现控制台不会继续输出 timerCurrentThread 方法中的打印。是因为阻塞了主线程导致的吗？不是的，这里 RunLoop 无法同时处理屏幕触摸事件和 timer 回调。此时，试着将模式替换为 UITrackingRunLoopMode， [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; 再滑动 UITextView 控件，控制台会继续输出。结合上面的所说的一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer，例子中的关系可以这样表示，如图所示， 这里在 UITrackingRunLoopMode（UI模式）下的优先级最高，当通过触摸事件唤醒该模式时，当前 RunLoop 会忽落掉其它模式，优先处理UI模式下的事件。 同样在UI模式下，没有触摸手机屏幕时，即使有 timer 回调也不会继续处理，因此，当不再滑动控件时，控制台就不会再有任何输出了。如果想要兼顾默认模式和UI模式，可以这样做： [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; 将 timer 同时添加到两种模式中，在触摸屏幕时(UI模式)，会处理 timer 回调，当不在触摸屏幕时(默认模式)，也会处理 timer 回调。那么有没有一种模式可以兼顾这两种模式呢？答案是肯定的。如下， [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 这里的 NSRunLoopCommonModes (占位模式)，相当于前两种模式的叠加。 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 — 摘录自 深入理解RunLoop 系统默认注册了5个Mode，如下： NSDefaultRunLoopMode 默认模式 UITrackingRunLoopMode UI模式 NSRunLoopCommonModes 占位模式 初始化模式 系统内核模式 经常用到的是前三种模式。 RunLoop 的内部逻辑利用 RunLoop 解决一些问题1. RunLoop 渲染UI — 减少滑动卡顿在 tableView 上加载多张高清大图时，在拖拽很快的时候，所有的图片渲染都交给 RunLoop 一次循环中处理掉，这样就会导致滑动时卡顿的问题。那么该如何解决呢？这里以 iPhone 6s 为例，tableView 最多一次显示18张图片，分为18次加入到 RunLoop 中，而不是一次。 具体怎么做呢？通过监听 RunLoop 的循环！通过 observer 观察活动的不同状态。具体步骤： 添加观察者，观察 Runloop 循环； 观察状态变化； 将原来添加图片的代码加入到数组中 在 Runloop 的回调方法中，拿出数组中加载图片的代码，执行。 关键代码如下： - (void)addRunloopObserver { // 1. 得到runloop CFRunLoopRef runloop = CFRunLoopGetCurrent(); // 2. 获取上下文 CFRunLoopObserverContext context = { 0, (__bridge void *)self, &amp;CFRetain, &amp;CFRelease, NULL }; // 3. 创建观察者 CFRunLoopObserverRef observer = CFRunLoopObserverCreate(NULL, kCFRunLoopBeforeWaiting, YES, 0, &amp;callback, &amp;context); // 4. 添加观察者 CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes); // 5. 释放 CFRelease(observer); } #pragma mark - 在回调里面加载图片（Runloop循环一次加载一次） void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){ NSLog(@&quot;%@&quot;,info); LoadImageViewController *vc = (__bridge LoadImageViewController *)info; if (vc.tasks.count == 0) { return; } runloopBlock taskBlock = vc.tasks.firstObject; taskBlock(); [vc.tasks removeObjectAtIndex:0]; } 2. 通过 RunLoop 让 Crash 的 App 回光返照由 SIGABRT 引起的 crash 是系统发这个 SIGABRT 给 App，程序收到这个SIGABRT 后，就会把主线程的 RunLoop 杀死，程序就挂掉了。这个例子只针对 SIGABRT 引起的 Crash 有效。 CFRunLoopRef runloop = CFRunLoopGetCurrent(); //获取所有Mode，因为可能有很多Mode，每个Mode都需要跑，此处可以选择提交下崩溃信息之类的 UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;程序崩溃了&quot; message:@&quot;崩溃信息&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil]; [alertView show]; NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(runloop)); while (1) { //快速切换Mode for (NSString *mode in allModes) { CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); } } 未完善Demo： https://github.com/XibHe/RunLoopCase 写在最后在准备写这篇博客前，第一反应就是一定要参考 ibireme 两年前写的 深入理解RunLoop 这篇文章，但当花了一天时间看完 ibireme 的文章后，又不知道该如何下手了？脑子里满是 ibireme 博客的影子。ibireme 的这篇文章简直就是 iOS 开发界的 《春江花月夜》，给人一种 “孤篇压全唐” 的感觉。 自己起的调太高了，为了不跑调，就只能假唱了。这篇文章中有一半内容是深入理解RunLoop 的原话。写到最后，才发现这哪里是自己对 RunLoop 的深入理解？写的明明是自己的挣扎与不甘啊！从事 iOS 开发四年的我，又该何去何从呢？愿与诸君共勉： 心之所向，身之所往；道阻且长，行则将至。 最后，得知 ibireme 去岁身体有恙，想来现在早已康复。祝：一切安好！ 参考资料深入理解RunLoop RunLoopWorkDistribution","tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"http://XibHe.github.io/tags/RunLoop/"},{"name":"CFRunLoopObserverRef","slug":"CFRunLoopObserverRef","permalink":"http://XibHe.github.io/tags/CFRunLoopObserverRef/"}]},{"title":"使用WKWebView进行性能调优","date":"2018-02-02T16:00:00.000Z","path":"2018/02/03/WKWebView-disabuse/","text":"最近一周，用户频繁反应一个问题：切换到某个功能页面后，加载H5页面相应时间过长，当H5页面未展示出来时，此时，再切换到其他页面，App会卡死。我们试着在公司的网络环境下复现这个问题，但并未复现。 错误的尝试最开始时并没有意识到是webView的原因，反而因为前几天刚解决了一个UI线程的bug，将这个卡顿问题主观上当做线程问题去解决。基于此做了以下操作： 增加webView加载失败的代理方法； 在加载完成和加载失败时，取消加载进度动画的展示； 在将项目中的页面替换为 WKWebView 后，发现在访问下个H5页面时，无法共享 Cookie 的问题（下面会详细说下这个问题是如何解决的），导致无法获取到已经验证成功的用户登录信息。 先期采用方法1和方法2，但测试时还是会造成卡顿。后期替换为 WKWebView 后，亟待解决 Cookie 无法共享的问题，想着能不能在每次加载H5页面时，都在请求链接后面拼上用户信息的各种参数，经测试，这样做仍然无法解决页面跳转后读取用户信息的bug。而且还因每次访问页面频繁与服务器进行验证，给服务器带来了性能压力。 问题的复现这时考虑到用户应该是在弱网环境下进行操作，遇到的问题。于是，使用网络封包分析工具Charles模拟慢速网络。选择Throttle present：56 kbps Modem。此时，再切换页面，先切换到那个加载H5的页面，然后再来回切换其他几个页面，就会出现APP卡死的情况。(这里需要说明的是其他切换的页面有4个同样是加载H5页面，一共有8个主界面)。 现在问题基本可以明确了，每次加载H5页面时都要初始化webView导致了程序内存消耗过大，造成APP卡死。 控制台报错调试时，在程序频繁切换刷新页面直至卡死阶段，控制台一直报错，主要报错如下： 1. Domain=NSURLErrorDomain Code=-999&lt;LZoutsourceViewController.m : 226&gt; -[LZoutsourceViewController webView:didFailProvisionalNavigation:withError:] 2018-01-31 21:02:22.084257+0800 CloudOfficeTest[9230:4603782] error:Error Domain=NSURLErrorDomain Code=-999 &quot;(null)&quot; UserInfo={NSErrorFailingURLStringKey=http://test.net/h5/zskt/spkt.html? _WKRecoveryAttempterErrorKey=&lt;WKReloadFrameErrorRecoveryAttempter: 0x1c0822d20&gt;} 2. NSURLConnection finished with error - code -10022018-01-31 21:35:56.144596+0800 CloudOfficeTest[9301:4618465] NSURLConnection finished with error - code -1002 2018-01-31 21:36:02.742996+0800 CloudOfficeTest[9301:4618815] TIC TCP Conn Failed [14:0x1c41702c0]: 3:-9802 Err(-9802) 3. failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode2018-02-01 11:09:01.952689+0800 CloudOfficeTest[614:68129] void SendDelegateMessage(NSInvocation *): delegate (webView:decidePolicyForNavigationAction:request:frame:decisionListener:) failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode 其中，前两个错误都有错误码，分别对应 Code=-999，NSURLErrorCancelled code -1002，NSURLErrorUnsupportedURL -999的错误，是因为webView在之前的请求还没有加载完成，就发起了下一个请求，此时webView会取消之前的请求，因此会回调的请求失败这里。 这里使用的是WKWebView，因此，需要在WKWebView加载失败的代理方法里拦截掉被取消的请求。 - (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error { // code = -999，被取消什么也不干 if ([error code] == NSURLErrorCancelled) { return; } NSLog(@&quot;error:%@&quot;,error); // 失败后的后续处理..... } 第3个错误中看到了main run loop的字样，感觉很有可能是造成卡顿的元凶了。又在项目中全局搜了一下报错的这个方法，发现是使用的js与oc交互框架—WebViewJavaScriptBridge中的方法。 // WebViewJavascriptBridge.m - (void)webView:(WebView *)webView decidePolicyForNavigationAction:(NSDictionary *)actionInformation request:(NSURLRequest *)request frame:(WebFrame *)frame decisionListener:(id&lt;WebPolicyDecisionListener&gt;)listener 这个方法是框架WebViewJavascriptBridge中的方法，主要用于处理UIWebView与JS交互。到目前为止，仍然不能定位到究竟是UIWebView与JS交互时发生了什么？才导致报这个错误。只是隐隐的感觉到可能和初始化UIWebView时的内存消耗有关，毕竟WKWebView的内存消耗相比UIWebView低了一个数量级。于是，将加载会卡顿的页面替换为WKWebView来加载H5页面，通过降低频繁初始化消耗的内存，减少页面卡死的概率。但在替换后遇到一些比较棘手的问题。 具体替换步骤 引入WKWebView的代理，生成WKWebViewJavascriptBridge桥接对象 #import &quot;WKWebViewJavascriptBridge.h&quot; #import &quot;LZWKWebKitSupport.h&quot; @interface LZPartnerMainViewController ()&lt;WKNavigationDelegate&gt; @property WKWebViewJavascriptBridge *jsBridge; /**WKWebView**/ @property (nonatomic, strong) WKWebView *wkWebView; 初始化WKWebView - (void)viewDidLoad { _wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:YES]; [_wkWebView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil]; [self.view addSubview:_wkWebView]; self.jsBridge = [WKWebViewJavascriptBridge bridgeForWebView:_wkWebView]; [self.jsBridge setWebViewDelegate:self]; // 使用WKWebViewJavascriptBridge进行桥接，OC端注册方法，由js端进行调用 [_jsBridge registerHandler:@&quot;testObjcCallback&quot; handler:^(id data, WVJBResponseCallback responseCallback) { NSLog(@&quot;data:%@&quot;,data); NSString *urlStr = nil; NSString *processIsTop = nil; if ([data isKindOfClass:[NSString class]]) { urlStr = data; }else{ NSDictionary *dic = data; urlStr = dic[@&quot;url&quot;]; processIsTop = dic[@&quot;processIsTop&quot;]; } responseCallback(@&quot;Response from testObjcCallback&quot;); }]; } 注意，这里通过LZWKWebKitSupport来初始化一个WkWebView是为了同步Cookie，后面会具体说到为什么要同步Cookie及如何同步。 设置WkWebView的代理方法 #pragma mark - WKNavigationDelegate // 开始加载 - (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation { self.loadingView.hidden = NO; NSLog(@&quot;didCommitNavigation&quot;); } // 加载完成 - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { self.loadingView.hidden = YES; NSLog(@&quot;didFinishNavigation&quot;); } // 加载失败 - (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error { // code = -999 if ([error code] == NSURLErrorCancelled) { return; } NSLog(@&quot;didFailProvisionalNavigation error.code = %ld&quot;,error.code); } #pragma mark - wkwebviewDelegate - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler { decisionHandler(WKNavigationActionPolicyAllow); } //接收到服务器响应 后决定是否允许跳转，主要用来处理请求失败的情况。 - (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler { decisionHandler(WKNavigationResponsePolicyAllow); NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response; // 读取cookies NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL]; for (NSHTTPCookie *cookie in cookies) { [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie]; } if (response.statusCode &amp;&amp; response.statusCode != 200) { LZErrorHintType type = LZErrorHintType404; if (![[Singleton shareInstance] hasNet]) { type = LZErrorHintTypeNet; } __weak typeof(self) weakSelf = self; if (!_errorView) { //弹出错误界面，点击刷新按钮刷新界面 LZErrorHintView *errorView = [[LZErrorHintView alloc] initWithFrame:self.view.bounds type:type refreshBlock:^{ [weakSelf loadHTMLPage]; }]; weakSelf.errorView = errorView; [self.view addSubview:errorView]; } return; } if ([[Singleton shareInstance] hasNet]) { if (_errorView) { [_errorView removeFromSuperview]; _errorView = nil; } }else{ if(!_errorView){ __weak typeof(self) weakSelf = self; LZErrorHintView *errorView = [[LZErrorHintView alloc] initWithFrame:self.view.bounds type:LZErrorHintTypeNet refreshBlock:^{ [weakSelf viewWillAppear:YES]; }]; _errorView = errorView; errorView.tag = 2200; [self.view addSubview:errorView]; } } } 替换UIWebView为WKWebView后遇到的问题及解决方法1. 使用WKWebViewJavascriptBridge进行桥接时，加载H5页面闪退。这里需要更新WebViewJavaScriptBridge桥接框架中WKWebView的桥接方法， - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler { if (webView != _webView) { return; } NSURL *url = navigationAction.request.URL; __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate; if ([_base isWebViewJavascriptBridgeURL:url]) { if ([_base isBridgeLoadedURL:url]) { [_base injectJavascriptFile]; } else if ([_base isQueueMessageURL:url]) { [self WKFlushMessageQueue]; } else { [_base logUnkownMessage:url]; } decisionHandler(WKNavigationActionPolicyCancel); return; // 对比之前的方法，这个地方多了一个return } if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:decidePolicyForNavigationAction:decisionHandler:)]) { [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler]; } else { decisionHandler(WKNavigationActionPolicyAllow); } } 2. WKWebView加载完网页后，点击里面的按钮，不跳转的问题。设置WKWebView的另一个代理WKUIDelegate，从名称能看出它是webView在user interface上的代理， // 创建新的webView // 可以指定配置对象、导航动作对象、window特性。如果没用实现这个方法，不会加载链接，如果返回的是原webview会崩溃。 -(WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures { if (!navigationAction.targetFrame.isMainFrame) { [webView loadRequest:navigationAction.request]; } return nil; } 要调用下面的方法是有条件的，WKNavigationDelegate中的该方法是用户点击网页上的链接，需打开新页面时，将先调，是否允许跳转到链接。 - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler｛ WKFrameInfo *sFrame = navigationAction.sourceFrame;//navigationAction的出处 WKFrameInfo *tFrame = navigationAction.targetFrame;//navigationAction的目标 //只有当 tFrame.mainFrame == NO；时，表明这个 WKNavigationAction 将会新开一个页面。 // 才会调用createWebViewWithConfiguration这个代理方法。 ｝ 这样就新开一个webView，如果我们只是显示网页，这样会消耗性能，没有必要。 3. 如何同步WKWebView的Cookie在将UIWebView替换为WKWebView后加载速度提高了，页面卡死的问题基本没有再出现过。但遇到了一个更加棘手的问题，之前使用的是UIWebView，它会对首次加载H5页面后的用户登录信息进行同步，这样我由当前的H5页面跳转到一个新的UIWebView进行请求时，会自动找到上个页面同步的用户信息，从而加载当前用户对应的内容。 WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。 因此，如何实现多个 WKWebView 之间共享 Cookie（session Cookie and persistent Cookie）数据。是决定能否继续使用WKWebView的关键。如果不能解决这个问题，就只能再继续使用之前的 UIWebView 了，之前所做的一切都没有用处了。 解决多个 WKWebView 之间共享 Cookie 的问题，首先要弄明白三个问题？ WKWebView 与 webView 在 Cookie 设置，读取上有什么不同？ WKWebView 会将对应的 Cookie 存在什么地方？ 如何取到 WKWebView 的 Cookie 并将其注入到要访问的下一个 WKWebView 中？ 结合以上三个问题，在网上搜索很多关于 WKWebView 的 Cookie 存储在什么地方？ 这些资料普遍认为 WKWebView 拥有自己的私有存储，不会将 Cookie 存入到标准的 Cookie 容器 NSHTTPCookieStorage 中。但在实际项目中，却发现 WKWebView 实例可以读取到存储于 NSHTTPCookieStorage 中的 Cookie。最后，看到了腾讯Bugly的一篇技术文章 —- WKWebView 那些坑，也印证了我的观点。 实践发现 WKWebView 实例其实也会将 Cookie 存储于 NSHTTPCookieStorage 中，但存储时机有延迟，在iOS 8上，当页面跳转的时候，当前页面的 Cookie 会写入 NSHTTPCookieStorage 中，而在 iOS 10 上，JS 执行 document.cookie 或服务器 set-cookie 注入的 Cookie 会很快同步到 NSHTTPCookieStorage 中。 看来以后搜索技术文章，不能太片面了，一定要结合一些大厂的权威技术文章来具体分析。 下一步，就是如何在发起请求时注入 通过 NSHTTPCookieStorage 获取的Cookie。网上关于 WKWebView 的 Cookie 注入方法有以下几种: JS注入 —- 在初始化 WKWebView 的时候，通过 WKUserScript 设置，使用javascript 注入 Cookie，一开始发送 NSMutableURLRequest 请求的时候也要加上 Cookie，并且保证两个地方的设置的cookie一致。参考 — Can I set the cookies to be used by a WKWebView? WKHTTPCookieStore —- 利用 iOS11 API WKHTTPCookieStore 解决 WKWebView 首次请求不携带 Cookie 的问题。参考 — iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明 利用 iOS11 之前的 API 解决 WKWebView 首次请求不携带 Cookie 的问题。参考 — iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明 通过让所有 WKWebView 共享同一个 WKProcessPool 实例，可以实现多个 WKWebView 之间共享 Cookie（session Cookie and persistent Cookie） 数据。不过 WKWebView WKProcessPool 实例在 app 杀进程重启后会被重置，导致 WKProcessPool 中的 Cookie、session Cookie 数据丢失，目前也无法实现 WKProcessPool 实例本地化保存。 方法1，经过测试行不通，可能是后台读取 Cookie 的方式有问题；方法2，是 iOS 11 的 API ，不具有普适性；方法3，在测试时无法通过 url 匹配到 Cookie；最后，只剩下方法4了，需要注意在特殊场景下 Cookie 丢失的情况： app 杀进程重启后会被重置，导致 WKProcessPool 中的 Cookie、session Cookie 数据丢失，目前也无法实现 WKProcessPool 实例本地化保存。 但以我们的应用为例，哪怕是主动杀进程，重新打开应用；还是应用突然闪退，重新打开应用。首次加载某个含有用户登录验证的H5页面时，需要在发起请求的地方拼上用户特定信息的参数，因此，即使之前存储的 Cookie 数据丢失了，也会在首次加载时重新获取。如下： Singleton *sin = [Singleton shareInstance]; NSString *baseIpPort = [LZUserDefaults objectForKey:PreferenceKey_SystemInit_ZyPartnerIPPort]; NSString *urlString = [[NSString stringWithFormat:@&quot;%@/test1/test2?Id=%@&amp;Name=%@&amp;Pid=%@&quot;,baseIpPort,sin.clinicId,[LZUserDefaults objectForKey:PreferenceKey_Name],[LZUserDefaults objectForKey:PreferenceKey_Pid]] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]]; request.HTTPMethod = @&quot;POST&quot;; request.timeoutInterval = 15.0f; [_wkWebView loadRequest:request]; 因此，对于 APP 重启后 Cookie 数据可能丢失的情况，难道不可以在首次加载H5页面时，重新获取一下用户登录信息的 Cookie 吗？对我而言，现在的项目就是这样做的。 通过 WKProcessPool 实现多个 WKWebView 之间共享 Cookie1. 新建一个名为 LZWKWebKitSupport 的类，用于生成一个统一的，全局使用同一个 WKProcessPool 的 WKWebView 对象。// LZWKWebKitSupport.h #import &lt;Foundation/Foundation.h&gt; #import &lt;WebKit/WebKit.h&gt; @interface LZWKWebKitSupport : NSObject @property (nonatomic, strong,readonly) WKProcessPool *processPool; + (instancetype)sharedSupport; + (WKWebView *)createSharableWKWebView:(BOOL)isFullScreen isShowNav:(BOOL)showNav; @end // LZWKWebKitSupport.m #import &quot;LZWKWebKitSupport.h&quot; @interface LZWKWebKitSupport() @end @implementation LZWKWebKitSupport + (instancetype)sharedSupport { static LZWKWebKitSupport *_instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _instance = [LZWKWebKitSupport new]; }); return _instance; } - (instancetype)init { if (self = [super init]) { self.processPool = [WKProcessPool new]; } return self; } + (WKWebView *)createSharableWKWebView:(BOOL)isFullScreen isShowNav:(BOOL)showNav { WKUserContentController* userContentController = [WKUserContentController new]; NSMutableString *cookies = [NSMutableString string]; WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:[cookies copy] injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; [userContentController addUserScript:cookieScript]; WKWebViewConfiguration *configuration = [WKWebViewConfiguration new]; // 一下两个属性是允许H5视频自动播放,并且全屏,可忽略 configuration.allowsInlineMediaPlayback = YES; configuration.mediaPlaybackRequiresUserAction = NO; // 全局使用同一个processPool configuration.processPool = [[LZWKWebKitSupport sharedSupport] processPool]; configuration.userContentController = userContentController; // 考虑到左侧菜单栏，需要设置webView的不同frame WKWebView *wk_webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, y, width, height) configuration:configuration]; return wk_webView; } @end 2. 在加载H5的地方初始化 LZWKWebKitSupport，并在 WKNavigationDelegate 中获取 cookie，并设置到本地。// 初始化LZWKWebKitSupport - (void)viewDidLoad{ _wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:YES]; [self.view addSubview:_wkWebView]; } #pragma mark - wkwebviewDelegate //接收到服务器响应 后决定是否允许跳转 - (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler { decisionHandler(WKNavigationResponsePolicyAllow); NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response; // 读取cookie，并设置到本地 NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL]; for (NSHTTPCookie *cookie in cookies) { [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie]; } } 3. 在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。这里以跳转到 LZDetailViewController 页面为例，先是通过LZWKWebKitSupport 初始化一个 WKWebView // LZDetailViewController.m - (void)viewDidLoad { [super viewDidLoad]; //初始化视图 [self setUpSubViews]; } - (void)setUpSubViews{ _wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:NO]; _wkWebView.UIDelegate = self; [self.view addSubview:_wkWebView]; _jsBridge = [WKWebViewJavascriptBridge bridgeForWebView:_wkWebView]; [_jsBridge setWebViewDelegate:self]; } 然后在加载请求时，注入之前设置的 Cookie - (void)loadUrl{ if (!_urlStr) { return; } NSURL *url = [NSURL URLWithString:_urlStr]; NSMutableString *cookies = [NSMutableString string]; NSMutableURLRequest *requestObj = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15.0]; // 一般都只需要同步BJSESSIONID,可视不同需求自己做更改 NSString * BJSESSIONID; // 获取本地所有的Cookie NSArray *tmp = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]; for (NSHTTPCookie * cookie in tmp) { if ([cookie.name isEqualToString:@&quot;BJSESSIONID&quot;]) { BJSESSIONID = cookie.value; break; } } if (BJSESSIONID.length) { // 格式化Cookie [cookies appendFormat:@&quot;BJSESSIONID=%@;&quot;,BJSESSIONID]; } // 注入Cookie [requestObj setValue:cookies forHTTPHeaderField:@&quot;Cookie&quot;]; // 加载请求 [self.wkWebView loadRequest:requestObj]; } 通过以上三步就可以达到同步 Cookie 的目的，现在看来之前通过 JS脚本 注入 Cookie 失败，可能是由于后台需要同步 BJSESSIONID，而BJSESSIONID 是 HtppOnly，不允许通过js脚本修改。 最后，需要特别注意的一点是：考虑在加载H5页前，是否需要清除某些H5页面的 Cookie ? 这里对于我们的项目而言，加载的需要验证用户身份信息的H5页面，是需要清除 Cookie 的，因为用户的权限不同，所看到的界面就不同，在同一台设备下切换不同的用户时，如果不清除之前的 Cookie，所展示的就是上一个用户的信息。 - (void)deleteWKCookies { // 清除WKWebView缓存的cookie(根据ip) if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 9.0){ NSString *iPPort = [LZUserDefaults objectForKey:PreferenceKey_SystemInit_ZyIPPort]; NSArray *iPPortArray = [iPPort componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@&quot;/&quot;]]; NSString *recordIP; if ([iPPortArray count] &gt; 2) { recordIP = partnerIPPortArray[2]; } WKWebsiteDataStore *dateStore = [WKWebsiteDataStore defaultDataStore]; [dateStore fetchDataRecordsOfTypes:[WKWebsiteDataStore allWebsiteDataTypes] completionHandler:^(NSArray&lt;WKWebsiteDataRecord *&gt; * __nonnull records) { for (WKWebsiteDataRecord *record in records) { // 以www.baidu.com为例，是否包含baidu.com if ([recordIP containsString:record.displayName]) { [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:record.dataTypes forDataRecords:@[record] completionHandler:^{ NSLog(@&quot;Cookies for %@ deleted successfully&quot;,record.displayName); }]; } } }]; } } WebView性能优化总结一个加载网页的过程中，native、网络、后端处理、CPU都会参与，各自都有必要的工作和依赖关系；让他们相互并行处理而不是相互阻塞才可以让网页加载更快： WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。 后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。 脚本执行慢，就让脚本在最后运行，不阻塞页面解析。 同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。 WebView初始化慢，就随时初始化好一个WebView待用。 DNS和链接慢，想办法复用客户端使用的域名和链接。 脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。 上面是美团点评技术团队关于WebView性能优化的总结。 对比我们项目中有哪些页面用到了 UIWebView，哪些用到了 WKWebView，发现当前程序中一共有8个主要模块，其中，一共有4个主要模块是通过加载H5页面展示的，还有一个模块中部分嵌套了H5页面。这些页面中，有三个页面使用 WkWebView 加载，剩下的使用的是 UIWebView 加载页面，发生卡顿的页面多是频繁初始化 UIWebView 加载H5时发生的。 这里我们的项目中使用UIWebView 和 WKWebView 的地方有很多，没有一个管理类去居中调控的话，后期维护起来会很耗时，而且很容易出现bug。下一步的优化就是要构建这样一种集构建，配置，分发，操控为一身的通用类。 Apple Staff 的建议关于在 WKwebView 中如何获取 Cookies，苹果的工程师也给出了建议（May 11, 2017 1:40 AM） There isn’t a solution that works in all cases, alas. All the approaches I know of have issues: NSHTTPCookieStorage isn’t reliable because WKWebView does all of its networking in a separate process, so you can’t get at the NSHTTPCookieStorage object being used by the web view. JavaScript (like the WKUserScript example you referenced) doesn’t see any cookies tagged with HttpOnly. WKWebsiteDataStore lets you know of the existence of the cookie but doesn’t let you get the contents. The delegate approach you showed (which I’d not seen before, so brav{o,a} for your creativity!) won’t see all the cookies because not all responses are navigation responses. Under normal circumstances I’d recommend that you file an enhancement request requesting a better approach for this, but in this case I happen to know that WebKit Engineering is well aware of this issue (r. 31024691).Right now the only approach that works in all cases is to use UIWebView, which is obviously less than ideal. 但最后也提到了：目前，在所有情况下唯一有效的方法是使用 UIWebView，但这显然是不太理想的方案，和使用 WKWebView 的初衷相违背。 参考资料WebView性能、体验分析与优化 webView:decidePolicyForNavigationAction:decisionHandler: WKWebView 那些坑 iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明 Developer wknavigationdelegate documentation WKWebView and UIWebView Cookie How to get all cookies from WKWebView –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"wkWebView","slug":"wkWebView","permalink":"http://XibHe.github.io/tags/wkWebView/"},{"name":"webView性能调优","slug":"webView性能调优","permalink":"http://XibHe.github.io/tags/webView性能调优/"}]},{"title":"2017年度总结","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/2017deadline/","text":"转眼间2017就要结束了，回首过去的一年，有过彷徨，有过不安，也有收获的感动与喜悦。过完17年我就拥有四年开发经验了，一直觉得四到五年的阶段是区别高级开发与初中级开发的分水岭。但这并不使我感到高兴，我深知这四年时光中一多半是在蹉跎中度过的。往之不谏，来者可追！2018！我来了。 家庭对我这个年龄来说，结婚的很少，更别提孩子了。但我已经为人夫，为人父了！似乎用两三年的时间走完了别人十几年的路。太过年轻的我，总会时不时忘记自己身为父亲的责任，我媳妇(花花)总会不厌其烦的唤起我作为父亲该承担的责任。家里的大事小情，在花花的安排下井井有条。孩子的奶粉，尿不湿也不用我来操心，为了分担我的压力，花花早早给儿子断了母乳，离家挣钱。对花花我即心疼又愧疚，我不能一直用年轻作为借口，逃避身为男人的责任。家庭永远是第一位！ 每个人都有属于自己的人生遥控器，它无时无刻不掌握在你自己的手中，你可以随时按快进键让时间从你的手中逃走，你也可以按回退键，想想自己曾经的错过与失误，你也可以按跳过键，它的另外一个名字叫做逃避…… 从前有个精灵一直在寻找彩虹那端的金罐，但最后，他发现那只是一罐麦片。 博客年初给自己定下了一个目标：每周至少写一篇博客。到目前为止，算上这篇，一共是25篇。这25篇文章中，有5篇是译文，5篇是个人感悟，剩下15篇是技术上的分享。技术上的分享有些很肤浅，和大咖们由浅入深的技术文章比起来有些相形见绌。但我还是会坚持写下去的，须知泰山非一日之功。 写一篇鞭辟入里的爽文真的很费时间，前期需要阅读大量的相关文章，技术文档。最难得还是将所要描述的知识点与实际的代码，产品需求结合起来。因此，当你在自己的项目中解决了一个棘手的bug，或者实现了一个复杂的产品需求时，你再将这些解决问题的方案写成博客，就会有一种“下笔如有神”的感觉。就好比最近写了一篇名为利用JenKins持续集成iOS项目时遇到的问题博文，通篇写下爱特别顺畅。因为这些流程都是我切身经历过得，在这里也只是再复述一篇操作流程而已。 相比之下这篇文章 — AFNetworking到底做了什么？ 写起来就不那么顺利，自己没有切实经历过，整个AFNetworking的源码，马马虎虎的读了两遍，不能透彻理解其中的精髓。也只能转载别人的观点。 自从给自己定下了一周至少写一篇博客的目标后，每到周末就特纠结，搜肠刮肚的想着如何结合实际开发构思出一篇好博文。有时实在没有好的点子，就翻译Medium和湾区日报上推荐的英文文章，或者写一些个人心得体会。 今年写的一些技术性文章也有不尽如人意的地方，有些文章，写的很粗浅，没有刨根问底追溯到本质上。有些文章是迫于一周要写一篇博文而拼凑成的，今年不会如此只求量而不求质了。但以文字的形式记录分享开发心得的习惯，一旦养成，就不会轻易舍弃，这算是2017年一个明显的收获吧！ 读书今年看完了《图解HTTP》、《黑客与画家》、《软技能:代码之外的生存指南》。正在看的有《人类简史》、《啊哈!算法》。看《啊哈!算法》时，看的快忘得也快，还是没有结合实践，将书上的算法，用代码实现一遍。 在这些书中，《黑客与画家》这本书书对我启发最大，里面很多论述让我有种醍醐灌顶的感觉。现在回想起来，书中很多内容已经忘得差不多了，唯一记得的是：编程和绘画一样，是需要走心的，需要绞尽脑汁去构思的。 偶然在知乎上看到你是怎么看完《JavaScript权威指南》《JavaScript高级程序设计》等这类厚书的？的提问，摘录其中一个赞同数最高的回答： 与其说看书不如说看目录，从目录里找到感兴趣的章节，看掉，看到中途没兴趣了，就放下下次再看。工作中碰到什么问题不明白需要参考了，还是看目录，才大概会在什么章节里，探索一番，中间如果碰到感兴趣的，看掉，看到中间没兴趣了，放下，下次再看。要不了多久，整本书的70%-80%都翻遍了，其中有20%-30%翻了不止一遍，这些往往是核心的知识；至于剩下的20%没看过的，以后或许有机会的，没机会也不要紧，很多时候自己已经通过各种机缘学到了。 所以看技术厚书不在于多块或多慢，而是从容。 其中，我认为结合书中知识点，理论联系实践是最为有效的掌握知识点的方法。读一些非技术的书籍，最重要的是能够让自己心安。 此心安处是吾乡 关于买书，今年没有买一本书。因为去年买的书，大概有七八本吧！只看完了三本，还有向公司申请采购的3本技术书籍，手中库存的书足够我看了。2018年在此立一个flag：看完6本书！ 新部门今年12月份时被调到一个新部门，开始接触到公司最为核心的项目。想想就有些小激动啊！因此，也会给自己提出更高的要求，写功能模块时要注意与其他功能的耦合性，兼顾需要考虑程序的性能，容错机制的相应。现有的开发模式，耦合性太高，如何实现高可用的组件化，降低功能模块间的耦合性？将是我们这个团队在18年需要重点考录的问题。希望能为这次项目模块的优化重构尽自己的一份力量。 新技术9月初接触微信小程序，和部门另外两个H5一起开发公司的一款小程序。中间吃了小程序产品原型还是是基于原生App思维而设计的亏，同时，也由于自己没有完全吃透小程序开发文档，在实现一些功能时踩了坑。 这次小程序开发经历使我意识到自己的技术短板，陷入对技术的狂热之中。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。 请勿陷入对技术的狂热之中 若是早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不再积极进取，不再学习新技术。这种开发者被称为“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。 2018年，新的一年，要在原有技术的基础之上找到突破口，将自己以前囫囵吞枣的知识点再好好品味一番。同时，也不能仅仅局限于iOS一方面的技术。 今年最直观的感觉是自己对于新技术的渴望，缺少那种如饥食渴的痴迷感。苹果开发者大会上的ARKit，CoreML，SiriKit这些新技术，对于我这个iOS开发者竟然毫无吸引力可言。这是我身上存在的一个大的缺陷，也是程序员堕落，不思进取的开始。对于程序员来说，最大的悲哀并不是35岁后被华为辞退，也不是42岁后跳楼。 而是： 不再向往新技术。 stay hungry，stay foolish. 愿景家人朋友身体健康，自己技术日臻成熟。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢！","tags":[{"name":"2017","slug":"2017","permalink":"http://XibHe.github.io/tags/2017/"},{"name":"年度总结","slug":"年度总结","permalink":"http://XibHe.github.io/tags/年度总结/"}]},{"title":"(译)创业就是要发起一场思想运动","date":"2017-12-08T16:00:00.000Z","path":"2017/12/09/Build a Movement/","text":"作为一个创业者，我并不喜欢和开发者在午餐时间发生争论。 ”这是胡说，“我们的首席技术官回复。“MailChimp的产品并不比其他产品好，这只是另一个发送消息的通讯工具而已。当它竞争对手提供同样的功能只需要花费几块钱时，为什么每月要额外花费200美元呢？“ 我想说服他，MailChimp确保我们的电子邮件广告系列投递到顾客的收件箱，而不是他们的垃圾邮件文件夹。 但是他一直用我没有完全明白的技术解释来反驳我。 “看，我们甚至可以建立我们自己的电子邮件机器人，做同样的事情，”他补充说。“你只是因为他们的品牌知名才使用它。” 是的，在一定程度上他说的很对。 在过去的几年中，MailChimp已经建立了一个标志性的品牌以其设计为中心的方法和非传统的营销活动。 猴子吉祥物广告牌没有提到他们的名字…“MailKimp”和参与其他趣味取名活动达到了3.34亿人…以设计为中心的年度报告与风格… MailChimp的赠品也是非常规的。为猫咪准备的免费猴子帽子打动了像我一样准备付更多钱的超级粉丝。 在一个任何人都可以一夜之间复制你的产品的世界里，MailChimp选择为猫咪编织猴子帽子，而不是进行军备竞赛建立更多的功能。 毕竟，公司甚至还接到一些大客户的公开信和警告，如果没有更高级的功能，就有可能转向竞争对手。 MailChimp的回答？ 重点打造品牌客户的爱心。 当我们接近2017年年底时，从未在外部资金上花费一分钱的电子邮件创业公司正在准备结束令人兴奋的增长达1500万客户的一年。 但是猴子生意足够了。 让我们着眼大局，了解这对初创企业如何在当今混乱的世界取得成功意味着什么： 你不必扰乱整个行业:尽管许多企业家正忙于构建下一个Uber或Facebook，但这是一个我们需要消除的神话。MailChimp并没有打乱任何一个行业，但它却在一个日益拥挤的市场上建立起了猴王国。 如果你不打扰或创造一个全新的市场，你仍然可以在竞争激烈的行业里建立一个帝国:而且它涉及越来越多的超级粉丝，他们虔诚地跟随你的运动，即使你收取溢价，或者拒绝参加建立更多特征的军备竞赛，仍然会推荐你的品牌。 但是，秘密是什么？ 你如何接触民众，发展你的粉丝俱乐部，让你按自己的规则玩游戏，而不用担心竞争？ 选择各不相同，但一些世界上最成功的创业公司使用两个强大的战略: 首先显然是“MailChimp方式”，即，将您的产品推销为高品质的品牌。正如他的创始人Ben Chestnut解释的那样: 我们为商业客户制作应用程序，使用低价位的零件，然后以高质量，以设计为中心，可爱的B2C品牌推广应用程序。 但是越来越多的蓬勃发展的创业公司使用另一种策略 - 不一定需要以设计为中心的方法。 它需要反过来影响人的思维： 不要扰乱一个行业，扰乱思想 正如马克·博切克（Mark Bonchek）在他广受欢迎的哈佛杂文中所强调的那样： 成功销售和销售创新的公司能够改变人们，不仅关注他们的产品，而且关心他们自己，市场和世界的想法。 不要销售产品，销售一种全新的思维方式。 拿Drift来说，今天科技界的新星之一。 并不是强迫人们理解他们的产品，像Drift这样的“推动者”推销思想的根本转变，即，引起他们创新的原始洞察力。 对Drift而言，最初的洞察力导致了营销和销售方式的破旧，仍然依赖网站形式和烦人的销售后续行动。 这就是为什么，他们没有硬去销售或用产品信息淹没他们的博客，而是谈论今天的营销和销售技巧是怎样的，或者为什么营销自动化和电子邮件营销被打破。 这与你的价值主张不同。这是一个关于世界如何运作的假设（通常是无意识的），“Bonchek补充道。 当你将其视为模板时，该逻辑很容易应用于任何创业项目： 我们支持[插入]，并将人们思考[插入]的方式转变为[插入]。 例如，Drift支持新的营销和销售方式，将人们对营销和销售的看法转变为更多的谈话驱动，个性化和人性化。 另外两家标志性公司–Basecamp和Salesforce也在重新思考现有的心智模式方面处于领先地位。 Basecamp的创始人通过倡导“非硅谷之路”，改变人们对管理，生产力，时间，增长或创业公司运作方式的看法，来壮大自己的超级粉丝。 Salesforce捍卫“无软件”的口号，将思想从打包的安装软件转移到云计算和软件即服务。 建立一个改变人们思维的引擎 改变人们目前的思维模式不是一朝一夕就能实现的。 相反，你将需要一个可持续的引擎，一次又一次地在不同的环境和情况下向人们展示新的心智模式。 例如，尽管Drift的博客每月已经超过了10万人，他们打开新的渠道，达到他们无法达到的观众，否则他们不会通过： 他们一年一度的“超级增长”会议，专门讨论营销和销售的未来; 他们的“寻找智慧”播客，通过音频对话传播他们的信息。 像Drift一样，Basecamp的创始人们建立了一个多渠道的引擎，通过他们的畅销书，如’返工‘，他们的流行博客和播客来接触新的人。 尽管如此，建立一个引导人们去思考新的思维方式的方法并不是保留给创业公司的。 像GE这样的大公司已经认识到他们称之为“市场份额之前的分享”的重要性。 GE的首席营销官Beth Comstock解释了为什么他们大量投资于内容引擎: 真正好的创新需要在被接受之前得到解释……这意味着成为一家内容工厂 - 从数据到视频，再到社交媒体，讲述媒体和方法的故事。 MailChimp的方式，Drift的方式，或着你的方式 从博主到创业创始人，今天的制作者们都越来越关注： 噪音太大，竞争如此激烈。 像SaaS这样的空间变得越来越有竞争力，公司觉得他们差不多是在出售商品，或者他们的产品可以在一夜之间复制。 这就是为什么在今天这个历史上最混乱的市场上，建立一场运动比以往任何时候都重要。 建立它，以MailChimp方式，漂移的方式，或你的方式。不管你采取什么样的路线，在企业中有一个与自己相得益彰的要素是一致的：对自己忠实。 对于MailChimp来说，这意味着推出非常规的营销活动，故意错误地发音他们的名字： 我们相信与客户建立关系的最好方式就是成为你自己。 对我们来说，这意味着我们的名字有乐趣。 对于Drift来说，这意味着在他们的首席营销官和首席执行官之间进行诚实的交谈 虽然世界上充斥着假装看起来专业的播客，Drift的非正式播客风格是“寻求智慧”拥有忠实粉丝的原因之一。 正如Basecamp的创始人所指出的那样，倾注于自己的产品是一种从人群中脱颖而出的有力方式： 如果你成功了，人们会试着复制你所做的。但是有一个很好的方法来保护自己免受抄袭： 让你成为你的产品或服务的一部分。注入你对销售方式的独特看法。 把自己投入到产品和产品周围：你是如何销售的，你是如何提供产品支持的，你是如何向顾客解释产品的，以及你是如何交付产品的。 竞争者永远不能复制你的产品。 这对生意有好处。 - 不要建立一个初创公司，而是发起一场运动 - 从第一天开始。 如果你做得对，像我这样的超级粉丝可能会自愿花午餐时间，因采用你提供的方案而与他人进行激烈的讨论。 原文地址Don’t Build a Startup, Build a Movement –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"创业","slug":"创业","permalink":"http://XibHe.github.io/tags/创业/"}]},{"title":"AFNetworking到底做了什么？","date":"2017-11-25T16:00:00.000Z","path":"2017/11/26/AF3.x/","text":"最近在对接一个demo，主要是调用一下SDK，实现一些功能。发现这个demo的网络请求部分是基于NSURLConnection做的一些简单调用。用起来感觉总是怪怪的，于是就想切换回自己一直在用的AFNetworking。结果，和我想的还是不太一致。同时，也暴露出一个严重的问题：对AFNetworking实现原理，到底做了什么？可以说是一窍不通。之前一直以为对AFNetworking很熟悉了，现在看来，也只是停留在调用AFHTTPSessionManager的表面。 NSURLSession， NSURLSessionDataTask这两个类是iOS做网络请求的核心类，而AFNetworking则是对其做了一系列封装，简化了使用系统原生API做网络请求的过程。 更新说明更新记录: 2017 年 11 月，第一版。 2017 年 12 月，对具体的步骤进行归类整理。 对AFNetworking调用是做了一层简单的封装，将请求时用到的各种参数在一个继承自NSObject的类中统一配置。如下， + (void)postWithUrl:(NSString*)url params:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间 manager.responseSerializer = [AFJSONResponseSerializer serializer]; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@&quot;text/html&quot;]; [manager POST:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSDictionary *bodyObjDic = [responseObject objectForKey:@&quot;body&quot;]; CLog(@&quot;bodyObjDic = %@&quot;,bodyObjDic); NSString *code = [bodyObjDic objectForKey:@&quot;code&quot;]; CLog(@&quot;url = %@,code = %@&quot;,url,code); if ([code isEqualToString:@&quot;200&quot;]) { if(success) success ([responseObject objectForKey:@&quot;body&quot;]); } else if(code == nil){ NSError *error = [NSError errorWithDomain:@&quot;请求错误&quot; code:-1 userInfo:nil]; if(failure) failure(error); } } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { if([@&quot;NSURLErrorDomain&quot; isEqualToString:error.domain]){ error = [NSError errorWithDomain:@&quot;请监测您的网络环境&quot; code:error.code userInfo:nil]; } if([@&quot;NSCocoaErrorDomain&quot; isEqualToString:error.domain]){ error = [NSError errorWithDomain:@&quot;服务器繁忙，请稍候重试&quot; code:error.code userInfo:nil]; } if(failure) failure(error); }]; } 再将所有用于请求的url都放在这个类的类别中，统一管理。如下， /** 注册接口 */ + (void)getRegistedWithParams:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure { [self postWithUrl:[NSString stringWithFormat:@&quot;%@&quot;,kILVBHost] params:params success:^(id JSON) { if(success){ success(JSON); } } failure:^(NSError *error) { if(failure){ failure(error); } }]; } demo在网络请求时，会将参数转换并设置到HTTPBody中，上面那种直接使用AFHTTPSessionManager进行POST请求的方式就不行，其无法在请求时将请求的参数设置到request的HTTPBody中。于是，尝试通过新建一个NSMutableURLRequest请求，通过设置它的HTTPBody到达目的。如下， + (void)postWithUrl:(NSString*)url params:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间 manager.responseSerializer = [AFJSONResponseSerializer serializer]; NSError *requestError = nil; NSMutableURLRequest *request = [manager.requestSerializer requestWithMethod:@&quot;POST&quot; URLString:url parameters:params error:&amp;requestError]; request.HTTPBody = [NSData data]; [manager.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { CLog(@&quot;data = %@,response = %@&quot;,data,response); }]; } 但请求时会报500的错误。看来还需要接着往深了抛，看看AFNetworking到底做了什么？ 这里之所以会设置manager.requestSerializer为： [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; 是将NSMutableURLRequest与manager.requestSerializer混为一谈了。 demo中通过NSMutableURLRequest设置相应的请求头的属性值，如下： NSURL *URL = [NSURL URLWithString:url]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL]; if (data){ [request setValue:[NSString stringWithFormat:@&quot;%ld&quot;,(long)[data length]] forHTTPHeaderField:@&quot;Content-Length&quot;]; [request setHTTPMethod:@&quot;POST&quot;]; [request setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [request setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; [request setHTTPBody:data]; } 而manager.requestSerializer用于设置AFHTTPRequestSerializer(请求参数解析类)的，之所以会报解析或者服务器先关错误，是由于没有设置网络请求的解析方式导致。而responseSerializer默认使用了JSON的解析方式，这也是为什么当使用AFN进行网络请求时，JSON会自动进行解析的原因。这里如果想进行默认的request和response序列化，就要在manager的默认设置完成之后，在开始进行网络访问前使用： AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.requestSerializer = [AFJSONRequestSerializer serializer]; manager.responseSerializer = [AFJSONResponseSerializer serializer]; 即可实现返回数据的自动解析。 AFNetworking到底做了什么？AFNetworking概述图片所在原文链接 AF分为如下5个功能模块： 网络通信模块(AFURLSessionManager、AFHTTPSessionManger) 网络通信信息序列化/反序列化模块(Serialization) 网络状态监听模块(Reachability) 网络通信安全策略模块(Security) 对于iOS UIKit库的扩展(UIKit) AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的上层封装。而其余的四个模块，均是为了配合AFURLSessionManager类的网络通信做一些必要的处理工作。如上图，所示。 其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager去做。 以上内容原文链接 对外接口类AFHTTPSessionManagerAFHTTPSessionManager不做实事，只是提供了对外调用的接口。 调用父类方法进行初始化 - (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } //.... return self; } 类似网络请求方法中，调用父类方法拿到task，这个类仅仅是把得到的task，resume即可 NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot; URLString:URLString parameters:parameters uploadProgress:nil downloadProgress:downloadProgress success:success failure:failure]; // 开始任务 [dataTask resume]; AFHTTPSessionManager还做了一件很重要的事，就是把传过来的参数，编码成我们请求时需要的request，并且传给父类去做网络请求。 NSURLSession， NSURLSessionDataTask NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; AFNetworking请求核心类：AFURLSessionManagerNSURLSessionDataTask,AFHTTPSessionManager的初始化方法，触发了这个类所有的初始化初始化方法： - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration； - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super init]; if (!self) { return nil; } if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; // queue并发线程数为1，这个是代理回调的queue self.operationQueue.maxConcurrentOperationCount = 1; // 注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法。 self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 各种响应转码 self.responseSerializer = [AFJSONResponseSerializer serializer]; // ssl证书，是验证证书，还是公钥，还是不用 self.securityPolicy = [AFSecurityPolicy defaultPolicy]; #if !TARGET_OS_WATCH self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; #endif // 设置存储NSURL，task与AFURLSessionManagerTaskDelegate的词典（重点，在AF中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理） self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; // 设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; // 为所管理的session的所有task设置完成块,此方法为生成session之后就调用 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { // 置空处理 for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self; } 这个方法初始化了一些我们后续需要用到的属性，其他的都很简单，唯一比较费解的两处可能是： self.operationQueue.maxConcurrentOperationCount = 1; [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { //置空处理 }]; 我们首先来讲讲这两个操作的作用： 第一是让回调的代理queue是串行的，即请求完成的task只能一个个被回调。 第二是清空了session中所有task。 - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { // 第一件事，创建NSURLSessionDataTask，里面适配了Ios8以下taskIdentifiers，函数创建task对象。 __block NSURLSessionDataTask *dataTask = nil; // 其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理 url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask; } 类似这个类中很多方法这样的方法，这些方法主要做两件事： 调用session的方法，传request过去去生成task。注意这里调用了url_session_manager_create_task_safely函数去执行的Block,这个函数实现如下： static void url_session_manager_create_task_safely(dispatch_block_t block) { if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) { dispatch_sync(url_session_manager_creation_queue(), block); } else { block(); } } 简单来讲就是为了适配iOS8以下task创建，其中taskIdentifiers属性不唯一，而这个属性是我们之后添加代理的key，它必须是唯一的。 所以这里做了一个判断，如果是iOS8以下，则用串行同步的方式去执行这个Block，也就是创建session。否则直接执行。 给每个task创建并对应一个AF的代理对象，这基本上是这个类的核心所在了，这个代理对象为其对应的“task做数据拼接及成功回调。 方法如下： - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler { AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系 delegate.manager = self; delegate.completionHandler = completionHandler; // 这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应 dataTask.taskDescription = self.taskDescriptionForSessionTasks; // 将AF delegate对象与 dataTask建立关系 [self setDelegate:delegate forTask:dataTask]; // 设置AF delegate的上传进度，下载进度块 delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock; } 将AF delegate对象与dataTask建立关系 - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task { // 断言，如果没有这个参数，debug下crash在这 NSParameterAssert(task); NSParameterAssert(delegate); // 加锁保证字典线程安全 [self.lock lock]; // 将AF delegate放入以taskIdentifier标记的字典中（同一个NSURLSession中的taskIdentifier是唯一的） self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // 为AF delegate 设置task 的progress监听 [delegate setupProgressForTask:task]; // 添加task开始和暂停的通知 [self addNotificationObserverForTask:task]; [self.lock unlock]; } 以上两个方法创建了一个AFURLSessionManagerTaskDelegate的代理，把这个代理和task的taskIdentifier一一对应，放到我们最早初始化的字典里，建立起映射。 我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，这些代理开始调用了： NSURLSessionDelegate： - (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(NSError *)error； - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler; NSURLSessionTaskDelegate： - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error； NSURLSessionDataDelegate： - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler； - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask； - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data； - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler； NSURLSessionDownloadDelegate： - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location； - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite； - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes； AFURLSessionManager一共实现了如上所列举的一大堆NSUrlSession相关的代理。 而只转发了其中3条到AF自定义的delegate中： NSURLSessionTaskDelegate： - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error; NSURLSessionDataTaskDelegate： - (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data; NSURLSessionDownloadTaskDelegate： - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location; AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。 总结一下，这些代理主要是做了一些额外的处理，并且调用了它的属性Block： @interface AFURLSessionManager () @property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid; @property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge; @property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession; @end 等属性…… 我们可以利用这些Block，做一些自定义的处理，Block会随着代理调用而被调用，这些代理帮我们做了一些类似数据分片、断点续传、https认证等工作 除此之外，有3个代理方法回调了我们的task的AF代理，包括请求完成的代理，收到数据的代理，以及下载完成的代理，以第一个为例： - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 根据task去取我们一开始创建绑定的delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) { // 把代理转发给我们绑定的delegate [delegate URLSession:session task:task didCompleteWithError:error]; // 转发完移除delegate [self removeDelegateForTask:task]; } // 公用Block回调 if (self.taskDidComplete) { self.taskDidComplete(session, task, error); } } 通过我们之前设置的task和AF代理映射，去调用AF代理，并且把这个task从映射字典中移除。 接着就调用了AF的代理：(自定义代理3条中的一条) // AF实现的代理！被从urlsession那转发到这 - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; // 用来存储一些相关信息，来发送通知用的 __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; // 存储responseSerializer响应解析对象 userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; // Performance Improvement from #2672 // **注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存** NSData *data = nil; if (self.mutableData) { data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; } // 继续给userinfo填数据 if (self.downloadFileURL) { userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; } else if (data) { userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; } // 错误处理 if (error) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; // 可以自己自定义完成组 和自定义完成queue,完成回调 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, error); } // 主线程中完成通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); } else { dispatch_async(url_session_manager_processing_queue(), ^{ NSError *serializationError = nil; // 解析数据 responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 如果是下载文件，那么responseObject为下载的路径 if (self.downloadFileURL) { responseObject = self.downloadFileURL; } // 写入userInfo if (responseObject) { userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; } // 如果解析错误 if (serializationError) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; } // 回调结果 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, serializationError); } dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); }); } } 虽然这个方法有点长，但是它主要做了两件事： 调用responseSerializer按照我们设置的格式，解析请求到的数据。 用completionHandler把数据回调出去，至此数据回到了用户手中。 到这里，AF的整个主线流程就完了，当然，我们跳过了很多细节没有讲，比如responseSerializer的各种格式的解析过程，还有为了监听task的开始和挂起通知，所做的method swizzling，这里对iOS7的兼容问题的处理，算是相当精彩了。 以上内容原文链接 处理请求和响应：AFURLSerialization对发出请求以及接收响应的过程进行序列化，这涉及到两个模块： AFURLResponseSerialization AFURLRequestSerialization 前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。我们首先会对 AFURLResponseSerialization 进行简单的介绍，因为这个模块使用在 AFURLSessionManager 也就是核心类中，而后者 AFURLRequestSerialization* 主要用于 AFHTTPSessionManager** 中，因为它主要用于修改 HTTP 头部。 有关解析类的详情见原文： 处理请求和响应 AFURLSerialization（三) 小结本来想自己写关于AFN的使用心得，但发现自己的水平有限，不能把AFN主要做了什么？它是如何实现网络请求和解析的？这些问题说明白。只能将大牛文章中的精彩内容粘贴出来，做了一个简短的整理。这里引述涂耀辉在AFNetworking到底做了什么? (终)一文中所说的一句话： AFNetworking中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。 参考资料如何使用 AFNetworking 3.0 设置 Request.HttpBody AFNetworking到底做了什么？ AFNetworking到底做了什么？(二) AFNetworking 概述（一） 处理请求和响应 AFURLSerialization（三)","tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://XibHe.github.io/tags/AFNetworking/"}]},{"title":"(译)软件开发这份工作到了35岁之后就是尽头了吗","date":"2017-11-18T16:00:00.000Z","path":"2017/11/19/dead-end job /","text":"我想你会问3个不同的问题，也许应该修改一下这个问题。我们来分解一下吧： 年龄歧视是软件开发行业中的问题吗？ 你应该把自己的职业转向管理角色，而不是个人开发者角色吗？ 软件开发个人开发者是一个死胡同吗？ 在Quora上关于这些问题的提问，每个问题都有详细的回答，其中细节如上所述，所以我将简要地讨论每个问题。 对于年龄歧视，我不认为有人会否认这个行业有一定的年龄歧视。你可以看看几乎所有硅谷公司的新员工的平均年龄。我怀疑，大多数中等雇佣年龄远低于30。然而，这并不一定意味着官方的公司政策不会雇用超过一定年龄，种族，性别，性别偏好或其他特征的候选人。 为什么在高科技产业中存在年龄歧视，原因是多方面的，并非是所有公司一起商量好不雇用年长员工。一方面，许多公司发现，使用新的大学毕业生（麻省理工学院和斯坦福大学等）作为招聘的主要对象是最容易的。新毕业生便宜。他们有一个稳定的质量。他们不受其他公司经验的束缚。他们是一张白纸，比较容易教他们企业文化，软件方法论，最佳实践，并与参与其他业务的新毕业相互配合工作。 我认为，硅谷的任何人都不会认为，如果你有一个在相关技术方面拥有3年扎实编程经验的候选人（加上也是有名望的毕业生），不是一个好的候选人。事实上，我甚至可以说N年开发经验并不重要，没有确切的说明，有N年相关经验的候选人比N + 1年经验的候选人要好，所有其他因素是平等的，技能 以及与公司正在进行的业务相关的经验。 对于工程师来说，保持相关性的技术变化太快的说法可能是一回事，但是构建网络的核心技术已经存在了几十年了。C语言早在七十年代末就出现了，已近有将近四十多年的历史了。Javascript语言，第一次出现在1997年，大概是20年前。这意味着几十年开发经验的工程师，他们的工作已经接近退休年龄，整个职业生涯一直专注于C和运行Unix服务器。这样的工程师非常少，有这么多的经验，但是我怀疑有谁会试图宣称刚刚毕业的22岁的人肯定比60岁的人好，相比之下，他们的一些人已近专研了40多年技术。当然，这些类型的工程师很少。 因此，对于问题的另一方面，我不认为软件工程是一个死胡同的事业。我想说的是，在薪酬增长方面，在一定的时间之后，它会趋于稳定。部分原因就是工程师本质上是人为的商品。除非你是一个非常特别的工程师，事实上，你总是可以被其他人取代。与其他竞争性行业相比，我认为这有助于保持软件工程工资水平。不过，我几乎可以保证，对软件工程师的需求将超过应聘者中新毕业生或其他人的供应，所以你总能找到工作。不过，你可能不会每年收到那些10％的指数提升，就像你两三年前那样。 最后，关于转为管理者是否是一个更好的选择，我想问为什么只考虑这个选项？当然有许多职业道路可供选择。你可以转换到另一个工程领域。例如，许多不喜欢创造产品的软件工程师会转移到其他角色，有时在同一个公司，例如运营，产品管理，项目管理，质量保证，或者更少的技术，如销售或行政职位。我也有一些完全改变职业的朋友，比如全职教学。 最后让我说，以为自己为例，在和那些具有扎实工程背景的经理人员一起工作时，我很欣赏他们，最好是与公司相关技术的软件工程，所以请不要急于进入工程管理的职业道路。对于我们这些将来可能不得不与你打交道的人，作为开发者，可以获得5年或6年的良好工程实践经验。了解这个行业是如何运作的，作为一个经验丰富的开发者。只有这样，才能考虑把你的职业转向管理方向。就像你不会雇用花店来建造布鲁克林大桥。同样也不会聘请没有任何开发经验的人担任项目经理。 原文地址Is software development really a dead-end job after age 35-40? –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"职业生涯","slug":"职业生涯","permalink":"http://XibHe.github.io/tags/职业生涯/"}]},{"title":"凌冬将至","date":"2017-11-10T16:00:00.000Z","path":"2017/11/11/introspect/","text":"至此光棍节来临之际，祝各位光棍们节日快乐，年年无今日，岁岁无今朝，早日脱单。最近一个月不是很忙，之前做的项目在8月中旬停了下来，项目是停了下来，但整个项目组却闲不下来。九月份接手了一个新需求，为公司的另一个项目开发录入药品的小程序。工期算上测试、发布大概是二十天。这中间虽然是第一次接触小程序开发，最后，跌跌撞撞的总算是顺利上线了。 开发小程序的这段时间，总是有些难熬，自己之前并没有HTML、CSS、JavaScript的基础，在w3cschool上看了两天的HTML、CSS基础，就硬着头皮上了。不过还好有一个前端老司机带着，一起踩踩小程序的坑。在前两年前端很火的时候，我就很想跟风学习一下了，但总是给自己找各种理由。最后，学习计划就不了了之了。这次的学习动机来的如此强烈，看来只有将自己的学习动力与工作中的业务需求捆绑起来，才能迈出这第一步。 随着开发的深入，不得不惊讶于小程序“用完即走”的设计理念。与移动端APP相比，小程序真的很小，开发成本小的多。不得不感慨，移动开发的凌冬将至，或许早已来临了。苹果的光环正在消退，不只是iOS开发，没有哪种技术是长盛不衰的，对所有的与技术相关的开发者而言: 请勿陷入对技术的狂热之中 自从今年以来，发现了自己的技术短板。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。 最近两年以来，互联网的发展不再像早期那样粗放了，对各种技术人员的需求趋于稳定。“一招鲜，吃遍天”的时代终会落幕，全栈会成为一种趋势。不只贫穷会限制我们的想象力，作为一名开发者，我们因对某项技术的狂热崇拜也会限制我们在业务需求上的想象力。应戒之，慎之。 但无论如何增加知识广度的同时，先扪心自问自己所擅长技术是否全面掌握了。拿我自己来说，也有四年多 iOS 开发经验了，但做的项目都是很普通的那种。这里并不是说普通项目不能提高开发水平，相对于那些业务逻辑复杂的项目，其复杂的关联业务、交互设计会早早的暴露出性能方面的问题，因此，开发者不得不从各方面考虑，最终深入研究这些技术点，并形成最终的优化方案。而普通应用很少遇到性能上的瓶颈，开发者也早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不在积极进取。我管这种开发者叫“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。 这也是很多初级中级 iOS 开发者的共性，没有深入某一具体的方向解决对应的问题，没有自己的技术深度。当我们被全栈开发这种趋势追赶着拼命向前奔命，花费时间、精力学习那些新技术时，需要反思自己有没有达到所擅长领域的技术深度，对掌握的知识，是肤浅还是真正的精通。 互联网发展非常快，每天每个月都有很多的新技术面世。在我们朝着全栈一路狂奔时，需要思考为什么要用这个技术？它能解决什么问题？有什么弊端吗？为了技术而技术，考虑问题的全面性就会差很多。裹足不前不行，盲目追新亦是不行，这里很考验我们对新技术的判断，最终这些技术都要对应业务场景，或许多经历几次因业务需求变化而导致的通宵加班，彻夜上线才会让开发者有所反思，经历几次痛苦的重构才会刻骨铭心吧！ 但无论如何，凌冬将至，大家过冬的粮食都储备充足了吗？ –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"自省","slug":"自省","permalink":"http://XibHe.github.io/tags/自省/"}]},{"title":"利用JenKins持续集成iOS项目时遇到的问题","date":"2017-11-05T16:00:00.000Z","path":"2017/11/06/JenKins-Continuous-Integration/","text":"持续集成(Continuous Integration，简称CI)是一种软件开发实践：许多团队频繁地集成他们的工作，每位成员通常进行日常集成，进而每天会有多种集成。每个集成会由自动的构建（包括测试）来尽可能快地检测错误。许多团队发现这种方法可以显著的减少集成问题并且可以使团队开发更加快捷。 CI是一种开发实践。实践应该包含3个基本模块，一个可以自动构建的过程，自动编译代码，可以自动分发，部署和测试。一个代码仓库，SVN或者Git。最后一个是一个持续集成的服务器。通过持续集成，可以让我们通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。 更新说明更新记录: 2017 年 11 月，第一版。 2018 年 01 月，替换一些图片，增加上传ipa包到FTP。 持续集成的优点 缩减开发周期，快速迭代版本 自动化流水线操作带来的高效 随时可部署 极大程度避免低级错误 持续化集成工具—JenKinsJenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 JenKins的用途: 构建项目自动化打包可以省去开发人员好多时间，重要的是，Jenkins为我们维护了一套高质量可用的代码，而且保证了一个纯净的环境。 可以用来自动化测试，在本地生成大批的测试用例，每天利用服务器不断的跑这些用例。 静态代码分析，可以检测出很多代码的问题，比如潜在的内存泄露的问题。 随时部署，Jenkins在打包完成之后可以设定之后的操作，这个时候往往就是提交app到跑测试用例的系统，或者部署到内测平台生成二维码。 开始安装JenKins方法一: 直接下载安装包 注意：此时有两种安装方式是 标准安装，如下图 自定义安装，此时应该取消Start at boot as “jenkins”勾选，如下图 安装完成后在Terminal中输入, open /Applications/Jenkins/jenkins.war 即可打开Jenkins 方法二: 使用命令行安装安装JenKins， $ brew install jenkins 若brew无效？则需要安装homebrew， $ ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 启动JenKins， $ jenkins 启动JenKins后使用浏览器访问JenKins， 地址为: http://localhost:8080/ 使用安装包安装后会自动打开，如果端口冲突那么请修改端口 defaults write /Library/Preferences/org.jenkins-ci httpPort 7070 强烈推荐使用方法二安装JenKins，使用命令行可以避免后面构建项目时，报一些莫名其妙的权限错误。 安装插件若使用git做源码管理，则需要安装 GIT plugin GitHub plugin 这两个插件，为了方便管理打包证书，需要安装插件 Keychains and Provisioning Profiles Management 由于需要使用Xcode编译环境，因此必须要安装插件 (当然，也可以不安装Xcode integration插件，使用shell脚本命令进行打包) Xcode integration 若最后构建生成的ipa包，需要上传到FTP，则需要安装上传FTP的插件 FTP publisher plugin 我们需要依次选择 系统管理-&gt;管理插件，在“可选插件”中选中“Keychains and Provisioning Profiles Management”和“FTP publisher plugin”这两项，然后安装。如图， 配置构建环境在配置构建环境前，我们先来导入一下打包证书，点击系统管理，找到刚才添加的插件Keychains and Provisioning Profiles Management，点击选取文件，导入名为login.keychain的钥匙串文件。 这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/管理员用户名/.jenkins/workspace/项目目录名称，(.jenkins是隐藏文件)。 如图所示， 其中，Keychains中的Identities输入项，对应的是刚才点击Upload后钥匙串中的测试证书名称，发布证书名称(需要输入证书名称)。 Provisioning Profiles中对应的是刚才上传的证书配置文件。这些配置文件的存放路径为:/Users/管理员用户名/Library/MobileDevice/Provisioning Profiles 这样Adhoc证书和签名文件就在Jenkins中配置好了，接下来我们只需要在项目的构建配置中指定相关文件即可。 注意: 有些升级了最新的Mac OS系统后，/Users/管理员用户名/Library/keychains目录下没有login.keychain文件，有的是一个名为login.keychain-db的文件，这是需要将login.keychain-db文件copy到桌面，修改成文件名为login.keychain。点击”选取文件“，选取并上传这个修改名称后的login.keychain文件。 导入证书后需要在”系统管理“–&gt;”系统设置“里再设置”Xcode Builder“时，访问证书的全局路径。如图， “Keychain path“为钥匙串的本地路径，”Keychain password“为访问钥匙串的密码。设置完成后不要忘记点击”保存“。 新建项目新建 -&gt; 输入项目名称 -&gt; 选择“构建一个自由风格的软件项目” -&gt; 点击ok就行了。 源码管理如图所示， 其中，Repository URL对应的是svn的路径，Credentials为登录svn时的用户账号密码，点击”Add”按钮添加即可。Check-out Strategy最好选择每次update最新代码前都revert下，而不是“Use ‘svn update’ as much as possible” ，因为我使用的是CocoaPods管理的第三方，每次打包运行pod install会修改了工程配置文件，如果下次自动打包前不先revert再update的话会出现冲突。 构建触发器这里是设置自动化测试的地方。涉及的内容很多，暂不做深入研究，这里先不设置，有自动化测试需求的可以好好研究这里的设置。 Poll SCM (poll source code management) 轮询源码管理需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次 Build periodically (定时build)一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。 构建环境勾选“Keychains andProvisioning Profiles Management”和“Mobile Provisioning Profiles”。 这里的Code Signing Identity和Provisioning Profile选项中对应上文Keychains and Provisioning Profiles Management插件中导入的钥匙串文件中的证书及证书的配置文件。当然也可以不勾选Mobile Provisioning Profiles。 构建(构建步骤)点击”增加构建步骤”选项，因为我使用的是CocoaPods管理的第三方，打包前先运行pod install –verbose –no-repo-update安装下第三方库。 注意:执行pod install命令时，需要cd到pod文件所在的目录，${WORKSPACE}是项目在JenKins中的工作目录，而我的项目由于多套了一层目录BusinessMall，因此需要加上这层目录${WORKSPACE}/BusinessMall，否则，在构建时就会报: [!] No `Podfile’ found in the project directory. Build step ‘Execute shell’ marked build as failure 的错误。在执行完pod install后，就可以使用Xcode构建项目打包环境了。 添加构建步骤-&gt; Xcode 在”General build settings“中，点击”Settings“按钮设置相关参数。 Target要与Xcode项目中Target的名字对应 Clean before build设置为YES 勾选”Pack application，build and sign .ipa？“的复选框，会弹出设置生成ipa包的几个参数项。如图， Export method，ipa的类型(‘development’, ‘ad-hoc’, ‘enterprise’ or ‘app-store’) .ipa filename pattern，ipa的名称。 Output directory，输出ipa的文件路径。 注意:这里如果Xcode的版本低于9.0，就可以正常输出ipa包。如果Xcode版本不低于9.0，就会由于Xcode 9.0不在允许你访问钥匙串里的内容，而输出ipa失败。具体的解决方法请参照后面”构建项目时遇到的几个问题“中具体的解决方法。 继续设置”Code signing &amp; OS X keychain options“证书信息，如图， 其中，Development Team ID为开发团队ID,可以在钥匙串中的证书详情里查看。勾选Unlock Keychain，显示为之前上传的login.keychain文件。 如果项目使用了cocoaPods,需要配置Advanced Xcode build options,设置 Xcode Schema File，设为Xcode项目中的schema Xcode Workspace File，这里设置绝对路径，不需要带上.xcworkspace后缀。如果项目中没有workspace后缀，那就在“Xcode Project File”上填.xcodeproj文件的路径。 Build output directory，设为${WORKSPACE}/build/ 注意:Xcode Workspace File为绝对路径，也就是Jenkins用于构建项目的workspace目录中，.xcworkspace文件所在目录的路径。 如果路径不正确，则在构建项目时，会报: open BusinessMall.xcworkspace The file /Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall.xcworkspace does not exist. Build step ‘Execute shell’ marked build as failure 的错误。 构建后操作 添加构建后操作步骤，使用脚本将生成的ipa包上传到fir或者蒲公英等三方平台，扫码下载安装。 参考http://blog.fir.im/jenkins/使用官方工具fir-plugin-1.9.5.hpi插件上传ipa包到fir。 将ipa包上传到FTP服务器 如图，选择“Publish artiffacts to FTP”，其中，FTP site就是在系统管理-&gt;系统设置中，增加的一项名为“FTP repository hosts”的配置里已经设置好的host和端口。Source为构建生成的ipa包的存放路径。 构建项目时遇到的几个问题1. pod: command not found pod install/var/folders/gn/rqsybgtn7f50w67111kj1hhw0000gn/T/hudson3821369083140563198.sh: line 2: pod: command not foundBuild step ‘Execute shell’ marked build as failure 解决方法: 在系统管理–&gt;系统设置，增加”全局属性”，勾选Environment variables，增加键值对列表。如图， 其中，PATH是固定的，值是在终端输入: $echo $PATH 命令获取，将输入命令后得到的值粘贴过来就可以了。 2. ruby_executable_hooks: No such file or directory Pod: env: ruby_executable_hooks: No such file or directoryBuild step ‘Execute shell’ marked build as failure 从jekyll有时也会报这个错误得到启示，可能是由于执行pod命令的路径粗存在问题。在终端使用命令: $ which pod 查看pod的安装路径为: /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod，而执行pod install的shell的环境变量中可能没有该路径。于是使用命令: $ gem env 查看SHELL PATH:，发现列表中没有/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod这条路径。查阅了一些资料(What it is and How to Modify the Shell Path in macOS Sierra and OSX using Terminal)后，发现可以在根目录的.bash_profile中增加永久的路径。在终端输入命令: $ sudo vi ~/.bash_profile 打开根目录下的.bash_profile文件，将路径/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod插入: export PATH:”/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod:$PATH”结束编辑esc后，输入:wq保存。在终端输入命令: $ source ～/.bash_profile 让这个配置文件在修改后立即生效。此时，再查看gem env发现SHELL PATH:列表中，增加了/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod这条路径。 3. `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException) /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/lib/ruby/ site_ruby/2.2.0/rubygems.rb:271:in find_spec_for_exe&#39;: can&#39;t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException) from /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/lib/ ruby/site_ruby/2.2.0/rubygems.rb:299:inactivate_bin_path’ from /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/bin/pod: 23:in &lt;main&gt;&#39; from /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:ineval’ from /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in `‘ Build step ‘Execute shell’ marked build as failure 子所以在构建项目时出现这个错误，是因为看到一篇文章(cocoapods插件GEM_PATH的配置)，说是修改Xcode中CocoaPods插件的GEM_PATH:中的路径与SHELL PATH:中路径一致就能解决: env: ruby_executable_hooks: No such file or directory 这个错误。于是就在~/.bash_profile文件中增加了一条GEM路径 export GEM_PATH=”/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod” 构建项目后就会报上面的错误，仔细看看，觉得是多了一条无效的执行路径导致的。于是，就删除了那条新添的GEM_PATH，再次构建就不报这个错误了。 4. in `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) in `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) 更新一下gem版本，终端命令如下； $ sudo gem update –system 有时在输入命令后会出现ssh相关的网络错误提示，可以在终端输入命令: gem sources -a http://gems.ruby-china.org/ 将源地址换为ruby-china。 5. 报xcodebuild: error: The workspace ‘Project’ does not contain a scheme named ‘Project’.的错误 Going to invoke xcodebuild:, scheme: Project, sdk: DEFAULT, workspace: Project, configuration: Debug, clean: YES, archive:NO, symRoot: DEFAULT, configurationBuildDir: /Users/ignat/.jenkins/workspace/Project/build, codeSignIdentity: DEFAULT[Project] $ /usr/bin/xcodebuild -scheme Project -workspace Project.xcworkspace -configuration Debug clean build CONFIGURATION_BUILD_DIR=/Users/ignat/.jenkins/workspace/Project/buildBuild settings from command line: CONFIGURATION_BUILD_DIR = /Users/ignat/.jenkins/workspace/Project/build xcodebuild: error: The workspace ‘Project’ does not contain a scheme named ‘Project’.FATAL: Build directory does not exist at /Users/ignat/.jenkins/workspace/Project/build. Potential configuration issue.Build step ‘Xcode’ marked build as failureFinished: FAILURE 在Xcode中，选择Manage Scheme，勾选对应的Shared。 6. 构建时报 NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list. Error Domain=IDEProvisioningErrorDomain Code=9 “”BusinessMall.app” requires a provisioning profile with the Push Notifications feature.” UserInfo={NSLocalizedDescription=”BusinessMall.app” requires a provisioning profile with the Push Notifications feature., NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list.} EXPORT FAILED 最后错误提示，EXPORT FAILED，可知是导出ipa包时出的错。根据提示”provisioningProfiles” dictionary in your Export Options property list.在网上搜了一下这个plist文件的用处，发现原来新版的Xcode 9将不会允许你访问钥匙串里的内容，除非设置allowProvisioningUpdates。 具体的解决方式是: 自己动手写脚本替代插件（插件本质是帮助我们生成打包脚本代码）。于是，在JenKins里，点击项目的”配置“选项，在”构建“中，添加xcodebuild -archivePath，xcodebuild -exportArchive -archivePath的脚本命令，输出ipa包。如图， 具体的脚本命令如下: xcodebuild -archivePath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/output/debug/BusinessMall.xcarchive&quot; -workspace BusinessMall.xcworkspace -sdk iphoneos -scheme &quot;BusinessMall&quot; -configuration &quot;Release&quot; archive xcodebuild -exportArchive -archivePath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/output/debug/BusinessMall.xcarchive&quot; -exportPath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/ipa/debug/&quot; -exportOptionsPlist &#39;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/ipa/debug/ExportOptions.plist&#39; -allowProvisioningUpdates 脚本中的构建路径为JenKins下对应的archivePath，ipa包的输出路径。其中，需要特别注意的是ExportOptions.plist的存放路径。手写ExportOptions.plist文件过于麻烦，不如让XCode帮我们生成。使用XCode 9打包并导出后的文件夹里就有这样一份文件可以直接拿过来用。修改后的plist文件，如图， 之后就在项目所在的目录下，新建一个名为ipa/debug/的目录，将修改后的ExportOptions.plist文件放在这个目录下。在Jenkins中使用SVN管理源码，因此，我需要将这个新增的文件上传SVN，这样在我每次构建项目，输出ipa时就能直接从SVN上拉取这个plist文件，通过设置ExportOptions.plist’ -allowProvisioningUpdates就能访问钥匙串中的打包证书，输出ipa包了。 注意:设置了allowProvisioningUpdates字段后，在打包过程中会弹出是否允许访问钥匙串内容的弹窗，这时需要多次点击“始终允许”按钮。 7. 构建时报error: exportArchive: The data couldn’t be read because it isn’t in the correct format. error: exportArchive: The data couldn’t be read because it isn’t in the correct format. EXPORT FAILED 关掉bitcode重新打包就可以了…… 参考https://forums.developer.apple.com/thread/21193 写在最后中间使用过命令: sudo gem install -n /usr/local/bin cocoapods –pre 重装过CocoaPods，目前CocoaPods的版本为: 1.4.0.beta.2。也可以输入命令: $ sudo gem install cocoapods -v 0.39.0 安装特定版本的CocoaPods。 由于给iOS项目构建版本时必须依赖于xcodebuild环境。现在是在一台Windows上部署Jenkins环境，可以配置节点，在另一台Mac电脑上打包。具体操作，可以参考这篇文章—Jenkins自动打包 配置mac slave节点 参考资料w3cschool Jenkins How to solve “/usr/bin/env: ruby_executable_hooks: No such file or directory”? /usr/local/bin/pod No such file or directory How to delete a gem path? What it is and How to Modify the Shell Path in macOS Sierra and OSX using Terminal 手把手教你利用Jenkins持续集成iOS项目 cocoapods插件GEM_PATH的配置 cocoaPods安装2017 以及遇到的坑 Xcodebuild fails in jenkins with cocoapods xcodebuild commands give different results when run from the command line than when run from within Jenkins Jenkins自动打包 配置mac slave节点 Jenkins+XCode9自动打包错误处理 xcode 9 beta export options not working #9589 Xcode 7 Enterprise Distribution not working –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"持续化集成","slug":"持续化集成","permalink":"http://XibHe.github.io/tags/持续化集成/"},{"name":"JenKins","slug":"JenKins","permalink":"http://XibHe.github.io/tags/JenKins/"}]},{"title":"直播那些事","date":"2017-10-30T16:00:00.000Z","path":"2017/10/31/live/","text":"直播技术经过近两年的迅速发展，已经很成熟了。从十月份开始接触与直播相关的技术，中间花了一周左右的时间，对市面上几种流行的三方直播SDK做了调研和对比。今天是月末最后一天，就做一个阶段性的总结吧！ 更新说明更新记录: 2017 年 10 月，第一版。 2017 年 11 月 11 日，增加相关说明。 2017 年 11 月 13 日，增加直播原理。 直播原理1. 一个完整直播app实现流程1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动 2. 一个完整直播app架构 3. 一个完整直播app技术点 4. 流媒体相关参数帧: 每帧代表一副静止的图像。 帧率: 每秒显示的图片数。影响画面流畅度，与画面流畅度成正比:帧率越大，画面越流畅；帧率越小，画面越有跳动感。 由于人类眼睛的特殊生理结构，如果所看画面之帧率高于16的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。 码率：图片进行压缩后每秒显示的数据量。 分辨率：（矩形）图片的长度和宽度，即图片的尺寸压缩前的每秒数据量: 帧率X分辨率(单位应该是若干个字节)压缩比: 压缩前的每秒数据量/码率 （对于同一个视频源并采用同一种视频编码算法，则：压缩比越高，画面质量越差。） 视频文件格式：文件的后缀，比如.wmv,.mov,.mp4,.mp3,.avi,主要用处，根据文件格式，系统会自动判断用什么软件打开,注意: 随意修改文件格式，对文件的本身不会造成太大的影响，比如把avi改成mp4,文件还是avi. 视频封装格式：一种储存视频信息的容器，流式封装可以有TS、FLV等，索引式的封装有MP4,MOV,AVI等，主要作用：一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、封装起来.注意：会发现封装格式跟文件格式一样，因为一般视频文件格式的后缀名即采用相应的视频封装格式的名称,所以视频文件格式就是视频封装格式。 视频封装格式和视频压缩编码标准：就好像项目工程和编程语言，封装格式就是一个项目的工程，视频编码方式就是编程语言，一个项目工程可以用不同语言开发。 对比几种不同的直播SDK对比市面上常用的直播平台，这里分别是：阿里云、zego、七牛云、腾讯云。这里根据业务需求，对比以上四个平台的指标为：支持的最大连麦上限，是否提供实时视频通话的解决方案，是否提供聊天室功能(IM)，可拓展性等。 阿里云直播阿里云直播中有提供连麦功能，但连麦上限最终确认4人（不能添加上限），不符合公司功能需求。视同阿里云提供的连麦demo，如图， 超过三个连麦观众时会提示：连麦观众不能超过3个。 在阿里云提交工单后，得到了最终的反馈，如图， 最后，联系了技术支持，连麦上限最终为4人。 zego直播zego直播中提供实时视频通话、连麦互动直播和即时通讯功能，实时视频场景的典型使用案例是同一房间内的成员（如微信群视屏），进行实时视频对话同一房间中的用户均可发起视频通话。连麦功能支持20个连麦观众。 提供了实时视频通话的解决方案，如图 七牛云直播七牛云提供强大的直播以及连麦服务，有提供强大的连麦功能，且无上限，受限于客户端的总体带宽，建议8路以下。 腾讯云直播腾讯云分为直播、互动直播、移动直播多种视频服务， 互动直播(ILVB)多对多连麦，最多支持8人同时连麦。移动直播(MLVB)提供即时通讯等一体化直播的解决方案，但最多同时支持3人连麦(见工单)。这二者都是在直播(LVB)基础之上做的延伸拓展。 最后，对比以上四种直播，单从技术上考虑，zego以其一体化的解决方案，超出20路的连麦数，做工精良并频繁更新的Demo被重点考虑。从价格上考虑，阿里云和腾讯云的价格比较有优势。最后暂时选择了阿里云，原因可能是公司的云服务器用的是阿里云吧！ 关于demo该demo为整理后的阿里云直播连麦demo，添加了一些注释，为了突出直播所需的主功能，demo只集成直播所需的基本的API。通过对demo添加Tag，区别不同的功能。其中，Tag为V0.1的版本集成最基本的直播推拉流功能，Tag为V0.2的版本集成连麦功能。点击下载链接 注意:阿里云的连麦demo中并未集成聊天室功能，在引入的SDK中，有一个名为AlivcLiveChatRoom.framework。该SDK暴露的AlivcLiveClient.h文件中，注明了聊天室相关的API，但创建聊天室和发送聊天消息的方法都加了__deprecated_msg的注释： - (void)createChatRoomWithName:(NSString *)chatRoomName success:(void(^)())successBlock error:(void (^)(NSError *error))errorBlock __deprecated_msg(&quot;暂未开放,请勿使用,参考Demo与appServer交互&quot;); - (AlivcLiveChatMessage *)sendMessage:(AlivcLiveConversationType)conversationType content:(NSString *)content success:(void (^)(long messageId))successBlock error:(void (^)(NSError *error, long messageId))errorBlock __deprecated_msg(&quot;暂未开放,请勿使用,参考Demo与appServer交互&quot;); 在阿里云提交工单，工程师回复目前阿里云直播SDK不再提供聊天室功能了。不过通过阿里云DEMO接口文档中所列出的错误码，其中，有返回2040，2050的错误码， 2040 创建环信聊天室失败 2050 消息发送到环信失败 可见，阿里云聊天室之前是环信即时通讯方案，只是现在移除了。接口详情见: DEMO接口文档 写在最后这篇关于直播的文章写得很粗浅，只是记录了阿里云直播SDK的使用。没有详细系统的描述直播原理、主要直播技术及其实现。下面几篇文章对直播做了系统的介绍: 如何开发出一款仿映客直播APP项目实践篇 -【服务器搭建+推流】 如何开发出一款仿映客直播APP项目实践篇 -【原理篇】 如何开发出一款仿映客直播APP项目实践篇 -【采集篇 】 如何开发出一款仿映客直播APP项目实践篇 -【播放篇】 参考资料【如何快速的开发一个完整的iOS直播app】(原理篇)","tags":[{"name":"直播","slug":"直播","permalink":"http://XibHe.github.io/tags/直播/"}]},{"title":"(译)为何许多开发者仍然喜欢用Objective-C，而不是Swift","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/SwiftUsageRate/","text":"iOS SDK已经发布很多年了，开发人员纷纷涌向Objective-C，他们力图通过开发会大卖应用程序而获得丰厚的回报。但那样的时代如今已不复存在了：Swift已经面世三年多了，与Objective-C相比，大大地获取了大家的关注度。 Objective-C - 从应用程序开发世界冉冉升起的明星 - 沦为苹果生态系统中的二等公民。即使OC仍然会在WWDC的一两个板块中被提及，但世界各地的大部分会议都在谈论Swift，苹果正努力推动Swift在教育领域的应用，使用Swift作为主要的语言。 但是如果你仍然在使用Objective-C，你并不孤单 - 许多开发者仍然喜欢使用Objective-C相对于Swift，并且有很好的理由。我与一些Objective-C开发者联系，询问他们是否感觉继续使用Objective-C开发会受到指责，下面的内容就是他们不得不说的… 注意：这里表达的意见是个人意见，可能不代表雇主的意见; 人们按照他们回应的顺序列出; 一些回答在长度上进行了变更。 阻止你将Swift作为开发语言的主要原因是什么？史蒂夫·特劳顿 - 史密斯：我有几个原因避免了Swift。 首先，我不喜欢使用它 - 我发现这个语言比ObjC更难阅读和解析，尤其是在循环和switch语句中的if-let变量赋值（这在Apple的体例中是混乱的，像ARKit一样)。我不是尝试各种不同语言为各种平台编写东西的新手，而且Swift绝对是我见到的可读性很低的语言。 我还不相信苹果参与设计这个语言的初衷 - 四年之后，Swift并不用于iOS，OS或框架的重要部分（我在Twitter上保留了苹果公司的Swift应用程序，macOS很少采用它的新特性相对于iOS来说)。我明白为什么会这样（ABI的稳定性等），但如果苹果没有使用Swift，我不明白为什么我需要代表他们进行beta测试。在Swift准备好之前，我没有什么期待，而且在此期间我获得了Objective-C所带来的一切好处。 我完全相信，只是因为苹果建立了一些东西，并说这是前进的道路并不意味着它是正确的选择。 有趣的是，在最初的几年中，我曾经听说过苹果与Swift的任何人分开，苹果公司当然是大量的ObjC开发人员，而Swift对于许多人来说，对我们来说是一个惊喜。 而且我完全相信，只是因为苹果建立了一些东西，并表示这是前进的道路并不意味着它是正确的选择 - 我们已经看到了一大堆错误（DNS 解析服务 discoveryd，iOS 7，iOS 8）或’mehs ‘（macOS，Touch Bar）在过去几年里，而且看到如何摆脱这些不好因素带来的负面影响。 迈克尔·劳尔：我看不到激励。我在Objective-C方面非常有成效，我将语言视为非常优雅，简洁，富有表现力。如果Swift有一流的（异步）并发，我会高兴的跳起来。相比之下，我听说缓慢的编译时间，大量的运行时库重复，我还没有看到运行时性能的显着提升。 丹·莱弗斯：对于技术原型预演Demo或非常小的项目，我将使用Objective-C，纯粹为了在经过相当长的时间（通常可能与这些类型的客户端）之后的易于更新。我还为许多客户保留了Objective-C应用程序，而且没有时间（或将其切换到Swift的理由）。在Swift中构建这样的项目的代码通常会把它当做演示原型的Demo来简单使用。 彼得·莫尔纳尔：在3.0版本之前，我的主要障碍是缺少源代码兼容性，即使4.0之后，我还在等待ABI的稳定性。我认为这是剩下的唯一一个问题，如果源兼容性有效，我个人觉得这对我来说很重要。 托德·托马斯：Xcode对Swift的支持似乎很好笑。从大型项目的愚蠢长编译时间到重构和调试。Tweetbot for Mac是一个相当可观的项目，在2012款的Retina MBP上编译它需要44秒。这包括1个框架，1个库和应用程序本身。此外，Swift的ABI仍然不稳定 - 当我不需要使用我的应用程序包含的所有库被全部缓慢的构建为应用时。 伊恩·麦克道尔：我们有一大堆共享的C++代码，用于我们的业务逻辑，它与Windows和Android共享。我们在Objective-C中的本地UIKit/AppKit中编写我们的UI，并且有很多Objective-C++文件在两种语言之间桥接。至今，除了几个脚本和内部工具之外，我们还没有采用Swift。据使用Swift的其他团队说，编译时间比Objective-C / C ++慢。 我们有数百个Xcode项目，最终编译成一个巨大的静态库，链接到每个应用程序二进制文件。这样做可以减少应用启动时间。我们花费大概6小时流畅的构建我们的应用，不会增加很多时间。 西蒙·沃尔夫：我的主要编码项目是一个客户端，它是一个已经发展了几年的大型代码库。虽然我也会引入一些Swift进去，因为我做的很多工作涉及到编辑现有的代码，它阻止我使用太多Swift。 我也意识到作为一个开发者，每次有一个新的主要版本的Swift的更新，我都会将那些工作中可以用到拿来用，但这不是我真正需要的。 马科·阿门特：对我来说，这不是对Swift本身的判断，而是一个务实的决定：我已经是Objective-C的专家，在使用它方面极富生产力，而切换到Swift的好处并不足以说服我。 马塞尔·维赫尔：我最多的工作包括一些复杂的元编程和 C 进行部分混合的objective - C的动态消息部分。在使用Swift后所有的这些都会变得更加困难，例如，你无法在Swift中编写CoreData。还很纠结：我只是试图找到一些用Swift编写的Apple Pencil示例代码。结果浪费了我一天时间。 你有没有觉得开发人员可能会对使用Objective-C或者在社交媒体上谈论鄙视？史蒂夫·特劳顿 - 史密斯：真的吗？使用ObjC非常不受欢迎，或者说你喜欢ObjC 胜过 Swift。Swift有一个真正大规模的炒作人群，这个是你无法阻止的。 像任何充满激情的球迷一样，没有任何理由参与讨论。 Swift用户与我一样（或更多）了解其缺点，但是由于感知到的好处，他们很乐意做出妥协。我不是，也不觉得同样的好处。 迈克尔·劳尔： 实际上。我觉得我一直在为自己对Objective-C的认同而保卫自己不受外界的干扰。 我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。 丹·莱弗斯：当然，有一个新的和有光泽的驱动器。这最终有多少的iOS社区呢，所以它不是完全不足为奇，仍然存在很多争议。我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。 彼得·莫尔纳尔：当我正在阅读职位和职位描述时，这种感觉更多，不一定在社交媒体上。大家现在正在寻找高级Swift开发人员。 托德·托马斯：我并没有太多的担心。这个应该让应用程序自己来决定。如果它是好的，用户不会在乎它是用什么语言编写的。 伊恩·麦克道尔：对于仍然使用Objective-C，我感觉到一些耻辱，但并不多。 我使用Swift为我的个人项目，并爱上它，并理解我们在工作中不使用它的原因。 西蒙·沃尔夫：有一点，因为我不相信Swift是坏的，Objective-C是一个真正的Cocoa语言，我不会避免对Swift的利弊的热烈争论。我也没有看到人们对Objective-C开发人员太粗鲁，但作为Mac开发人员，我倾向于处于iOS社区的边缘，这可能是大多数冲突的地方。我不认为Mac开发人员很乐意使用最新最好的。我们还在争为NSCell争论(NSTableView中的NSCel)。 马科·阿门特：这已经开始了，但是每个过渡都是这样发生的。Objective-C开发人员为Carbon开发人员开辟了乐趣。这只是一个自然的发展历程，每当你的语言不在当前考虑范围内的，只要你的语言不被视为“进步语言”。但是你仍然以务实的原因使用它。作为网络上的PHP开发人员，我习惯了这一点。 当你看到开发者会议上大多数时间都在讨论Swift的使用时，你的感受是什么？史蒂夫·特劳顿 - 史密斯：毫无感觉，一个只有Swift的会议是对我没有任何影响。在语言还未完善之前，以及苹果尚未大规模使用之前，我并不关心Swift最佳做法或设计模式。我不想整理十几个社区主导的设计模式，我等待苹果对于Swift的进一步完善。 一个只有Swift的会议是对我没有任何影响。 知道Swift是苹果发展的一个真正的“未来”，已经做了很多工作来推动我彻底远离应用程序; iOS 7 UI与Swift一对一转换的冲击让我觉得这不是我想要开发的平台。 迈克尔·劳尔：这是可悲的。当然，我可以翻译我看到的一切，但比以前付出了更多的努力。而且我拒绝在任何要求使用Swift例子的会议上谈论它。幸运的是，还可以参加一些除了Swift之外的会议。 丹·莱弗斯：至少他们大都一致！ 彼得·莫尔纳尔：我认为这是演变的一部分，但它是真实的 - 在Objective-C周围没有太多的吸引力。Swift是新的，由于它不断变化，有很多话要说，显然这些新的话题也在快速过时。 托德·托马斯：我想如果你想要向前看，开发者会议应该谈论Swift。我不介意个人使用Swift，但也不要过度重视会议上对Swift的讨论。 伊恩·麦克道尔：我感觉很好，这是未来！ 西蒙·沃尔夫：我不介意，我意识到Swift是新的闪亮的东西，因为我知道Swift足够好了解它，真的不用担心我。如果我把我的头埋在沙滩上，而不是继续学习Swift，那么我可能会被遗忘，然而我不认为这种做法有利于成为一个好的开发者。 马尔科·阿门特：它不打扰我。大多数会议组织者和与会者都比我做得更紧密，所以当然应该使用Swift。将Swift代码片段从会议，教程和StackOverflow转换为Objective-C，只是继续使用Objective-C的成本之一，迄今尚未证明特别繁重的。 但随着时间的推移，这种转换负担会增加。 马塞尔·维赫尔：我不得不承认，我发现很多Swift的讨论非常肤浅，经常因为不知情而被嘲笑，所以我感到失望。我知道这听起来很苛刻，而且有明显的例外，然而很仍然感到吃惊。 你认为Swift的引入有助于或阻碍Objective-C作为一种语言的发展吗？史蒂夫·特劳顿 - 史密斯：Swift对于Objective-C开发绝对是灾难性的; 对于任何新的API或功能，我不再具有示例代码，WWDC幻灯片，教程，GitHub或StackOverflow。无论StackOverflow千禧年的笑话，但是失去了对所有这些上下文和知识的访问是毁灭性的。在这方面，ObjC语言本身已经获得了一堆生活质量/语法糖功能，以帮助它更好地与Swift进行交互，所有这些都是梦幻般的。 对于Objective-C开发，Swift绝对是灾难性的。 我非常厌恶为了让Swift存活而使ObjC死去 - 如果两种语言可以彼此独立存在，对于像我这样的开发人员来说是非常好的，他们可以选择最适合手头任务的语言。Swift背后的激情，大规模的推广宣传，苹果停止为开发人员创建ObjC资源。 迈克尔·劳尔：使用Swift的主要好处，“我们”要感谢轻量级泛型和可空性，但这是关于它的。如果背后有相同的人力投入，我只会希望Objective-C能获得Swift这样的好处。 丹·莱弗斯：我认为这最初是有帮助的，但我现在强烈感觉到，这样的做法有些舍本逐末了。 托德·托马斯：我认为这有帮助。他们为Swift的语言添加了许多有用的东西，所以我们不能抱怨。 伊恩·麦克道尔：Objective-C已经从Swift获得了一些很好的功能，包括@available语法和可空性说明符。这是一种稳定的语言，我没有想到它会改变任何事情。 在Swift中打包可能是一个痛苦，但它帮助我在Objective-C中采用更好的打包方式。 西蒙·沃尔夫：对于Swift导致的结果，Objective-C有一些变化和改进，这是有帮助的。另外，写一点Swift也鼓励我去看看我的Objective-C代码是否完美，而且我不太愿意让空对象去操作底层的一些东西。在Swift中打包可能是一个痛苦，但它帮助我在Objective-C中采用更好的打包方式。 马尔科·阿门特：Swift已经有效地停止了Objective-C作为一种语言的开发。 这并不奇怪或不合理，但幸运的是Objective-C相当成熟。前几年Swift的引入带来了许多改进，应该保持Objective-C可用，直到我们大部分人都转移到Swift。 马塞尔·维赫尔：显然受到阻碍，即使Objective-C很好，但Swift的出现结束了Objective-C进一步的发展！ 更令人惊奇和不安的是，一些首选Swift作为语言编写的三方库中有很多明显的缺陷。一些对Swift的改进被阻止，以使Swift看起来不错，虽然我很确定这不是怎么回事。 然而，最大的负面影响就是那些可能阻止Swift后续发展的一系列做法。我们正在尽我们所能创造一种脱离控制的Swift，而苹果忽略了所有这一切。这是一个犯罪。 你怎么看？除了上述所有问题，我还问到人们使用Objective-C已经有多长时间了，因为我认为公平地说，在精通一门语言后，选择继续使用或这彻底放弃时总是很重要。 听到大多数人说他们在iPhone SDK第一次启用或不久之后立即使用Objective-C，几个人已经使用了十多年，其中一个人27了——是的,27岁。我应该补充说，一位回应者表示他们最近开始使用Objective-C，所以也许还存在一些固执的人。 另外还有一件事：去年，我写了一本名为Objective-C for Swift Developers的书，在介绍中，我介绍了一个题为“我喜欢Objective-C”的部分，这里是我写的一些话： 当我阅读本书的第一本完整的草稿时，我想到了自己，“哇，这看起来像是Snark的Objective-C指南”，因为几乎每一章都觉得是在抱怨。 结果，我花了一些时间来编辑这本书，让它更加完美 - 不是因为我试图用人造光线向你呈现东西，而是因为我真的很喜欢用Objective-C编码。在Apple发布Swift时，我就开始使用Swift了，并且在早期就发布了一款Swift应用程序到App Store上。因此，在许多方面，和Swift相比Objective-C只是看起来很糟糕，我已经使用Swift很长时间了，再次使用Objective-C感觉有点像从长期生活的大城市回到老家过圣诞节一样。 我不知道我是否喜欢Objective-C，因为我有斯德哥尔摩综合症，或者是因为苹果的API是如此强大。无论如何，我认为重要的是你意识到，一些令人惊奇的软件已经与Objective-C一起构建，许多人始终如一的爱着她。 当你在这本书中发现让你感到沮丧的事情时，你要温柔一点：这是一种古老的语言，经历了坎坷的发展历程。它为我们提供了很好的服务。至少，在它慢慢远离人们视线时应该被尊重! 谢谢Steve 史蒂夫·特劳顿 - 史密斯，迈克尔·劳尔，丹·莱弗斯，彼得·莫尔纳尔，托德·托马斯，伊恩·麦克道尔，西蒙·沃尔夫，马尔科·阿门特，以及马塞尔·维赫尔，花时间对这篇文章发表观点。 现在结束了 - 如果你仍然喜欢在Swift上使用Objective-C，可以在Twitter上联系我！ 原文地址Why many developers still prefer Objective-C to Swift –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"Swift","slug":"Swift","permalink":"http://XibHe.github.io/tags/Swift/"}]},{"title":"小程序开发总结","date":"2017-09-24T16:00:00.000Z","path":"2017/09/25/wx-mini-AppSummary/","text":"小程序开发结束已经两天了，这是第一个我参与的小程序项目。回顾开发过程中踩过的种种坑，剖析项目中的痛点，需要优化的地方。以后如何避免这样的问题？是否从此入坑H5了？自己的知识短板是什么？ 之前一直从事iOS开发，对web前端没有过多了解。单凭一腔热血去开发小程序，初识比较迷茫，纠结于html和css的样式，js的数据交互等基础知识。但项目周期短，任务重，需要与pc，平板进行数据同步。就没有太多时间去理会前端基础知识，都是现学现用。 就是产品有些坑，设计的小程序产品原型还是是基于原生App的思维。因此，设计出的UI效果图，页面数据展示效果多数是原生App的效果，有些设计甚至与小程序组件相悖。为了实现与UI设计一致的效果，就需要花费很多时间自定义数据交互组件。 开发时没有完全吃透小程序开发文档，在实现某个功能时一直拿不定主意。以下是踩过的一些坑: 小程序页面路径只能是五层，请尽量避免多层级的交互方式。 页面之间传递数据和变量的方式需要统一，不统一传参方式，一旦出现数据展示问题，会增加调试的难度。 一定要将多次调用的功能或样式封装起来，否则，重复相同功能代码会增加.js文件的代码量，使代码不易读。 使用swiper滑块视图容器时，一定要将滑块控制的页面抽离成单独的页面，放在一个页面中，当处理不同页面的数据交互时，会对其他不相干的页面数据造成干扰。 读取页面定义的变量时，不要忘记使用that关键字，把this对象复制到临时变量that，否则会找不到原来的对象。 wx.showToast吐司，当title文字超出限制，不会自适应宽高，需要自定义弹出框。 注意navigator 组件的几种跳转方式的不同之处。 小程序变量不支持下划线命名，若使用下划线命名会造成变量无法赋值。 避免快速点击，多次触发bindtap事件，造成打开多个相同页面。 小程序写着还是很纠结的，这是内心的真实想法。 通过这次开发小程序的机会，发现了自己的知识短板，正是这些短板让自己裹足不前。以下是短板高发区: 在哪些工作上花费时间最多? 可以改进的重复性劳动 自己没有完全理解的东西 你回答不出来的面试题 对比以上几点快速找出你的技术短板，然后消除它。你必须要确切知道自己需要学什么，保证焦点正确。不要让这些短板成为你的“痛点”。 我是否陷入了对技术的狂热之中？因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。 人生多艰，无暇他顾。 于是我局限在自己的世界中，变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"总结","slug":"总结","permalink":"http://XibHe.github.io/tags/总结/"}]},{"title":"小程序页面跳转","date":"2017-09-15T16:00:00.000Z","path":"2017/09/16/wx.navigateTo/","text":"微信小程序页面跳转API时需要注意，官方文档中强调：“为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。” 也就是说在连续使用navigateTo进行页面跳转时，若当前页面若正好是第5级，则点击该页面任何绑定触发事件的控件，都不会有任何反应。 更新说明更新记录: 2017 年 9 月，第一版。 2017 年 10 月，增加页面跳转流程图及跳转说明。 小程序中页面导航的API为了避免发生超过五级页面而无法跳转的悲剧，首先要了解清楚小程序中页面导航的API。小程序中页面导航API有五个，两个跳转新页面的API分别为wx.navigateTo和wx.redirectTo，一个用来做重置操作的API为wx.reLaunch，一个用于跳转到tabBar的API为wx.switchTab，还有一个API名为wx.navigateBack，用于返回页面。 wx.navigateBack 在小程序的初始版本中只能回到上一个页面，在最新版本的更新中给 navigateBack 添加了一个参数 delta，用于决定需要返回几层页面，返回的页面数，如果delta大于现有页面数，则返回首页。 几种跳转方式的不同之处navigator 组件的默认跳转方式与 wx.navigateTo 相同，而如果添加 redirect 属性，则与 wx.redirectTo 的跳转方式相同。 navigateTo 在官方文档中描述如下： 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面。 通过 navigateTo 跳转后，可点击左上角的按钮返回上一个页面。而如果多次调用 navigateTo 之后，就需要返回多次才能回到初始页面。因此，官方在此处有一个限制。 注意：为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。 不过上述五层的限制只是针对 navigateTo，redirectTo 则无此限制。因为 redirectTo 的行为是： 关闭当前页面，跳转到应用内的某个页面。 注意: 使用redirectTo跳转到一个之前加载过的页面，不会再次调用该页面的onLoad方法。 通过 redirectTo 跳转后，则无法返回跳转前的页面。但并不是无法调用 navigateBack，而是调用之后，会回到使用 redirectTo 跳转前的上一个页面。 页面栈可以通过 getCurrentPages 方法获取： getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。 上述的「页面路径」可以对应为页面栈中的元素，页面栈中的最后一个元素就是当前显示的页面，页面跳转就是新页面入栈的过程。 上述三种页面 API 的区别在于： navigateTo 不会将旧页面出栈； redirectTo 会将旧页面出栈，再将需要跳转到的页面入栈； navigateBack 则是将页面栈最后一个元素出栈，因此倒数第二个元素会成为最后一个元素，即变成「当前页面」。 结合下面这个例子，如图， 小程序包含 A、B、C、D 四个页面，A 页面为首页。小程序启动后，在 A 页面中，我们通过 navigateTo 跳转到 B 页面，然后在 B 页面中再通过 navigateTo 跳转到 C 页面。 如果通过navigateTo跳转到 D 页面，则在D页面调用navigateBack会返回到C页面；如果通过redirectTo跳转到 D 页面，则在D页面调用navigateBack会发现不是返回C 页面，而是返回到了 B 页面。 因为调用redirectTo 跳转到 D 页面，redirectTo 会将当前页面出栈，即将 C 页面出栈，再将 D 页面入栈，这时候，页面栈中的元素则会变为 A、B、D。 navigateTo 不会将旧页面出栈，因此通过 navigateTo 跳转后，页面栈中元素个数会加一，因此在页面栈中元素个数达到 5 之后再调用 navigateTo 会失败，出现无法跳转的错误。 redirectTo 会在将旧页面出栈后，再将新页面入栈，因此通过 redirectTo 跳转，页面栈中元素个数会保持不变，所以即使在页面栈中元素达到 5 个之后再调用 redirectTo 也能成功跳转。 实际业务流程业务流程:点击主页面的“扫码录入”按钮，页面跳转微信扫一扫页面，通过扫描条形码读取商品信息，若扫码到该商品信息存在数据库中，则获取数据库中的信息并将这些商品信息带至至“商品信息”页面，可以在商品信息页面对商品信息进行编辑。编辑结束后，点击商品信息页面底部的保存按钮，保存该条商品的最新信息。 为了在点击页面底部的“保存”按钮后直接跳转至微信扫一扫页面，达到快速扫码录入商品信息的目的。解决方案: 直接返回主界面，点击“扫码录入”按钮，跳转至微信扫一扫页面； 点击底部“保存”按钮后，立即调用wx.scanCode打开扫一扫页面； 方案1直接被否定了，原因是用户会频繁调用扫一扫进行商品信息的录入。如果在用户录入一天商品信息后，返回到主页面，再一次点击“扫码录入”按钮跳转至扫一扫页面进行商品录入或查询。会使得录入这一操作的连续性被打断，降低录入操作整体流畅度。 方案2在点击保存按钮后直接打开扫一扫固然可以保证操作的连贯性，但此时若在扫一扫页面不做扫码操作，而是点击扫一扫左上角的返回按钮，则返回到上个页面—商品信息保存页面。此时，如果点击“保存”按钮会对商品信息进行重复保存。 那么，能否在微信扫一扫页面做相应处理呢？比如，点击扫一扫左上角的返回按钮时，直接返回到首页。由于扫一扫页面是直接调用wx.scanCode而来的，其并不是以压栈的方式出现在页面控制的层级中。因此，无法通过getCurrentPages()函数获取对应的层级关系。 另外一种方式，针对方案2的问题，需要在点击“商品信息”页的“保存”按钮后做出特别处理，于是在点击保存绑定的事件中设置: saveTap: function (res) { wx.request({ url: requestUrl.LookForGoodsUrl data: { &quot;userId&quot;: userId, &quot;goodsId&quot;: numResult, &quot;name&quot;: name, &quot;factory&quot;: factory, }, header: { &#39;content-type&#39;: &#39;application/json&#39; }, success: function (res) { if (res.data.code == &#39;0000&#39;) { // 保存成功 wx.redirectTo({ url: &#39;../homePage/homePage&#39; }) } } }) } 将最新商品信息上传至服务器，关闭当前页面，跳转到应用内的某个页面。再调用: wx.scanCode({ var numResult = res.result; if (numResult.substring(0, 2) == &#39;69&#39;) { wx.request({ url: requestUrl.LookForGoodsUrl data: { &quot;userId&quot;: userId, &quot;goodsId&quot;: numResult, }, header: { &#39;content-type&#39;: &#39;application/json&#39; }, success: function (res) { if (res.data.state == &#39;1&#39;) { // 存在该商品 wx.redirectTo({ url: &#39;../goodsInfo/goodsInfo?goodsChart=&#39; + goodsChart + &#39;&amp;goodsId=&#39; + goodsId, }) } } }) } }) 调用扫一扫，获取商品条码，将获取的条码作为参数上传服务器得到服务器返回的商品信息。再将这些信息传递并跳转至“商品信息”页，展示这些信息。再次扫描商品条码时，重复以上操作。 但是为了在商品信息页面点击“保存”按钮时关闭当前页面，使用了wx.redirectTo，会先返回到首页（homePage），然后再调出扫一扫页面。这期间会出现短暂（大概2~3秒钟）的停顿，停顿期间页面(homePage)仍然可以操作，会误触页面上的其他点击事件。最后，即使在该页面(homePage)加上loading，以防止误触。仍然无法回避短暂停顿后再跳转扫一扫页面的问题。 最后的解决方案是: 点击商品信息页的“保存”按钮后，将该按钮隐藏。这样当从扫一扫页面返回商品信息页时就不会出现重复保存数据的问题了。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"wx.navigateTo","slug":"wx-navigateTo","permalink":"http://XibHe.github.io/tags/wx-navigateTo/"}]},{"title":"爱之初体验 - 小程序","date":"2017-08-31T16:00:00.000Z","path":"2017/09/01/wx-mini-AppBlindDate/","text":"开发小程序已经有两周了，从最开始踌躇满志到现在喜忧参半。这中间经历了许多波折，好像又回到了第一次初恋时的感觉，迫切，含蓄，喜悦，又苦于不能迅速了解对方的方方面面，而感到沮丧。但随着一步步的接触，由浅入深，终会瓜熟蒂落，水到渠成。 框架小程序由视图层，逻辑层，渲染层三部分组成的一整套框架。框架使用自己的视图层描述语言WXML(.WXML文件中使用的是view标签构建视图，相当于CSS中的div标签。)和WXSS，逻辑层是基于JavaScript框架。视图层和逻辑层间微信提供了用于数据交互，事件绑定的丰富组件和API。 框架的核心是一个响应的数据绑定系统。整个系统分为两块: 视图层(View) 和逻辑层(App Service)。框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会发生相应的更新。 组件框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。什么是组件: 组件是视图层的基本组成单元。 组件自带一些功能与微信风格的样式。 一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。 但使用起来还是有些不足，很多组件的风格与微信风格类似，不想使用这种风格的组件就需要自定义组件，而自定义需要花费一些额外的时间，就算自定义成功了，仍需要经过仔细的测试，确保该自定义组件在交互上不会与基础组件产生偏差。 API框架提供了丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。 说明： wx.on 开头的 API 是监听某个事件发生的API接口，接受一个 CALLBACK 函数作 为参数。当该事件触发时，会调用 CALLBACK 函数。 如未特殊约定，其他 API 接口都接受一个OBJECT作为参数。 OBJECT中可以指定success, fail, complete来接收接口调用结果。开发工具 在原有的公众号网页调试工具的基础上，推出了全新的微信开发者工具，集成了公众号网页调试和小程序调试两种开发模式。 在8月30日和8月31日，对开发工具进行了很大的更新。全新的视觉和交互体验，新增了申请测试报告功能，新增WXS功能。 开发中填的坑微信小程序填坑记录希望对你有帮助。 学习心得 多看官方文档，多看几遍，遇到问题时再看，没有问题时继续看； 关注论坛最新动态； 基础知识一定要过关（小程序的框架，组成部分，运行机制，自身限制）； 不要眼高手低，人家的demo下载下来跑起来，看懂之后一定要自己尝试写一遍； 找一个自己熟悉的逻辑，开始模仿（结合实际的项目需求，一步一步解决遇到的问题）。 遗留问题模态窗体上的textarea多行输入框，当滑动整个页面时，会将textarea里输入的内容一起滑动至输入框外部，随着滑动的方向一起滑动。官方文档中备注了关于textarea的一个tip: textarea组件是由客户端创建的原生组件，它的层级是最高的。 或许正是由于textarea是最高层级导致的滑动问题。 demo下载wxModeList 参考资料微信公众平台 | 小程序 小程序中的循环列表，在点击时改变当前项的背景颜色 小程序操作按钮悬浮固定在底部 动态的显示或隐藏控件 微信小程序从子页面退回父页面时的数据传递 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"初体验","slug":"初体验","permalink":"http://XibHe.github.io/tags/初体验/"}]},{"title":"二次筛选功能开发心得","date":"2017-08-22T16:00:00.000Z","path":"2017/08/23/FilterError/","text":"一个类似于京东搜索结果页的筛选功能，侧边栏条件筛选器，根据不同的数据类型进行条件筛选及筛选条件的排列展示。 构建原理及使用到的技术点 RunTime继承组合 遇到的问题 筛选列表距离顶部状态栏距离过近筛选列表展示选中数量限制替换二次筛选结果页数据源循环移除数组元素报错在筛选更多，跳转的搜索页面进行搜索调用两次接口请求 解决的方式替换二次筛选结果页数据源需求中要求替换筛选条件的数据源,表述如下: 选中的选项需要在二次筛选条件选择页中显示，选中的选项为默认展开的选项时，无需变更选项的位置，若选中的不是默认展开的选项，需要将选中的选项放到二次筛选条件选择页中，并代替筛选条件选择页中没被选择的默认展开的选项的位置，按照选中的时间顺序正序占据页面中的默认展开的选项的位置（举例说明：筛选条件选择页中的默认展开的选项是1、2、3、4、5，默认展开的选项选中的是2和4,然后用户点击查看更多的选项，先选了11然后又选了9的选项,根据逻辑，筛选条件选择页中显示的选项依次显示的是：11、2、9、4、5），若选中的选项被取消选择，选项的位置按照选中时的位置显示，不更改选项的位置。 如图，二次筛选结果页和生产厂家搜索列表页 当生产厂家筛选数据源大于6项时，只展示5个生产厂家，并显示“更多生产厂家 &gt;”的跳转提示。点击跳转至生产厂家搜索列表页面，在搜索页面会根据搜索关键字展示所有的生产厂家列表信息。该列表会展示上个页面勾选的生产厂家，并将其置于列表最前面。现在需要做的是: 当勾选列表页中一个或多个生产厂家，该生产厂家是二次筛选结果页(上一个页面)中，默认展示5个生产厂家中从未出现的一个，是一个新的生产厂家。则需要替换掉二次筛选结果页，生产厂家一栏中未被勾选的一个或多个生产厂家，直到全部替换完成。 方案一: 进行多层嵌套循环遍历，判断如果对象的selected属性为YES，则跳出当前循环并做一个标记，再从新进行外层循环。这样就需要设置至少两个以上的标记在循环遍历的基础之上再进行循环遍历。增加了逻辑判断的复杂性，也使代码变得不易读。 针对方案一不足之处，将方案一中的杂糅在一起的逻辑判断抽离成不同的情况，形成方案二。 方案二: 需要定义两个可变数组，_dataList(二次筛选结果页，生产厂家数据源)，_selectList(生产厂家搜索页，所有勾选的生产厂家数据源)。对二者进行嵌套循环遍历，需要考录到三种不同情况，并对这三种情况进行一一判断。① _dataList全部包含了_selectList中的元素；② _dataList不包含_selectList中的元素；③ _dataList包含部分_selectList中的元素。 针对以上三种情况对应的具体步骤: ① 遍历找到_dataList中的_selectList元素，变更生产厂家Model中selected状态，将这些选中的元素放到_dataList中元素位置的最前面； ② 直接将_selectList插入到_dataList的最前面； ③ 先替换，再插入新元素到_dataList中，最后再将生产厂家Model中selected为YES的元素前置到_dataList的最前面位置。 方案二仍需要进行大量的判断，操作起来仍旧复杂。那么，有没有简单粗暴，提刀就干的方案呢？下面就要说说方案三了。 方案三: 在生产厂家搜索列表页面直接进行操作。在二次筛选结果页点击跳转至生产厂家搜索页时，传入已经选中生产厂家的数组_selectList，生产厂家搜索结果列表页的数据源_datalist(包含当前已选中生产厂家的数组_selectList和所有未选中的生产厂家)。点击”确定“按钮时，去除_datalist中已选中的生产厂家的Model，然后使用block反向将去除后的_datalist和_selectList传给二次筛选结果页。 这样在二次筛选结果页就能直接操作已经处理过的筛选数据了，不用再进行复杂的逻辑判断了。总的来说，这种替换原有页面数据源的操作，以后还是在可以对数据源进行修改的页面进行处理，避免最后需要进行复杂的逻辑判断。 参考文档ZYSideSlipFilter Objective-C NSMutableArray mutated while being enumerated? Collection was mutated while being enumerated –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"二次筛选","slug":"二次筛选","permalink":"http://XibHe.github.io/tags/二次筛选/"},{"name":"NSArray enumerate","slug":"NSArray-enumerate","permalink":"http://XibHe.github.io/tags/NSArray-enumerate/"}]},{"title":"重构webView页面间跳转逻辑","date":"2017-08-06T16:00:00.000Z","path":"2017/08/07/reconsiderUrlPush/","text":"在处理webView页面内的跳转逻辑时，需要在当前webView中点击某个按钮push到另一个webView页，在这个新的webView页中仍然可以操作页面上的点击事件，跳转到其他webView页面。于是，这些webView页面可以相互跳转，不断跳转新的或者之前的webView页面。 业务需求点击商品进入到“商品详情”页(GoodInforH5WebViewController)，点击店铺进入“店铺详情”页(ShopInfoH5WebViewController)，其中(“商品详情”页和”店铺详情”页均为webView)。其中，店铺详情页和商品详情页可以相互跳转。 当前逻辑在继承于UINavigationController的自定义导航控制器MyNavigationController里做判断，重写方法: - (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated { if (self.viewControllers.count &gt; 0) { if ([self respondsToSelector:@selector(interactivePopGestureRecognizer)]) { self.interactivePopGestureRecognizer.delegate = nil; } viewController.hidesBottomBarWhenPushed = YES; if ([viewController isKindOfClass:[GoodInforH5WebViewController class]] || [viewController isKindOfClass:[ShopInfoH5WebViewController class]]) { viewController.navigationItem.leftBarButtonItem = [UIBarButtonItem itemWithTarget:self action:@selector(backRootViewController) image:@&quot;navigation_back&quot; highlightImage:@&quot;navigation_back&quot;]; } } [super pushViewController:viewController animated:YES]; } 重写GoodInforH5WebViewController和ShopInfoH5WebViewController的返回事件。即，backRootViewController。在backRootViewController方法里做相应页面的跳转操作。 在GoodInforH5WebViewController页面的viewWillAppear方法里进行页面跳转逻辑的判断。如下: 前方高能预警!!! - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:NO animated:NO]; //[_webView reload]; CLog(@&quot;self.navigationController.viewControllers count = %ld&quot;,[self.navigationController.viewControllers count]); CLog(@&quot;self.navigationController.viewControllers = %@&quot;,self.navigationController.viewControllers); // 若是经首页;分类列表页面;订单中心;商业店铺列表页;我的收藏,且viewControllers&lt;5,则设置pop回上一页的标识;商家促销,且viewControllers&lt;5,则设置pop回上一页的标识 if ([_fromWebUrl isEqualToString:@&quot;home_bussinessUrl&quot;] || ([_fromWebUrl isEqualToString:@&quot;assortment_searchByCate&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@&quot;sellOrderCenter_buyOrders&quot;] || ([_fromWebUrl isEqualToString:@&quot;My_collectionListUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@&quot;businessShopSearchList_goodInfo&quot;] || ([_fromWebUrl isEqualToString:@&quot;ActivityViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || ([_fromWebUrl isEqualToString:@&quot;BusinessPromoteViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5)) { [[NSUserDefaults standardUserDefaults] setObject:@&quot;1&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@&quot;search_searchByKey&quot;] || [_fromWebUrl isEqualToString:@&quot;business_shopSearch&quot;] || ([_fromWebUrl isEqualToString:@&quot;home_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 6) || [_fromWebUrl isEqualToString:@&quot;businessShopSearchList_shopInfo&quot;] || ([_fromWebUrl isEqualToString:@&quot;home_productDetailUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 4) || ([_fromWebUrl isEqualToString:@&quot;ShopCarListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 4)){ // 从GoodsListViewController跳转至原生商品详情页面;从顶部搜索等页面跳转至原生商品详情页面; 从商业店铺搜索结果列表页跳转,点击返回至self.viewControllers[2]的页面;若是从搜索首页，分类的搜索结果页跳转而来,返回搜索商品列表页;若是从商业店铺列表页跳转而来，则返回到店铺详情的H5页面;从首页商品--&gt;商品详情--&gt;店铺详情--&gt;商品详情，并且viewControllers&gt;=4，则返回店铺详情页;从原生购物车跳转而来,且viewControllers&gt;=4，则返回店铺详情页; [[NSUserDefaults standardUserDefaults] setObject:@&quot;2&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@&quot;shopInfor_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 7) || ([_fromWebUrl isEqualToString:@&quot;assortment_searchByCate&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;My_collectionListUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;ActivityViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] == 5)) { // 若是从商业店铺详情搜索跳转而来;若是从分类列表页跳转而来;若是从我的收藏跳转而来，且viewControllers&gt;=5，则返回店铺详情页面。 [[NSUserDefaults standardUserDefaults] setObject:@&quot;3&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@&quot;home_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 6) || ([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 6)) { // 从搜索商品列表--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=6，则返回店铺详情页；从订单详情页--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=6，则返回店铺详情页； [[NSUserDefaults standardUserDefaults] setObject:@&quot;4&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if ([_fromWebUrl isEqualToString:@&quot;shopInfor_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 7) { // 从搜索商品列表--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=7，则返回店铺详情页。 [[NSUserDefaults standardUserDefaults] setObject:@&quot;5&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else { [[NSUserDefaults standardUserDefaults] setObject:@&quot;0&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } } 这里是通过设置一个名为KPopHomeIndentify的NSUserDefaults对象用于存储navigationController中，当前页面的层级。通过设置一个名为_fromWebUrl的字符串，用于判断是哪个页面跳转而来的。二者结合起来，设置经过GoodInforH5WebViewController页面的返回逻辑。 当触发商品详情页的跳转链接时，需要在webView的shouldStartLoadWithRequest代理方法里做判断，当request的绝对地址中包含店铺详情的路径时，则push到店铺详情页。如下: #pragma mark - UIWebViewDelegate -(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { _absoluteUrl = [request.URL absoluteString]; // push到店铺详情页面 if ([_absoluteUrl rangeOfString:@&quot;appLink/showBusyInfo?&quot;].location != NSNotFound) { ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init]; shopInforH5WebVC.webUrl = _absoluteUrl; shopInforH5WebVC.fromWebUrl = _fromWebUrl; [self.navigationController pushViewController:shopInforH5WebVC animated:YES]; return NO; } else { return YES; } } 再回到自定义导航控制器MyNavigationController重写的返回事件中: - (void)backRootViewController { CLog(@&quot;self.viewControllers = %@&quot;,self.viewControllers); NSString *popIndentify = [[NSUserDefaults standardUserDefaults] objectForKey:KPopHomeIndentify]; UIViewController *viewCtl; if ([popIndentify isEqualToString:@&quot;0&quot;]) { viewCtl = self.viewControllers[0]; } else if ([popIndentify isEqualToString:@&quot;1&quot;]) { viewCtl = self.viewControllers[1]; } else if ([popIndentify isEqualToString:@&quot;2&quot;]) { viewCtl = self.viewControllers[2]; } else if ([popIndentify isEqualToString:@&quot;3&quot;]) { viewCtl = self.viewControllers[3]; } else if ([popIndentify isEqualToString:@&quot;4&quot;]) { viewCtl = self.viewControllers[4]; } else if ([popIndentify isEqualToString:@&quot;5&quot;]) { viewCtl = self.viewControllers[5]; } [self popToViewController:viewCtl animated:YES]; } 同样是结合GoodInforH5WebViewController中设置好的KPopHomeIndentify进行判断。根据KPopHomeIndentify存储的导航控制器中的页面层级，在导航控制器中通过这些层级获取到对应的页面viewController，最后popToViewController到这些页面中。 重构原因看了上面那一片高能预警的代码逻辑，重构原因就不言而喻了。 *逻辑判断复杂，每次新增与商品详情，店铺详情相关页面时，都需要新增一系列对应页面层级的判断逻辑； *给调试造成困难，与商品详情，店铺详情关联的页面很多，需要进行多场景的关联测试； *最重要的一点:每次从商品详情页跳转到店铺详情都需要重新重新alloc一个新的ShopInfoH5WebViewController对象，耗费了很多资源。 重构逻辑通过设置NSUserDefaults存储页面层级方式进行页面跳转的逻辑，不易操纵，并且非常的不合理，也降低了代码的可读性。设想一下，这里之所以明确不同跳转页面在navigationController中的层级关系，是为了返回操作能回退到指定页面。而导致该冗余代码的罪魁祸首是:每次触发商品详情页或店铺详情页的跳转链接时，都会重新alloc一个新的对象。在进行多次跳转操作后，navigationController中控制的层级就会一直增加，若想在pop操作时跳转到指定页面，就必须明确所要跳转页面在导航控制器中的层级。 那接下来的操作就很明确了，首先移除GoodInforH5WebViewController中viewWillAppear里的一堆判断代码；然后，在webView的代理方法shouldStartLoadWithRequest中增加跳转判断，如下: #pragma mark - UIWebViewDelegate -(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { _absoluteUrl = [request.URL absoluteString]; CLog(@&quot;_absoluteUrl = %@&quot;,_absoluteUrl); // push到商业店铺详情页面 if ([_absoluteUrl rangeOfString:@&quot;appLink/showBusyInfo?&quot;].location != NSNotFound) { UIViewController *shopInfoH5WebViewController; for (shopInfoH5WebViewController in self.navigationController.viewControllers) { if ([shopInfoH5WebViewController isKindOfClass:[ShopInfoH5WebViewController class]]) { // addExtractBankCardVCIndex = [self.navigationController.viewControllers indexOfObject:addExtractBankCardVC]; [self.navigationController popToViewController:shopInfoH5WebViewController animated:YES]; break; } else if ([shopInfoH5WebViewController isKindOfClass:[GoodInforH5WebViewController class]]) { ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init]; shopInforH5WebVC.webUrl = _absoluteUrl; shopInforH5WebVC.fromWebUrl = _fromWebUrl; [self.navigationController pushViewController: shopInforH5WebVC animated:YES]; break; } } return NO; } else { return YES; } } 这里遍历navigationController.viewControllers中所有视图控制器。如果存在店铺详情(ShopInfoH5WebViewController)对象类，则直接popToViewController到该控制器中；如果不存在，则alloc一个新的店铺详情(ShopInfoH5WebViewController)，并pushViewController到该页面。 最后仍然需要在自定义导航控制器MyNavigationController重写的返回事件（backRootViewController）中做跳转的逻辑判断。如下: - (void)backRootViewController { CLog(@&quot;self.viewControllers = %@&quot;,self.viewControllers); // 当前视图控制器 UIViewController *currentVC = [self.viewControllers lastObject]; // 视图控制器的层级 NSInteger currentVCIndex = [self.viewControllers indexOfObject:currentVC]; // 上一个页面的视图控制器 UIViewController *previousVC = self.viewControllers[currentVCIndex - 1]; if ([currentVC isKindOfClass:[GoodInforH5WebViewController class]]) { if ([previousVC isKindOfClass:[ShopInfoH5WebViewController class]]) { [self popToViewController:previousVC animated:YES]; } else { [self popViewControllerAnimated:YES]; } } else if ([currentVC isKindOfClass:[ShopInfoH5WebViewController class]]) { // 其他会跳转到店铺页面视图的跳转逻辑 UIViewController *previoussLastVC; if ((currentVCIndex - 2) &gt;= 0) { previoussLastVC = self.viewControllers[currentVCIndex - 2]; } else { previoussLastVC = [self.viewControllers firstObject]; } if ([previousVC isKindOfClass:[GoodInforH5WebViewController class]] ) { // 我的积分跳转 if ([previoussLastVC isKindOfClass:[OrderDetailsViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 我的收藏 else if ([previoussLastVC isKindOfClass:[MyCollectionViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 分类 else if ([previoussLastVC isKindOfClass:[LonchH5WebController class]] &amp;&amp; [self.viewControllers[0] isKindOfClass:[AssortmentViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 首页，分类搜索结果页 else if ([previoussLastVC isKindOfClass:[SearchResultViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } else { [self popToRootViewControllerAnimated:YES]; } } else { [self popViewControllerAnimated:YES]; } } } 这里通过获取当前页面层级，以及当前页面上一个页面的层级，通过这些层级做相应的跳转操作: 如果当前页面是商品详情页(GoodInforH5WebViewController)，再进一步判断它的上个页面是否为店铺详情页(ShopInfoH5WebViewController)，若是则popToViewController到上个页面，否则直接popViewControllerAnimated； 如果当前页面是店铺详情页(ShopInfoH5WebViewController)，则需要判断当前视图层级是否越界(当前页面层级currentVCIndex不会超过3级，可能会遇到导航控制器中只有1个视图控制器的情况)，这里与商品详情页不同的是:增加了其它会跳转到店铺页面视图的跳转逻辑。需要对这些页面（积分、我的收藏、分类、搜索结果页）的跳转进行判断。 总结事不过三，过则重构! –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"重构","slug":"重构","permalink":"http://XibHe.github.io/tags/重构/"}]},{"title":"(译)一个给iOS App瘦身的奇怪窍门","date":"2017-07-22T16:00:00.000Z","path":"2017/07/23/One Weird Trick to Lose Size/","text":"流行的社交网络应用程序超过400M。每周更新一次，每年你下载的应用总量接近20G。 自从我们推出了Halide，我们听到的最令人意想不到的赞美就是它的大小。 在11M，我们将在一年内推出较少数据的更新，而不是社交网络应用进行频繁更新。 一个朋友问道：“所以你没有使用Swift。” 毕竟，Swift将其标准库捆绑到你的应用程序中，使应用大小增大。 Halide几乎完全是使用Swift编写的。 我们是怎么做的？ 我们从技术位开始吧。 这里有很多关于如何减少App大小的重要评论。 测量，不要猜从Xcode导出版本构建。 选择“Save for Ad Hoc deployment.”。假设你的应用程序支持app thinning（此时真的应该这样做），请选择“Export for Specific Devices.”。确保选中“ Rebuild from bitcode ”。 你不仅可以获得最终包的大小，还可以获得App Thinning报告。检查你的应用程序包，找到最大存储空间的占用者。 使用 Asset Catalogs将资源保存在资源目录中。当你上传应用程序时，Apple将其分解为特定设备的版本，因此具有2x屏幕的设备不会获得3x资源，反之亦然。 运行 PNG-crush将资源放入目录之前，请运行pngcrush。 根据QA1681，Xcode将自动压缩资源目录之外的PNG资源。 尝试JPEG格式照片由于UI资源格式限制以及PNG格式资源更加精细。这可能构成了你应用程序中大部分资源，但如果你有照片，请尝试使用JPEG格式。这样做会有些压力。 现在进入到一个困难步骤的实现经过这么辛苦的工作，你只能删掉一个100M项目中几M的文件。我不知道如何告诉你，但你需要更少的代码。 选择正确的方式Halide有大概15000行用Swift编写的代码。这包括一个实时视频处理器，一系列自定义控件，以及我们控制AVFoundation的平台。有趣的是我并没有写代码。 通过使用自动布局，我绘制了数千条样板。许多开发人员仍然坚持手工布局。也许他们不明白自动布局，也许他们听到朋友的朋友关于自动布局如何缓慢的言论。（事实并非如此。） 我看到太多的开发人员 - 特别是在大型公司 - 发明内部布局引擎。这简直太疯狂了。当Apple在操作系统上捆绑一个精细的布局引擎时，不要用自己定制的框架来增大应用程序。 我们可以通过删除Interface Builder来减少100k。用户手册和设置几乎完全是具有约束条件的IB。相机UI的高级布置也类似如此。但我们认为短期内开发进度是值得肯定的。 避免Library过大检查许多大型应用程序的包，你会发现几十个第三方框架，大小从100k到几兆。 我不使第三方库。这虽然有点极端，但我们有一个独特的情况。 很多第三方库不具备我们所需要的功能。iOS开发社区拥有大量的JSON映射器，但对于DNG文件的低级操作没有任何意义。 但是我之前提到的视频处理呢？我可以听到你大声喊叫，“GPUImage是可扩展的！你的做法太疯狂了!” 从我对Periscope的堆栈的经验来看，我们看到从GPUImage到内部解决方案的巨大收益。如果实时图像处理不是你业务的一部分，GPUImage就会很好。但是鉴于我们对Halide的长期愿景，以及实时渲染的作用，重要的是能掌控这样的组件。 由于文件太大，我从未引入过GPUImage。但是作为自己疯狂的结果，我避免了在我们的应用程序中捆绑125个未使用的过的滤镜。 PSPDFKit具有相似的成功经验，取代了太大的框架： 我们很高兴地告诉你，使用PSPDFKit 6.8 for iOS，我们重写了数字签名实施的核心，以改进检测，验证和更好的错误报告。因此，我们也设法完全放弃了对OpenSSL的依赖，从而减少了二进制文件的大小。 不要感染 Not-Invented-Here 综合征，有很多理由来避免使用三方库。 不要在分析和A / B测试中浪费资源我们不会使用任何第三方分析或崩溃报告服务。首先，我们不是很乐意将用户数据发送给广告公司。让我们暂停这样的想法。 数据不是免费的。在大型应用中，每个动作都会记录一个分析事件。大型应用程序需要日志记录基础设施 - 唯一标识用户，重复数据删除请求，缓存日志，重试失败等。这些操作都会进行叠加。 A / B测试更糟糕。你的典型社交网络应用程序由于没有人使用而死在的A / B测试上。 我们出于代码膨胀的考虑避免了分析和A / B测试。这只是我们的产品理念。知道太多的数据会扭曲你的想法。你发现自己在优化某个不存在的特殊场景，而不是真的去关注用户实际会不会有这样的需求。 所以我们使用苹果分析。它只是简单的记录，没有任何代码更改。并且免费。它尊重用户的隐私，需要选择加入。我们的选择加入率为32％，这对我们的需求是很好的。 有分析的时间和地点。我们不确定我们的最优价格，所以我们可以在那里进行实验。然而，我们在业务驱动的分析和产品开发之间保持隔离。 你需要一致的目标我们是一个两个人的开发团队。我们通过销售产品赚钱。我们顺其自然的成长。当用户高兴时，他们会向朋友们推荐我们。小应用让我们开心，我们认为用户也很开心。 我们的建议并不能帮助应用程序包很大的App。社交网络通过广告赚钱，广告客户需要详细的分析广告定位。 大型应用程序拥有数百名开发人员，组成数十个团队，每个团队都有独立的季度目标。 你走的越快，你达成的目标越多，你的晋升越有可能。 想想这是可以理解的，“这个三方库节省了我们一个星期的开发时间，但是在我们的应用程序中增加了1M。那么我们的App已经是几百M了，还有其它办法吗？” 大型组织充满带来意想不到后果的合理想法。 据说工程师想得到提升。输送功能不会让你达到目的。建立一个新的布局引擎。该公司甚至获得了工程博客的招聘诱饵。 唯一的解决方案是高层领导宣布：“我们将减少我们的应用程序大小。”不幸的是，科技CEO们不会使用8G的储存空间的iPhone，他们不会生活在网速受限的地区。 这不是一个毫不费力的努力。自从Halide发布以来，我们收到了来自世界各地的大量消息，感谢我们努力保持App的小巧。 减小App安装包大小真的有一个奇怪的伎俩：专注于你的客户。 原文地址One Weird Trick to Lose Size –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"App瘦身","slug":"App瘦身","permalink":"http://XibHe.github.io/tags/App瘦身/"}]},{"title":"第一个父亲节","date":"2017-06-17T16:00:00.000Z","path":"2017/06/18/First-father's-day/","text":"我和妻子是大学同学，在恋爱长跑五年后结了婚。妻子老家不是我们那边的，但是在同一个省，最开始的地域原因，造成了我家人对她的偏见。我们俩克服了种种阻碍，在15年情人节那天领了证。 我们的小孩比计划来的早，妻子一直很期待在猴年能生一个聪明伶俐的猴宝宝。当得知自己要作父亲的那一天，内心感受是复杂的，有期待，也有忐忑。觉得自己没有做好成为一个父亲的准备。伴随着孩子快要出生，我的这种焦虑感越发的明显了。在妻子待产期间，没有全身心的去照顾她，总是把工作中的压力和不快带到家里。终于，在一个周三的早上爆发了…… 最后，还是妻子在妻子的安慰下，我才渐渐平复了自己的心情。 由于老家人和妻子之间的矛盾，再加上我父母都不在老家，不能照顾快要临产的妻子。最终选择在我妻子老家待产。孩子出生那天的凌晨十二点多，那时我并不在妻子身边，电话那头当妻子告诉我小家伙出生了，是个男孩时，我就再也控制不住自己的激动，惊喜，幸福的感情了。当得知妻子由于羊水不足而剖腹产时，听着电话一头，妻子有气无力的声音。当时真想给自己一巴掌，我没有尽到作丈夫的责任，在妻子临盆时不能陪在她身边，给她鼓励，让她安心。还让我岳母，一个50多岁，腿脚不便利的老人家为我妻子跑前跑后，楼上楼下的张罗妻子生产的一切事宜。 像我这样的渣男竟然还有女人给我生孩子，把自己的终身幸福托付给我。我上辈子一定是积了什么大功德了！无法忘记第一次见到小家伙的场景，他紧握着一双小手，眼睛半闭半睁，好奇的打量着周围的一切。虽然我嘴上一直在埋怨小家伙让他妈妈挨了一刀，但心里还是对他充满了怜爱。唯一遗憾的是，陪在她们母子身边的时间太短，不等小家伙满月我就不得不离开她们母子俩，带着不舍与留恋重新投入到工作中。 这次端午节回家，小家伙给了我一个大大的惊喜。刚一见面，盯着看了我半天，然后就用一双小手抚摸我的脸，最后，嘿嘿一笑，扑到我的怀里。那一刻，时间仿佛静止，而我又找到了初恋的感觉[害羞]。这不禁又让我感慨了一番：不能时刻陪在你身边，经历你的成长，听到你第一次喊爸爸。终究是我无法弥补的遗憾。这里不奢望能得到你的原谅，只希望将来的某一天你能理解。成年人的生活里没有容易二字。爱❤你我的小宝贝！ 再过一个多月我们家宝宝就一岁了，这一年来我经历了很多，也成长了很多。感谢妻子的宽容和奉献，她总是迁就我的时不时就发作的小情绪，安慰我，鼓励我，支持我。尽她最大的力量来爱我和儿子。爱❤你我的大宝贝！你和儿子就是我的一切，我的天下无双。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"父亲节","slug":"父亲节","permalink":"http://XibHe.github.io/tags/父亲节/"}]},{"title":"《黑客与画家》小记","date":"2017-05-30T16:00:00.000Z","path":"2017/05/31/hacker-and-artist/","text":"郭一刀推荐的一本书，一本关于创业经历，软件开发，个人品味的书。也许是书中的章节相互独立，给我的感觉像是集合了众多的tips。而这些闪光点，或是忠告，或是建议，或者结合了很多事实而形成的结论。读后给我一种醍醐灌顶的感觉，Paul结合自己的创业和开发经历，将计算机编程的本质娓娓道来。全书大致分成三个部分: 解释了什么是黑客，黑客是如何看待这个世界的。 黑客去的成果，这些成果对世界的影响，如何创造财富？用黑客的方法防止垃圾邮件。 黑客心目中完美的编程语言是什么样的，为什么黑客如此执着于设计新的编程语言。 Paul是世界上首个互联网应用程序Viaweb的开发者之一。创建的Viaweb公司后来被雅虎收购，改名为Yahoo!Store。后来Paul成为一名资深的投资人，作为一名成功的创业者同时也是一名熟练使用Lisp语言的专家。他的经历很生动，完美诠释黑客文化的基础和核心。其中是我印象深刻的是一段关于如何促成潜在的买方掏钱收购自己创业公司的论述: 大多数时候，促成买方掏钱的最好办法不是让买方看到有获利的可能，二手让他们感到失去机会的恐惧。对于买家来说，最强的收购动机就是看到竞争对手可能收购你。我们发现这会使得CEO们连夜行动。次强的动机则是让他们担心如果现在不买你，你的高速成长将使得未来的收购耗资巨大，甚至你本身可能变成一个他们的竞争对手。 Paul曾经学习过绘画，绘画是一门艺术性很强，同时需要欣赏者有着相应的鉴赏和审美能力的创作方式。Paul总是能将自己的编程和创业经历与之结合起来，切中要害的指出二者之间的联系。 关于设计者的品味，只要你开始思考这个问题，你就会发现不同的领域对于“美”的理解有着惊人的相似度。优秀设计的原则是许多学科的共同原则，一再反复地出现。 好设计是简单的设计 好设计是永不过时的设计 好设计是解决主要问题的设计 好设计是启发性的设计 好设计通常是有点趣味性的设计 好设计是艰苦的设计 好设计是看似容易的设计 好设计是对称的设计 好设计是模仿大自然的设计 好设计是一种再设计 好设计是能够复制的设计 好设计常常是奇特的设计 好设计是成批出现的 好设计常常是大胆的设计 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"《黑客与画家》","slug":"《黑客与画家》","permalink":"http://XibHe.github.io/tags/《黑客与画家》/"}]},{"title":"使用JSExport进行JS交互时遇到的一个问题","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/使用JSExport进行JS交互时遇到的一个问题/","text":"在使用JSExport与OC和JS进行通信，遇到一个问题，无法调用JS传递的最新购物车商品数量的交互方法。 解决方法将之前的放在VC里的JS交互方法抽离到单独的一个类中，这个类继承NSObject。不做任何特别的处理，将 JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; context[@&quot;jsObject&quot;] = self; 这句代码，从 - (void)webViewDidFinishLoad:(UIWebView *)webView 移到， - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType 该代理方法中，就能每次都调用JS与OC的交互方法。 JavaScriptCore使用注意JavaStript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换，而在回调JavaScript方法的时候最好是在刚开始调用此方法的线程中去执行那段JavaStript方法的代码。 参考文献iOS js oc相互调用（JavaScriptCore）（二）ios 与 js交互一点心得 Demo点击下载 遗留问题这里只有获取购物车最新商品数量时，无法调用JS交互方法，其他的JS交互方法仍然可以调用。那么获取JSContext的时机是什么 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"JSExport","slug":"JSExport","permalink":"http://XibHe.github.io/tags/JSExport/"},{"name":"JS里通过对象调用方法","slug":"JS里通过对象调用方法","permalink":"http://XibHe.github.io/tags/JS里通过对象调用方法/"}]},{"title":"(译)HTTPS的工作原理","date":"2017-04-26T16:00:00.000Z","path":"2017/04/27/HTTPS/","text":"HTTPS只是标准HTTP协议涂上一层美味的SSL/TLS加密信息。 除非出现严重错误,它可以防止人们因infamous Eve查看或修改那些构成你浏览中产生的请求；让你可以安全的在你的电脑和服务器之间发送密码、通信和信用卡信息等数据。当绿色小挂锁和字母“https”出在你的地址栏时，并不意味你所访问的网站仍是之前的，而不是已经被篡改过的，当你打开网页时这些标识至少帮助你安全地访问网页。 1.什么是HTTPS以及它做了什么?HTTPS是著名的HTTP协议，是在SSL / TLS(以下简称为“SSL”)加密层之上。服务器和客户端仍然通过完全相同的HTTP协议进行通信，但二者的通信是建立在一个安全的SSL连接,加密和解密请求和响应体系之上的。SSL有两个主要目的: 验证你所访问的服务器的正确性 确保你与服务器之间的数据通信，无论是你发送给服务器的还是服务器返回给你的信息不被篡改 真正非常聪明的部分是任何人都可以拦截您与服务器交换的每一个消息，包括您同意使用密钥和加密策略的消息，仍然无法读取任何实际发送的数据。 2.如何建立SSL连接通过握手建立客户端和服务器之间的SSL连接，其目的是: 为了确实与客户端通信服务器的正确性 双方已经同意一个“密码套件”，其中包括二者将用于交换数据的加密算法 双方已就此算法达成任何必要的密钥 一旦连接建立，双方可以使用约定的算法和密钥来安全地发送消息给彼此。我们将把握手分为3个主要阶段 - 发送Client Hello报文，证书交换和密钥交换。 1.客户端发送Client Hello报文 — 握手开始于客户端发送Client Hello报文。这包含服务器通过SSL连接到客户端所需的所有信息，包括各种密码套件及其支持的最大SSL版本。服务器使用Server Hello报文进行响应，报文中包含客户端所需的类似信息，包括根据客户端的偏好决定将使用哪个加密套件和SSL版本。 2.证书交换 — 现在连接已经建立起来了，服务器必须向客户端证明其身份。这是使用SSL证书来实现的，这是一个很小的类似于护照的东西。SSL证书包含各种数据，包括所有者的名称，附加的属性（例如域），证书的公钥，数字签名和有关证书有效期的信息。客户端检查隐式信任该证书，或者它被隐式信任的几个证书颁发机构（CA）之一被验证和信任。更多关于证书的要求。注意服务器还可以要求通过证书证明客户端的身份，但这通常只发生在非常敏感的应用程序中。 3.密钥交换 — 客户端和服务器交换的实际消息数据的加密将使用一种对称算法来完成，该算法在发送Client Hello报文阶段已被认可。对称算法使用单个密钥进行加密和解密，与需要公钥/私钥对的不对称算法相反。双方需要就此单一的对称密钥达成一致，即使用非对称加密和服务器的公钥/私钥可以安全地实现这一过程。 客户端生成用于主对称算法的随机密钥。它使用在发送Client Hello报文阶段中同意的算法和服务器的公钥（在其SSL证书上找到）对其进行加密。它将此加密密钥发送到服务器，使用服务器的私钥对其进行解密，握手会话中有趣部分就这样完成了。双方都充满乐意，如同他们正在和正确的人交谈，并且秘密地同意对对方加密他们即将发送的数据的密钥。HTTP请求和响应现在可以通过对明文消息进行加密后发送。 3.证书3.1信任在最基本的层次上，SSL证书只是一个文本文件，任何具有文本编辑器的人都可以创建一个。实际上，您可以创建一个证书，声称您是Google Inc.，并且你掌握域名gmail.com。如果这是事实，SSL就是一个笑话;身份验证基本上是客户端询问服务器“你是Google吗？”，服务器回复“呃，是的，这是一张纸，’我是Google’写的”，客户说“好，这是我所有的数据”。阻止这场闹剧的魔法是在数字签名中，允许一方验证另一方的纸张是否合法。为什么你可能信任证书有两个明智的原因： 如果它在你隐含信任证书的列表上 如果能够证明它是被上述列表中的一个证书的控制器所信任 第一个标准很容易检查。您的浏览器具有可从其中查看，添加和删除证书颁发机构(CA)可信SSL证书预先安装的列表。这些证书由一个集中的（在理论上，一般在实践中）组织来控制，这些组织非常安全，可靠和值得信赖，如Symantec，Comodo和GoDaddy。如果服务器从该列表中提供证书，那么您可以信任它。 第二个标准很难。服务器很容易说：“er，我的名字是er，来自微软，你信任Symantec和er，他们完全相信我，所以很酷。”一个有点聪明的客户端可能会去问Symantec“我有一个来自微软的服务请求，说你相信他们，这是真的吗？”但即使Symantec说“是的，我们知道他们，微软是合法的”，您仍然不知道声称是Microsoft的服务器实际上真的是微软还是某些入侵者。这时候数字签名该登场了。 3.2数字签名如前所述，SSL证书具有关联的公钥/私钥对。公钥作为证书的一部分分发，私钥被保密。这对非对称密钥用于SSL握手，以交换另一个密钥，供双方对数据加密和解密。客户端使用服务器的公钥加密对称密钥，并将其安全地发送到服务器，服务器使用其私钥对其进行解密。任何人都可以使用公钥加密，但只有服务器可以使用私钥进行解密。 数字签名的情况恰恰相反。证书可以由另一个机构“签署”，从而有效地记录在案，“我们已经证实该证书的控制人也控制证书上列出的属性（域名）”。在这种情况下，权限使用其私钥（广义地说）加密证书的内容，并且该密文作为数字签名附加到证书中。任何人都拥有权限使用公钥对该签名进行解密，并验证其是否为预期的解密值。但只有证书的所有者才能使用私钥加密内容，所以只有所有者才能实际创建一个有效的签名。 因此，如果服务器声称拥有由Symantec（或其他CA）签署的Microsoft.com的证书，那么您的浏览器不需要为此签名。如果是合法的，Symantec将使用（超秘密）私钥来生成服务器的SSL证书的数字签名，因此您的浏览器使用可以使用（超公共）公钥来检查该签名是否有效。Symantec将采取措施确保他们正在签署的组织真正拥有Microsoft.com，因此，鉴于您的客户信任Symantec，可以确定它真的在与微软公司对话。 3.3自签名请注意，所有根CA证书都是“自签名”，这意味着使用自己的私钥生成数字签名的证书。根CA证书没有什么特别之处 — 你可以生成自己的自签名证书，并使用它来签署其他证书。 但是，由于您的随机证书不会作为CA预先加载到任何浏览器的任何地方，所以他们都不会相信你所签署的自己的或他人的证书。你是有效地说“呃，我真的是微软，这里是我自己签发并签署的身份证件”，所有正常运行的浏览器都会弹出一个非常严重的错误信息，以回应你的诡计。 这给所有浏览器和操作系统发行商带来了巨大的负担，只能信任干净的根CAs，因为他们的用户最终信任vet网站并保持证书安全的组织。这不是一件容易的事。 3.4你相信什么？有趣的是，你的客户在技术上并不试图验证是否应该信任发送证书的一方，而是应该信任证书中包含的公开密钥。SSL证书是完全公开和公共的，因此任何攻击者都可以获取Microsoft的证书，拦截客户端对Microsoft.com的请求，并向其提供合法的证书。客户端会接受这一点，并开始愉快地握手。 但是，当客户端加密将用于实际数据加密的密钥时，它将使用该真实证书中的真实的Microsoft公钥进行此操作。由于攻击者没有Microsoft私钥来解密，所以他们现在被终止了。即使握手完成，它们仍然无法解密密钥，因此无法解密客户端向其发送的任何数据。只要攻击者不控制受信任的证书的私钥，正常的秩序就会顺利进行下去。如果客户骗取了受信任的证书，攻击者控制了证书和公钥，那么麻烦就开始了。 4.真的很有趣的事实4.1咖啡店可以通过网络监控我的HTTPS流量吗?不。公钥密码使用方法的魔力意味着攻击者可以观察客户端和服务器之间交换的每一个字节数据，并且仍然不知道你们之间所说的话大致等于多少交换的数据量。然而，你的正常HTTP流量在不安全的Wi-Fi网络上仍然非常脆弱，而且脆弱的网站可能会成为任何数量的解决方案的受害者，这些方法可能会欺骗您通过纯HTTP或在完全错误的地方发送HTTPS流量。例如，即使登录表单通过HTTPS提交用户名/密码组合，如果表单本身通过HTTP安全地加载，那么攻击者可能会在到达您的计算机的途中拦截表单的HTML，在修改后将登录详细信息发送到他们自己的服务器。 4.2我的公司可以通过网络监控我的HTTPS流量吗？如果使用由自己公司控制的机器，那么是可以监控的。请记住，在每个信任链的根源都是一个隐含信任的CA，并且这些权限的列表存储在您的浏览器中。您的公司可以使用他们的机器访问权限，将自己的自签名证书添加到这个CA列表中。然后他们可以拦截您的所有HTTPS请求，提供声称代表相应网站的证书，由他们的假CA签名，因此毫无疑问，您的浏览器信任这些CA签名。由于使用其狡猾的证书的公钥对所有HTTPS请求进行加密，所以可以使用相应的私钥来解密和检查（甚至修改）您的请求，然后将其发送到其预期位置。他们可能不会这样做。但他们可以。顺便提一句，这也是你如何使用代理来检查和修改iPhone应用程序所提供的其他无法访问的HTTPS请求。 4.3那么Lavabit和联邦调查局怎么了？Lavabit是2013年NSA泄漏疯狂期间爱德华·斯诺登（Edward Snowden）的超级安全的电子邮件提供商。正如我们所看到的，无数标准黑客可以允许联邦调查局看到Lavabit和其客户之间的任何数据。没有Lavabit SSL证书的私人密钥，黑客们是不可能监听到这些数据的。然而，一位有益的美国法官告诉Lavaff创始人Ladar Levison，他不得不交出这个钥匙，有效地让联邦调查局自由地监视核心的内容。Levison通过在4点类型的11个硬拷贝页面上交出2,560个字符的键，试图停下来，但是被要求执行一个命令，必须以有用的格式交出私钥，否则将会面对每天5000美元的罚款。一旦他遵守了这个命令，Lavad的CA证书颁发机构GoDaddy就会认为证书被破坏了，就撤销了证书。这将Lavabit证书添加到证书吊销列表（CRL）中，该证书撤销列表（CRL）是客户端不再信任以提供安全连接的可信证书的列表。妥协的结果，自签名或其他不可信任的证书导致浏览器显示一个大的红色错误消息，并且阻止或彻底禁止用户进一步的操作。不幸的是，浏览器将继续信任破坏的证书，直到它们将最新的更新提交给CRL，这个过程在实践中显然是不完美的。 5.结论HTTPS不是不可破解的，SSL协议必须不断发展，因为对其的新攻击一直在快速的发展演化。但是，如果看不到您的消息，那么传输秘密数据的方式仍然是令人印象深刻的方式。当然，这里没有提及许多实现细节，例如握手消息的确切格式和顺序，缩短的握手来接收最近的会话而不必重新协商密钥和密码套件，以及每个阶段可用的许多不同的加密选项。要记住的关键是，尽管HTTPS将数据安全地保护到目的地，但绝对不会对您（作为用户或开发人员），保护您免受XSS或数据库泄漏或任何其他事情造成的严重影响。时刻保持警惕。 在威尔·史密斯的不朽言辞中，“在黑暗中行走，要时刻注意，防止突发的暴力。”。如果你喜欢这片文章，你可能会喜欢我的另一篇文章解释SSL2015年FREAK漏洞的细节。 原文地址How does HTTPS actually work? 参考资料 《图解HTTP》 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://XibHe.github.io/tags/HTTPS/"},{"name":"HTTPS的工作原理","slug":"HTTPS的工作原理","permalink":"http://XibHe.github.io/tags/HTTPS的工作原理/"}]},{"title":"iOS下的图形绘制","date":"2017-04-23T16:00:00.000Z","path":"2017/04/24/Graphics-rendering/","text":"图形绘制iOS系统本身提供了两套绘图的框架，即UIBezierPath 和 Core Graphics。而前者所属UIKit，其实是对Core Graphics框架关于path的进一步封装，所以使用起来比较简单。但是毕竟Core Graphics更接近底层，所以它更加强大。 UIBezierPathUIKit中的UIBezierPath是Core Graphics框架关于path的一个封装。可以创建基于矢量的路径，例如椭圆或者矩形，或者有多个直线和曲线段组成的形状。我们可以用moveToPoint: 和 addLineToPoint:方法去构建。moveToPoint:设置我们想要创建形状的起点。从这点开始，我们可以用方法addLineToPoint:去创建一个形状的线段。我们可以连续的创建line，每一个line的起点都是先前的终点，终点就是指定的点。closePath可以在最后一个点和第一个点之间画一条线段。 - (void)drawRect:(CGRect)rect { UIColor *color = [UIColor colorWithRed:0 green:0.7 blue:0 alpha:1]; [color set]; UIBezierPath* aPath = [UIBezierPath bezierPath]; aPath.lineWidth = 5.0; aPath.lineCapStyle = kCGLineCapRound; aPath.lineJoinStyle = kCGLineCapRound; // 起点 [aPath moveToPoint:CGPointMake(100.0, 0.0)]; // 绘制线条 [aPath addLineToPoint:CGPointMake(200.0, 40.0)]; [aPath addLineToPoint:CGPointMake(160, 140)]; [aPath addLineToPoint:CGPointMake(40.0, 140)]; [aPath addLineToPoint:CGPointMake(0.0, 40.0)]; [aPath closePath];//第五条线通过调用closePath方法得到的 //根据坐标点连线 [aPath stroke]; [aPath fill]; } UIBezierPath+CAShapeLayerCAShapeLayer 继承自 CALayer ，因此，可使用 CALayer 的所有属性。但是， CAShapeLayer 需要和贝塞尔曲线配合使用才有意义。查看官网说明: /* The shape layer draws a cubic Bezier spline in its coordinate space. The spline is described using a CGPath object and may have both fill and stroke components (in which case the stroke is composited over the fill). The shape as a whole is composited between the layer’s contents and its first sublayer.*/ 这里是说 CAShapeLayer 是在其坐标系统内绘制贝塞尔曲线的。因此，使用 CAShapeLayer 需要与 UIBezierPath 一起使用。它有一个 path 属性，而 UIBezierPath 就是对 CGPathRef 类型的封装，因此这两者要配合起来用。 CAShapeLayer与drawRect的关系 drawRect ：属于 CoreGraphics 框架，占用 CPU ，性能消耗大，不建议重写 CAShapeLayer ：属于 CoreAnimation 框架，通过 GPU 来渲染图形，节省性能。动画渲染直接提交给手机 GPU ，不消耗内存这两者各有各的用途，而不是说有了 CAShapeLayer 就不需要 drawRect。温馨提示：drawRect只是一个方法而已，是 UIView 的方法，重写此方法可以完成我们的绘制图形功能。 CAShapeLayer与UIBezierPath的关系 CAShapeLayer中shape代表形状的意思，所以需要形状才能生效 贝塞尔曲线可以创建基于矢量的路径，而UIBezierPath类是对CGPathRef的封装 贝塞尔曲线给CAShapeLayer提供路径,CAShapeLayer在提供的路径中进行渲染。路径会闭环,所以绘制出了Shape 用于CAShapeLayer的贝塞尔曲线作为path，其path是一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线 - (void)viewDidLoad { [super viewDidLoad]; _triangleView = [[UIView alloc] initWithFrame:CGRectMake(screenWidth / 4, 200, screenWidth / 2, screenHeight / 2)]; _triangleView.backgroundColor = [UIColor orangeColor]; [self.view addSubview:_triangleView]; _triangleView.layer.mask = [self createMaskLayerWithView]; } - (CALayer *)createMaskLayerWithView { CGFloat viewWidth = CGRectGetWidth(_triangleView.frame); CGFloat viewHeight = CGRectGetHeight(_triangleView.frame); CGFloat rightSpace = 10.; CGFloat topSpace = 15.; // 起点 CGPoint point1 = CGPointMake(0, 0); // 绘制线条 CGPoint point2 = CGPointMake(viewWidth-rightSpace, 0); CGPoint point3 = CGPointMake(viewWidth-rightSpace, topSpace); CGPoint point4 = CGPointMake(viewWidth, topSpace); CGPoint point5 = CGPointMake(viewWidth-rightSpace, topSpace+10.); CGPoint point6 = CGPointMake(viewWidth-rightSpace, viewHeight); CGPoint point7 = CGPointMake(0, viewHeight); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point1]; [path addLineToPoint:point2]; [path addLineToPoint:point3]; [path addLineToPoint:point4]; [path addLineToPoint:point5]; [path addLineToPoint:point6]; [path addLineToPoint:point7]; [path closePath]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = path.CGPath; return layer; } CoreGraphics这是一个绘图专用的API族，它经常被称为QuartZ或QuartZ 2D。Core Graphics是iOS上所有绘图功能的基石，包括UIKit，Core Graphics是高度集成于UIView和其他UIKit部分，Core Graphics数据结构和函数可以通过前缀CG来识别。 步骤: 1.先在drawRect方法中获得上下文context； 2.绘制图形（线，图形，图片等）； 3.设置一些修饰属性； 4.渲染到上下文，完成绘图。 - (void)drawRect:(CGRect)rect { CGContextRef c = UIGraphicsGetCurrentContext(); CGContextSetRGBStrokeColor(c, 0.0, 0.0, 0.0, 1.0); // black CGContextSetLineWidth(c, 1); CGMutablePathRef bubblePath = CGPathCreateMutable(); // 这里的点是三角形的尖尖 CGPathMoveToPoint(bubblePath, NULL, self.frame.origin.x / 2, self.frame.origin.y); // 其中的一条边的终点 CGPathAddLineToPoint(bubblePath, NULL, 0, self.frame.size.height / 3); // 另一条边的终点 CGPathAddLineToPoint(bubblePath, NULL, self.frame.size.width, self.frame.size.height / 3); CGPathCloseSubpath(bubblePath); CGContextSaveGState(c); CGContextAddPath(c, bubblePath); CGContextClip(c); CGContextSetFillColorWithColor(c, [[UIColor blueColor] CGColor]); CGContextFillRect(c, self.bounds); CGPathRelease(bubblePath); } 注意事项: 1.绘图需要 CGContextRef,CGContextRef即图形上下文。可以这么理解，我们绘图是需要一个载体或者说输出目标，它用来显示绘图信息，并且决定绘制的东西输出到哪个地方。可以形象的比喻context就像一个“画板”，我们得把图形绘制到这个画板上。所以，绘图必须要先有context; 2.并不是说一提到绘图，就一定得重写drawRect方法，只是因为通常情况下我们一般采用在drawRect方法里获取context这种方式。 drawRect方法什么时候触发?当view第一次显示到屏幕上时;当调用view的setNeedsDisplay或者setNeedsDisplayInRect:方法时。 CGContextAddArcToPoint &amp;&amp; CGPathAddArcToPointCGContextAddArcToPoint与CGPathAddArcToPoint这两函数是根据两切线及角度来画弧度,设置弧度CGFloat radius。 画一个四个角都是圆角的矩形, - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. [self drawArcToPoint2]; } - (void)drawArcToPoint2 { //创建CGContextRef UIGraphicsBeginImageContext(self.view.bounds.size); CGContextRef gc = UIGraphicsGetCurrentContext(); //===绘画逻辑 === //创建用于转移坐标的Transform,如许我们不消遵守实际显示做坐标策画 CGAffineTransform transform = CGAffineTransformMakeTranslation(200,200); //创建CGMutablePathRef CGMutablePathRef path = CGPathCreateMutable(); //半径为10 CGFloat radius = 10; //初始点为(10, 0),起点要从10开始，否则，在左上角会出现线条 CGPathMoveToPoint(path, &amp;transform, 10, 0); //右上角和右下角两个点,画出半个圆角 CGPathAddArcToPoint(path, &amp;transform,200, 0, 200, 200, radius); //右下角,画出别的半个圆角 CGPathAddArcToPoint(path, &amp;transform,200, 200, 0, 200, radius); //左下角 CGPathAddArcToPoint(path, &amp;transform,0, 200, 0,0, radius); //左上角 CGPathAddArcToPoint(path, &amp;transform,0, 0, 200, 0, radius); //将CGMutablePathRef添加到当前Context内 CGContextAddPath(gc, path); [[UIColor grayColor] setFill]; [[UIColor blueColor] setStroke]; CGContextSetLineWidth(gc,2); //履行绘画 CGContextDrawPath(gc,kCGPathFillStroke); //从Context中获取图像,并显示在界面上 UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); UIImageView *imgView = [[UIImageView alloc] initWithImage:img]; [self.view addSubview:imgView]; } CAShapedLayer处理理论上我们可以构造出任意想要的形状，但是有些形状如果你不熟悉几何知识的话是构造不出正确path的，从代码上我们可以看到我们可以通过设置CALayer的contents属性来设置显示的内容，那我们是不是可以通过设置CAShapedLayer的contents来设maskLayer呢？答案是肯定的，代码如下： - (void)setup4 { CAShapeLayer *maskLayer = [CAShapeLayer layer]; maskLayer.fillColor = [UIColor blackColor].CGColor; maskLayer.strokeColor = [UIColor clearColor].CGColor; maskLayer.frame = self.bounds; maskLayer.contentsCenter = CGRectMake(0.5, 0.5, 0.1, 0.1); maskLayer.contentsScale = [UIScreen mainScreen].scale; //非常关键设置自动拉伸的效果且不变形 maskLayer.contents = (id)[UIImage imageNamed:@&quot;gray_bubble_right@2x.png&quot;].CGImage; CALayer *contentLayer = [CALayer layer]; contentLayer.mask = _maskLayer; contentLayer.frame = self.bounds; [self.layer addSublayer:_contentLayer]; } 遗留问题使用CGPathAddArcToPoint绘制带有箭头的弹窗菜单,如图， 在绘制四个边的圆角时，无法对应到特定的四个角的位置，导致绘制不出该效果的图片。 demoGithub ：https://github.com/XibHe/DrawTriangle 参考资料 绘图 iOS CAShapeLayer精讲 iOS绘图—— UIBezierPath 和 Core Graphics CGPathAddArc vs CGPathAddArcToPoint CGContextAddArcToPoint与CGPathAddArcToPoint iOS 不规则的ImageView CGPathAddArc vs CGPathAddArcToPoint –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"图形绘制","slug":"图形绘制","permalink":"http://XibHe.github.io/tags/图形绘制/"},{"name":"UIBezierPath","slug":"UIBezierPath","permalink":"http://XibHe.github.io/tags/UIBezierPath/"},{"name":"CGPathAddLineToPoint","slug":"CGPathAddLineToPoint","permalink":"http://XibHe.github.io/tags/CGPathAddLineToPoint/"},{"name":"CGPathAddArcToPoint","slug":"CGPathAddArcToPoint","permalink":"http://XibHe.github.io/tags/CGPathAddArcToPoint/"}]},{"title":"Harden your mind","date":"2017-03-30T16:00:00.000Z","path":"2017/03/31/Harden-your-mind/","text":"前段时间看了casa的直播《闲话iOS架构》，收看直播时，很多人在聊天里发言询问迅速提高技术有什么捷径?而casa的回答是多想多练。casa直播背景是一个书架，书架上摆满了书，中途一直有人发消息询问大神背后的书架都有什么书？给我最直观的感觉是大家很浮躁，总是想通过一种事半功倍的方式快速摘取成功果实，却忽略了平时的积累，正是这些小的积累，造就大的爆发。 《闲话iOS架构》提到的内容如下: 1.《批判性思维》 2.高效烧脑，低效伤身. 3.protocol,categary 4.注释一般写在垃圾代码那里。剩下的都是代码自注释 5.极致了，怎么保证扩展性?并不矛盾 6.框架ctmater? 7.reactive cocoa 8.APImanager 9.组件化 10.class template 12.OCLink 可以部分review 13.有if就要有else,逻辑上的，思维考虑的对称，不是强制代码必须要这样做 14.以前一直用shell 现在用swift REPL 15.架构的限制是指规范 16.组件化和模块化到底怎么区分，一个东东的不同叫法，实际上应该叫模块化 17.《Cocoa设计模式》 18.如何看待新技术, mvvm，Reactive cocoa，rac 19.没有最全面的技术，只有最合适的技术。 20.CTMediator组件化方案 21.CTNetwokring和YTKNetworking，离散型，集约型 22.codeReview 23.继承的缺点，破坏了代码结构 24.RN,weex 25.复用的东西拆成组件 26.《The Art of Capacity Planning》 27.腾讯开源的Mars,引出大一统和多元化， 28.网易，无埋点打log，网易乐得无埋点数据收集sdk casa所讲的内容多是通过平时代码积累得来的方法论，如果没有一定的代码积累和长期的项目实践是很难彻底理解这些内容的。iOS应用架构看着很高大上，但需要在牢固的基础之上一层层堆砌成高楼。忽视这些必要的步骤，一味粉饰自己，到头来也只是黄粱一梦一场空。再回过头来看目前国内知识付费现象，觉得是一个泡沫。正如知乎上所说，知识付费，抓的不是人的求知欲，抓的是人的焦虑感。人们焦虑，希望有人告诉他们捷径，如何更快的获得成功。这里莫名的想到成功学，成功的永远是成功学的讲师。当代知识产品最大的痛点就是:不看书。 我们急切的接受别人输出的价值观，却选择性的忽略掉自己的内心真正的诉求。书上得来总觉浅，听人道出方觉深，互补的只是不愿意努力看书或是去实践的懒惰。知识经济本质上就是粉丝经济的另一种表现形式。最后，还是想强调一下，作为一名攻城狮通过解决日常遇到的问题，或由浅而深，或发散思维都可以一步步引导至问题的核心。切忌自以为是，舍本逐末。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"Harden your mind","slug":"Harden-your-mind","permalink":"http://XibHe.github.io/tags/Harden-your-mind/"},{"name":"知识付费","slug":"知识付费","permalink":"http://XibHe.github.io/tags/知识付费/"}]},{"title":"待办事项提醒功能开发(二)","date":"2017-03-15T09:01:00.000Z","path":"2017/03/15/待办事项提醒功能开发(二)/","text":"新建数据库入库操作界面绘制通知log表注意事项 时间转化的时区设置 最近的本地通知最多只能有64个(待测试) 过期通知的移除(不做移除，通过通知的自有机制去处理的可行性) 生产日期，到期日，保质期天数的交互 奇妙清单的到期提醒只与提醒时间和频率有关，与是否到期无关 iOS 10之后的推送 Demo地址点击下载 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"待办事项提醒","slug":"待办事项提醒","permalink":"http://XibHe.github.io/tags/待办事项提醒/"},{"name":"开源","slug":"开源","permalink":"http://XibHe.github.io/tags/开源/"}]},{"title":"待办事项提醒功能开发(一)","date":"2017-03-13T14:50:06.000Z","path":"2017/03/13/待办事项提醒功能开发(一)/","text":"业务需求根据用户所添加某件商品的生产日期和保质期天数计算商品的过期日期，在过期前的时间内，用户可以设置提醒的具体时间点和提醒频次，系统根据用户设置的提醒时间和提醒频次通知用户某某商品该使用了。具体操作步骤如下: 新增一个提醒事项的名称，这个名称将作为待完成事项显示在任务列表中，可以快速勾选完成； 在保质期限一栏，点击生产日期一栏，弹出年月日的日期选择器用于日期的选择； 点击保质期天数一栏，弹出用于输入保质期天数的输入控件，保质期单位可以是天，月，年； 如果保质期为30天以内，默认开启智能保质期提醒；如果超过30天，则关闭智能提醒，需要有手动设置结束提醒的具体时间及提醒频率； 在提醒设置一栏，根据生产日期和保质期天数自动计算出到期的具体日期，用户点击时间一栏，弹出时间的选择控件用于选择触发提醒的时间点，用户也可以设置提醒频次； 需要考虑的技术点结合需求需要考虑如下几个问题: 本地通知的运行机制是什么？ 如何自定义通知的频率？ 如何移除到期的通知提醒？ 当用户编辑一个已经存在的提醒任务时，如何根据用户修改后的日期，频率等参数，更新现有的通知提醒频次，触发时间，日期等属性？ 当切换用户或者用户退出登录后，如何操作之前已经添加的通知提醒？ 通知提醒数据的持久化？ 本地通知相关点使用本地通知提醒用户，而本地通知有些地方在使用时需要注意,如下: 1.本地通知是有操作系统统一调度的，只有在应用退出到后台或者关闭才能收到通知；2.本地通知的数量是有限制的，最近的本地通知最多只能有64个，超过这个数量将被系统忽略；3.如果想要移除本地通知可以调用UIApplication的cancelLocalNotification:或cancelAllLocalNotifications移除指定通知或所有通知；4.通知对应的NScalendarunit属性，可以通过该属性操作提醒的频率； NScalendarunit的具体属性如下： typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) { NSCalendarUnitEra = kCFCalendarUnitEra, NSCalendarUnitYear = kCFCalendarUnitYear, NSCalendarUnitMonth = kCFCalendarUnitMonth, NSCalendarUnitDay = kCFCalendarUnitDay, NSCalendarUnitHour = kCFCalendarUnitHour, NSCalendarUnitMinute = kCFCalendarUnitMinute, NSCalendarUnitSecond = kCFCalendarUnitSecond, NSCalendarUnitWeekday = kCFCalendarUnitWeekday, NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, NSCalendarUnitQuarter NS_ENUM_AVAILABLE(10_6, 4_0) = kCFCalendarUnitQuarter, NSCalendarUnitWeekOfMonth NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfMonth, NSCalendarUnitWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfYear, NSCalendarUnitYearForWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitYearForWeekOfYear, NSCalendarUnitNanosecond NS_ENUM_AVAILABLE(10_7, 5_0) = (1 &lt;&lt; 15), NSCalendarUnitCalendar NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 20), NSCalendarUnitTimeZone NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 21), NSEraCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitEra instead&quot;) = NSCalendarUnitEra, NSYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitYear instead&quot;) = NSCalendarUnitYear, NSMonthCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitMonth instead&quot;) = NSCalendarUnitMonth, NSDayCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitDay instead&quot;) = NSCalendarUnitDay, NSHourCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitHour instead&quot;) = NSCalendarUnitHour, NSMinuteCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitMinute instead&quot;) = NSCalendarUnitMinute, NSSecondCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitSecond instead&quot;) = NSCalendarUnitSecond, NSWeekCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekOfMonth or NSCalendarUnitWeekOfYear, depending on which you mean&quot;) = kCFCalendarUnitWeek, NSWeekdayCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekday instead&quot;) = NSCalendarUnitWeekday, NSWeekdayOrdinalCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekdayOrdinal instead&quot;) = NSCalendarUnitWeekdayOrdinal, NSQuarterCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_6, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitQuarter instead&quot;) = NSCalendarUnitQuarter, NSWeekOfMonthCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitWeekOfMonth instead&quot;) = NSCalendarUnitWeekOfMonth, NSWeekOfYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitWeekOfYear instead&quot;) = NSCalendarUnitWeekOfYear, NSYearForWeekOfYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitYearForWeekOfYear instead&quot;) = NSCalendarUnitYearForWeekOfYear, NSCalendarCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitCalendar instead&quot;) = NSCalendarUnitCalendar, NSTimeZoneCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitTimeZone instead&quot;) = NSCalendarUnitTimeZone, }; 步骤说明使用sqlite3进行通知提醒相关数据的持久化。大概的思路如下： 新增提醒任务: 1.插入保质期提醒任务表2.插入通知表3.插入通知log表4.上传服务器通知提醒数据 编辑提醒任务： 1.更新保质期提醒任务表2.更新通知表3.更新通知log表4.上传服务器编辑后的通知提醒数据 需要注意本地通知的官方文档是否有最近的跟新 ，待续…… –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"开源","slug":"开源","permalink":"http://XibHe.github.io/tags/开源/"},{"name":"待办事项","slug":"待办事项","permalink":"http://XibHe.github.io/tags/待办事项/"}]},{"title":"第一次面试别人是怎样的体会","date":"2017-02-25T16:00:00.000Z","path":"2017/02/26/第一次面试别人是怎样的体会/","text":"不安的开始 自从去年后半年以来，iOS开发相关工作就被唱衰。很多人抱怨裸辞后找不到工作，可谓是哀鸿遍野。看到了太多这样的帖子，身边也有相识的人遭遇了公司解散，失业后迟迟找不到工作的窘境。这也直接导致了我内心的忐忑和不安，不禁要问，iOS从业者的未来在哪里？我又该何去何从呢？这样的疑问，这样的不安，一直伴随着我。在结合别人的现实的遭遇后，分析了一下造成现阶段初级，中级iOS从业者找工作难的原因: 市场过度饱和，培训机构追求自身利益，在iOS开发人员相对稀缺阶段，培训了大量的从业人员，扰乱了市场正常的供需关系，导致从业人员供大于需； 鱼龙混杂的从业者，很多开发者并不是科班出身，只是听说iOS开发者的薪资待遇高，才决定去培训机构学习，经过四五个月左右的强制灌输和培训机构的包装后，摇身一变成了具有两年开发经验的iOS开发者,其本身不具备计算机专业相关的基础知识； 资本市场资金的收紧，导致流向互联网领域的热钱迅速减少，相比前几年互联网行业的创业潮，很多创业者张口闭口我们是颠覆者，一定会替代某某某，只要嘴炮一番就能忽悠到投资人的钱，今年的资本市场回归了理性。那些没有清晰盈利模式的初创公司迅速倒闭，相关中小互联网公司的用人需求在萎缩； 市场需求的理性回归，很多培训班出身，或者工作年限不足三年，或者是一年工作经验用了三年的初中级开发者满足不了市场上很多公司对于中高级开发者相关的技术要求，于是，被市场无情的淘汰； 行业内薪资待遇的降低，iOS开发已经结束了早期因从业者稀少而造成的市场红利时期，进入到了一个稳步发展的相对稳定时期。因此，薪资待遇回归到了一个正常的水准。那些早期享受到这种红利的开发者，一时间接受不了薪资待遇的降低； 技术层面方面，iOS开发依托苹果提供的平台，该平台的封闭性决定了开发者所接触的技术面比较狭窄，脱离了苹果，不能完全胜任其他技术工作； 我所遇到的一个例子带着这些不安，对于已经结束的16年，我做了一份总结，也包括17年的一些计划。或许是心志不坚，或许是颓废太久，这种不安仍旧存在，直到上周面试了一个来公司应聘iOS开发的应聘者…… 周五下午，人事和我说能不能帮忙面试一下，本来是另一个项目组需要的人，但恰巧他们的负责人不在，就让我去面了。第一次面试别人还是有些紧张，好像自己第一次被别人面试一样紧张。但左等右等还是等不到人事通知我去面试，后来大概半小时后被人事告知那个来面试的人已经走了，据她说面试题只做了一半，人就走了，可能是被我们的面试题吓走了。但面试题我也看过，是四十道很基础的面试题呀！表示不解啊！本以为这次安排的面试就这样结束了，后来人事通知还有一个已经写完了面试题，在沙发区等着，于是我就开始了这次面试之旅。 短暂的两分钟的沉默，我简单看了一下他的简历，上面工作经验写着三年。心里便盘算着从哪些知识点入手可以探出对方是不是真的有三年工作经验。先是让对方做了一个简单的自我介绍，然后开始对着简历问一些问题，简历上写了四个项目，每个项目所用到的技术都是一些大众化的技术，比如，网络请求库AFNetworking，图片加载库SDWebImage，数据库FMDB，刷新库MJRefresh，适配库Masonry等各种三方库的使用。于是我便问了以下的问题: NSOperation与GCD的区别 GCD中如何避免死锁和数据竞争 Block的使用及如何避免循环引用 使用过哪些设计模式 单例，什么是单例，单例的作用 内存管理 网络请求库的使用 JS与原生应用是如何交互的 了解过RunTime吗 通知是异步还是同步 该如何对tableView进行优化，实现滑动的流畅性，以及如何避免tableView代理方法中冗长的代码 SDWebImage的运行机制 App中的多用户逻辑 如何实现一个可以循环滚动的轮播图(类似于京东，淘宝首页顶部效果) 给你一个新项目你会怎么做 是否能看一下你的技术博客或是GitHub上的开源项目 对方对上述问题的回答模棱两可，十分的模糊。其中涉及到GCD那块的问题，只说了用过，GCD的如何避免数据竞争和死锁，以及它与NSOperation的区别只是把什么是NSOperation用名词解释了一下，而对于Block的循环引用问题，支支吾吾想了半天回答的文不对题。设计模式是典型的MVC，倒是提到了MVVM，但这里也只是简单的提到，就没有什么下文了。单例的使用，边想边说，整了半天也没有将声明单例的具体方法说明白。内存管理这块，据他说，学iOS开发时MRC已经没人用了，他就直接用的ARC。JS与原生应用交互这块说没有用过。那么RunTime呢?说是底层的东西没有怎么了解过。tableView的优化方面，说是用的原生API的代理方法，这个还需要优化吗?SDWebImage的运行机制，把它的使用方法说了一遍。App中的多用户逻辑，说是服务器的事，客户端不需要考虑。轮播图功能的实现，说的是使用NSTimer。给你一个新项目你会怎么做，说的是先花一周进行需求分析，再新建工程，使用CocoaPods把那些要用到的三方库引入到工程中。问完了这些问题，我还是抱有一丝幻想的，心想也许是太过紧张了，再看看他做的项目吧！ 看了下对方手机上他参与开发的项目，是一些与美食推荐相关的项目，有一个已经停止维护，拉取不到任何数据了。剩下的都是一些数据使用tableView展示的普通项目，没有什么逻辑特别复杂或是需要使用很高明技术的功能。自此，我仍然没有放弃，心想或许对方还研究过其他的技术点，于是就问对方，是否能看一下你的技术博客或是GitHub上的开源项目。对方回答说，没有。此刻，我也只能道了两声谢谢，说有结果人事会通知你。心里想着，本来还想问有没有使用过Swift，可是现在看来，已经没有问的必要了。 结束 红利已经结束了，那个只要会使用tableView等常用控件就能找到工作的时代结束了。曾听一位前辈说过， “感觉每个做技术的一开始都是一粒沙子，不断修炼学习吸收营养变成大颗粒的沙子。 再学习其他东西把自己变成土块儿，时间是一把大筛子，每次过滤掉小沙粒，只留大块儿在上面，在你被筛掉之前要么变的比网眼大留下来，要么赶紧被筛掉转行吧!” 最后来个总结吧！猥琐发育，别浪！ –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"面试","slug":"面试","permalink":"http://XibHe.github.io/tags/面试/"},{"name":"心得体会","slug":"心得体会","permalink":"http://XibHe.github.io/tags/心得体会/"},{"name":"iOS开发没人要了","slug":"iOS开发没人要了","permalink":"http://XibHe.github.io/tags/iOS开发没人要了/"}]},{"title":"适配器模式初探","date":"2017-02-18T20:23:06.000Z","path":"2017/02/19/适配器模式初探/","text":"初衷解决ViewConctroller里冗余代码过多的问题，将公用模块抽离出来。这里将项目中用到的拍照，调用相册，录像，定位等功能单独抽离出来放在一起。 使用步骤 第一步: 定义一个delegate，用来返回一个遵守该协议的数据，不管传过来的数据是什么类型，只要服从这个协议，实现协议里的方法，就处理这个数据。 @protocol MediaHandleDelegate &lt;NSObject&gt; @optional - (void)returnMedidaData:(id)mediaData; @end 第二步: 创建继承于NSObject的根适配器类MediaHandleAct，该类遵守第一步中的协议，并实现该协议的方法，但只是空实现。 // MediaHandleAct.h #import &quot;MediaHandleDelegate.h&quot; @interface MediaHandleAct : NSObject { id &lt;MediaHandleDelegate&gt; _delegate; } // MediaHandleAct.m #import &quot;MediaHandleAct.h&quot; - (void)returnMedidaData:(NSString *)data{ } 第三步: 构建根适配器类MediaHandleAct中注册特定Action的方法，并获取注册的Action。 #import &lt;Foundation/Foundation.h&gt; #import &quot;MediaHandleDelegate.h&quot; @interface MediaHandleAct : NSObject { id &lt;MediaHandleDelegate&gt; _delegate; } // 动态注册新的Action + (void)registerMediaHandleAction:(MediaHandleAct *)mediaHandleAct andKey:(NSString *) actKey; // 获取注册的Action + (NSDictionary *)mediaHandleActions; // 传递Action的具体执行方法 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass; @end // MediaHandleAct.m #import &quot;MediaHandleAct.h&quot; static NSMutableDictionary * mediaHandleActs = nil; @implementation MediaHandleAct + (void)registerMediaHandleAction:(MediaHandleAct *)mediaHandleAct andKey:(NSString *)actKey { @synchronized(self){ if (!mediaHandleActs) { mediaHandleActs = [NSMutableDictionary dictionary]; [MediaHandleAct registerCommonAction]; } [mediaHandleActs setObject:mediaHandleAct forKey:actKey]; } } + (NSDictionary *)mediaHandleActions { NSDictionary * acts = nil; @synchronized(self){ if (!mediaHandleActs) { mediaHandleActs = [NSMutableDictionary dictionary]; [MediaHandleAct registerCommonAction]; } acts = mediaHandleActs; } return acts; } // 具体的执行方法 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass{ } @end synchronized 这个主要是考虑多线程的程序，这个指令可以将{ } 内的代码限制在一个线程执行，如果某个线程没有执行完，其他的线程如果需要执行就得等着。@synchronized 的作用是创建一个互斥锁，保证此时没有其它线程对self对象进行修改。这种机制确保了同一时刻对于每一个类，至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。一般在公用变量的时候使用，如单例模式或者操作类的static变量中使用。 第四步: 针对不同功能的类，创建继承于MediaHandleAct的类适配器。使用适配器的时候，分为类适配器和对象适配器。类适配器针对每一个数据类型或某个功能模块创建一个适配器，并继承于根适配器。 // 调用相册功能 #import &lt;Foundation/Foundation.h&gt; #import &quot;MediaHandleAct.h&quot; @interface MediaHandleAlbum : MediaHandleAct @property (nonatomic, assign) NSInteger maxCount; // 最多可添加照片数 // 注册Action + (void)load; @end // MediaHandleAlbum.m #import &quot;MediaHandleAlbum.h&quot; #import &quot;JKImagePickerController.h&quot; @interface MediaHandleAlbum ()&lt;JKImagePickerControllerDelegate&gt; { UIViewController * _parentController; } @end @implementation MediaHandleAlbum + (void)load { [MediaHandleAct registerMediaHandleAction:[[MediaHandleAlbum alloc] init] andKey:@&quot;album&quot;]; } #pragma mark - 拍照和调用相册功能 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass { _parentController = controller; _delegate = (id)callbackClass; UIActionSheet *actionSheet = [[UIActionSheet alloc] initWithTitle:nil delegate:(id)self cancelButtonTitle:nil destructiveButtonTitle:nil otherButtonTitles:@&quot;拍照&quot;,@&quot;从相册选择&quot;,@&quot;取消&quot;,nil]; [actionSheet showInView:_parentController.view]; } #pragma mark - ActionSheetDelegate - (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex { switch (buttonIndex) { case 0: { // 拍照 UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.sourceType = UIImagePickerControllerSourceTypeCamera; picker.editing = YES; picker.allowsEditing = YES; picker.delegate = (id)self; [_parentController presentViewController:picker animated:YES completion:nil]; break; } case 1: { // 调用相册 JKImagePickerController *imagePickerController = [[JKImagePickerController alloc] init]; imagePickerController.delegate = (id)self; imagePickerController.showsCancelButton = YES; imagePickerController.allowsMultipleSelection = YES; imagePickerController.minimumNumberOfSelection = 1; imagePickerController.maximumNumberOfSelection = self.maxCount; //imagePickerController.selectedAssetArray = self.photosView.assetsArray; UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:imagePickerController]; [_parentController presentViewController:navigationController animated:YES completion:NULL]; break; } default: break; } } #pragma mark - UIImagePickerControllerDelegate - (void) imagePickerController: (UIImagePickerController*)picker didFinishPickingMediaWithInfo: (NSDictionary*) info { [picker dismissViewControllerAnimated:YES completion:nil]; UIImage *edit = [info objectForKey:@&quot;UIImagePickerControllerEditedImage&quot;]; UIImage *originalImage = [info objectForKey:@&quot;UIImagePickerControllerOriginalImage&quot;]; CLog(@&quot; EditedImage %@ &quot;,NSStringFromCGSize(edit.size)); CLog(@&quot; OriginalImage %@ &quot;,NSStringFromCGSize(originalImage.size)); UIImage *aImage = edit; NSData * imageData = UIImageJPEGRepresentation(aImage,0.5); if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(returnMedidaData:)]) { NSArray * photos = @[imageData]; [_delegate returnMedidaData:photos]; } } - (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker { [picker dismissViewControllerAnimated:YES completion:nil]; } #pragma mark - JKImagePickerControllerDelegate - (void)imagePickerController:(JKImagePickerController *)imagePicker didSelectAsset:(JKAssets *)asset isSource:(BOOL)source { [imagePicker dismissViewControllerAnimated:YES completion:nil]; } - (void)imagePickerController:(JKImagePickerController *)imagePicker didSelectAssets:(NSArray *)assets isSource:(BOOL)source { [imagePicker dismissViewControllerAnimated:YES completion:nil]; CLog(@&quot;assets == %@&quot;,assets); NSMutableArray * photos = [[NSMutableArray alloc] init]; for (JKAssets * jkAssets in assets) { NSData * photoData = UIImageJPEGRepresentation(jkAssets.photo, 0.5); [photos addObject:photoData]; CLog(@&quot;groupPropertyID = %@, groupPropertyURL = %@, assetPropertyURL = %@, photo = %@&quot;,jkAssets.groupPropertyID,jkAssets.groupPropertyURL,jkAssets.assetPropertyURL,jkAssets.photo); } if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(returnMedidaData:)]) { [_delegate returnMedidaData:photos]; } } 第五步: 调用适配器。 MediaHandleAlbum * album = [[MediaHandleAct mediaHandleActions] objectForKey:@&quot;album&quot;]; album.maxCount = imageCount; [album performActionWichController:self callbackClass:self]; 适配器模式的优缺点优点: 耦合度低，可以扩展多种不同功能的适配样式。缺点: 代码量相应增多，文件增多。 源码下载地址 注意该Demo中使用调用相机，相册，录制视频的功能，当系统为iOS 10以上访问权限的设置有所不同，需要在工程中的plist文件中添加对应的描述。Demo中的plist，如图， 其他功能访问权限设置， iOS 10 - Changes in asking permissions of Camera, microphone and Photo Library causing application to crash –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://XibHe.github.io/tags/设计模式/"},{"name":"适配器","slug":"适配器","permalink":"http://XibHe.github.io/tags/适配器/"}]},{"title":"再见! 2016!","date":"2017-01-15T13:25:10.000Z","path":"2017/01/15/再见！2016/","text":"结婚2016年注定是不平凡的一年，我和花花（我媳妇的外号）在2月14日领的结婚证，这天也是西方的情人节。从这天起我要履行法律赋予我作为一个丈夫的责任和义务。我和花花是大学同学，相识六年，经历了种种磨难和阻力，最终走到了一起。她是我的福星，我的天使，没有花花的鼓励和支持我不敢想象我会变成什么样子。谢谢你包容我的时不时的坏脾气，容忍我的懒散，不思进取，选择和我在一起。承担起本不该属于你的忧愁和压力。我的挚爱，我的血肉。谢谢你一路的陪伴。 生子16年，给了我太多的惊喜和感动。我又办成了人生的另外一件大事—孕育下一代。我们家小宝贝的出生好似给我注入了一剂强心剂，让我感到内心无比的强大。前期的彷徨无措，以及不知该如何适应父亲这个新角色的焦躁不安随着我们家小宝贝的降生，被一扫而空。又是一个给我带来好运的小天使，每每想到小家伙那粉嫩的面庞，心中就为之躁动起来。他的一举一动都牵动着我，同时，也感到肩上的责任越来越重了。我会更加努力为你打下一片大大的疆土。我的小宝贝。 新工作因为种种原因，之前的公司主营业务出现了问题，于是，树倒猢狲散，我又开始了漫长的面试生涯。经过近一个月数十家公司的面试，最终入职了现在的公司。面试时也遇到很多自己之前没有深入去考录的问题，被打了几次脸之后，让我认识到自己的基础并不牢固，很多问题只有肤浅的认知。关于面试这一块的具体内容，需要整理成具体的内容，再发布到博客上，就当给自己提个醒，告诫自己前方还有一段很长的路要走。 新的工作，给我最大的感受就是流程上的统一与协调。在开发新版本前，会走一个需求分析-&gt;原型设计-&gt;需求评审-&gt;UI设计评审-&gt;制定开发计划-&gt;开发计划评审的流程。虽然起初感到繁琐，但对流程的把控可以形成有效的开发计划，掌握开发过程中不同的产出环节，随着对流程的适应以及团队磨合，最终这个流程的时间也会缩短。最重要的是当项目延期或是需求出现问题，可以追溯到流程中那个环节出现了问题。 刚接手现在正在做的这个项目时，觉得很烫手。不仅要面对开发进度的滞后，还要提防项目中随时可能出现的一些无以名状的Bug。觉得自己一个人有些力不从心，但又不得不咬牙顶上去。最终，通过不断加班加点的赶进度，不断的理解产品需求，迈过了这个坎。反而很享受这样解决问题的畅快，为自己以后填更大的坑积累的初始的经验。经过这五个多月的不断历练，最大的收货是：自己慢慢能把控好一个项目了。由最初的慌张，苦闷，到现在可以坦然的面对这些问题。在项目中对自己的要求更加严格了，对产品性能方面，有了一个基本的认识，并开始着手做一些性能上的优化工作。 家庭这半年时间，加班比较多，这就导致了陪在家人身边的时间少了很多。起初，我觉得我是在履行我养家糊口的责任，从这一点出发是无可厚非的。但事实上，我的家人更需要我的陪伴，我不能陪伴小家伙一天天的成长，是我作为父亲最大的遗憾；我不能换位思考，体谅我妻子带孩子的艰辛，是我作为丈夫的不称职。曾听说过一句话：把家当做事业来经营，把事业当做家来爱。如果真正做到了这句话所说的那样，那么家庭与工作二者之间就会找到平衡点，一切的矛盾将会迎刃而解。同时，沟通的不及时也会加剧这种矛盾，所以，今年无论工作再忙也要抽出时间关心下我的妻子和儿子，让她们能感受到我对她们的爱。 读书16年初，1月份读了一刀推荐的 《把时间当做朋友》 ，尝试从心智层面上控制自己，告别拖延症。开始尝试制定每个月的工作学习计划。4月初读了一刀推荐的 《Effective Objective-C 2.0:编写高质量iOS与OS X代码的52个高效方法》和 《Objective-C高级编程:iOS与OS X多线程和内存管理》 对编写高质量的代码，提高代码质量有了初步的了解，对线程底层实现的原理有了一个大概的轮廓。但看这两本书时，太着急了些，未能将书中的精髓全部掌握，同时，也遗留了很多一知半解的问题。今年计划再拿出半个月的时间回顾一下这两本书中未搞懂的内容。五月中旬看了 《GitHub入门与实践》 一书，书的内容很简单，浅显的讲了一下GitHub的原理和流程，如果想进一步了解Git的详细使用及具体操作，可以看Pro Git，GitBook上已经有第二版简体中文的翻译了。六月份还看了 &lt;&gt; 一书，不过是跳着看的，跳过了那些自己已经掌握的内容，看后，对现有知识进行了一些拓展。双十一的时候，在网上买了几本书，如下： 《传习录》 《编程珠玑》 《人类简史》 《软技能:代码之外的生存指南》 《Head First设计模式(中文版)》 《啊哈!算法》 《图解HTTP》 《黑客与画家》 这几本书里有之前听别人说起过的，也有一刀推荐的。这几本书中 《软技能:代码之外的生存指南》， 《啊哈!算法》， 《图解HTTP》这三本书已经看了有些日子了。这些书有些是对现有知识的拓展和升华，打破我固有的思维，有的是个人喜好。读书的时间，开始时是早上在公交车上看，有时看某一本书看得厌烦了，就换另一本书看。个人觉得看纯技术书籍时，可以根据自己的口味搭配一本非技术的书籍来一起读，这样可以缓解因长期看一本书而造成的疲劳和厌烦。 以前认为读书的时间是千方百计的挤出来的，现在看来这样的想法有失偏颇。当我想偷懒，放松下来时，或是想玩手机时，就在心里告诫自己用这些时间来看书，反复这样几次后，竟然发现在这些时间内，比我千方百计挤出来的时间看的书还多。看来平时的时间都被浪费在了这些琐碎，无意义的事情上了。 博客关于博客，16年初开始写，一直到7月份才写了第二篇文章，全年只写了7篇文章。很多想写的东西，都只是被记录下来，并没有梳理成一篇文章，最后，都化作了尘埃，消失不见了。最开始时，想着什么都往博客上写，但那样纯粹是为了凑字数，可读性并不强。浪费了自己的时间，也对读这篇博客的人造成了困扰。到后来，太过于浅显东西没有写的必要，未经深入研究的东西，或是从别处直接复制粘贴别人的观点。这些都不是在写博客，而是在记流水账。因此，给自己定下了一个三不写的要求: 所描述的内容，逻辑不清，不写 没有经过自己验证过的内容，不写 对别人没有帮助，只是在记流水账的内容，不写 2017年会继续坚持写博客，写那些真正经过自己深入研究过的东西，写那些日常项目中真正遇到并最终解决的问题，写对自己对别人有用的东西。只有这样才能提高文章的质量，付出的时间才能得到最大化的利用。 新技术16年8月初，学习了最新的Swift 3.0，当然，现在最新的是Swift 3.01。从官网下了The Swift Programming Language(Swift 3.01)，通过官网下载时会跳转到iBooks，但由于一些众所周知的原因，iBooks中国区是无法下载的，需要使用美区账号登录iBooks。可以结合极客学院Wiki简体中文翻译看。目前，自己只看到了 Functions 这章，17年还需要继续学习剩下的部分，再使用Swift编写一个具体的项目。17年计划学习一些热更新的技术，并计划在自己做的项目中使用一种热更新技术，实现动态化的修改项目中的代码。17年，希望自己能在iOS之外，能入门一种新的技术，拓宽自己的视野，达到自己心中设定的新的高度，看到之前看不到风景。 挑战17年是公司发展历程中重要的一年，也是我所在项目组所开发的项目大范围推广的一年，我们将迎来更多的用户，更大的并发量，会根据市场反应快速迭代产品。我们渴望在项目中使用新的技术，不断的提高用户体验，同时，又能不影响项目上线时间。希望我们产品被更多的人使用，得到大家的认可。同时，希望我们团队 永远年轻，永远热泪盈眶。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://XibHe.github.io/tags/年终总结/"},{"name":"2016","slug":"2016","permalink":"http://XibHe.github.io/tags/2016/"}]},{"title":"调试蓝牙扫码枪遇到的问题","date":"2016-12-06T10:31:54.000Z","path":"2016/12/06/iOS蓝牙开发简介  /","text":"iOS蓝牙开发简介蓝牙 4.0出现之前，蓝牙 2.0时只有iOS设备和苹果认证的MFI设备才可以被iOS设备检索到。蓝牙 4.0之后（硬件要4S，系统要iOS6以上才支持蓝牙 4.0），苹果开放了BLE(蓝牙4.0以低功耗著称，所以一般被称为BLE（bluetooth low energy））通道，没有MFI认证的蓝牙设备也可以连接非越狱的iOS设备了。 总结了一下，一共有五种方式可以实现蓝牙通信: 使用MFI认证的蓝牙模块的蓝牙产品 —— 开发使用ExternalAccessory框架，如果你的蓝牙模块还没设计，打算在AppStore上发布，打算使用蓝牙4.0以下（IOS设备都兼容），那你就抓紧找MFI认证的蓝牙模块吧。 使用苹果提供的CoreBluetooth framework框架 —— 只适用于支持蓝牙4.0的设备，无需越狱，无需使用MFI，可以发布在AppStore上。 GameKit framework —— 只能在iOS设备之间同一个应用内连接，从iOS7开始过期了，通过蓝牙可以实现文件的共享（仅限设备沙盒中的文件），此框架一般用于游戏开发（比如五子棋对战）。 Private API —— 使用私有API的应用程序不被允许在AppStore上发布。 Jailbreak 这里我使用的是第二种方式 —— CoreBluetooth。 核心概念CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类。 CBCentralManager：中心设备（用来连接到外部设备的管家） CBPeripheralManager：外部设备（第三方的蓝牙4.0设备） 这两组api分别对应不同的业务场景，左侧叫做中心模式，就是以你的app作为中心，连接其他的外设的场景，而右侧称为外设模式，使用手机作为外设别其他中心设备操作的场景。 服务和特征，特征的属性(service and characteristic):每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。 外设、服务、特征间的关系 连接测试检测蓝牙设备的连接强度，查询一定范围内的蓝牙设备列表。可以通过一款名为LightBlue的手机端软件来确定。在开启蓝牙的状态下，打开LightBlue搜索到当前范围内的设备列表，可以点击查看当前设备的UUID以及特征和服务的UUID，如图， 连接蓝牙扫码枪项目中需要连接蓝牙扫码枪，通过扫码枪扫描商品的条码，将得到的条码值传给终端设备。终端设备根据该条码值搜索该商品的全部信息。iPad开启蓝牙，通过设置蓝牙扫描枪，连接上iPad，但发现在调试状态下，并没有调用CBCentralManager的代理方法。使用LightBlue搜索当前范围内的蓝牙设备，无法找到当前连接到iPad上的蓝牙扫描枪。蓝牙扫描枪使用的是富立叶（cilico）ci6800这款。最后，看了产品说明，发现它的蓝牙模块是蓝牙2.0 + EDR。而不是最新的蓝牙4.0。在未做任何处理的情况下，iPad端任然可以所接收到扫码枪扫描条码后的到的码值。原来是扫码枪默认开启了HID模式，在该模式下iPad默认当前通过蓝牙连接的扫码枪为一个外接键盘，因此扫描后得到码值相当于通过敲击键盘输入。 这样也造成了一个问题，iPad上所有带有输入功能的操作，都无法通过点击输入框弹出软键盘。因为系统会将扫码枪当做键盘，所有软键盘的弹出或者隐藏都是通过扫码枪做操作。但事实上扫码枪并不能控制键盘的弹出。通过google找到了一种据说是可以解决该问题的方法点击查看。但该方法极不稳定，当扫码枪的连接状态在休眠/唤醒两种状态下来回切换时就会失效。偶尔会成功弹出键盘。 最后，在联系厂家需求帮助无果的情况下，不得不停止了该款扫码枪的适配。 连接蓝牙血压计为了验证自己的代码没有问题，是由于蓝牙扫码枪的蓝牙模块版本过低不支持CoreBluetooth。我又找来了一台据说支持蓝牙4.0的蓝牙血压计做测试。 代码实现的步骤 第一步，创建CBCentralManager。第二步，扫描可连接的蓝牙外设（必须在蓝牙模块打开的前提下）。第三步，连接目标蓝牙外设。第四步，查询目标蓝牙外设下的服务。第五步，遍历服务中的特性，获取特性中的数据或者保存某些可写的特性，或者设置某些特性值改变时，通知主动获取。第六步，在通知更新特性中值的方法中读取特性中的数据（再设置特性的通知为YES的情况下）。第七步，读取特性中的值。第八步，如果有可写特性，并且需要向蓝牙外设写入数据时，写入数据发送给蓝牙外设。 引入 CoreBluetooth头文件 #import &lt;CoreBluetooth/CoreBluetooth.h&gt; 声明属性 @property (nonatomic, strong) CBCentralManager *manager; @property (nonatomic, strong) CBPeripheral *peripheral; @property (strong ,nonatomic) CBCharacteristic *writeCharacteristic; @property (strong,nonatomic) NSMutableArray *nDevices; @property (strong,nonatomic) NSMutableArray *nServices; @property (strong,nonatomic) NSMutableArray *nCharacteristics; 遵守协议 @interface ViewController () &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt; 初始化数据 - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.manager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; _cbReady = false; _nDevices = [[NSMutableArray alloc]init]; _nServices = [[NSMutableArray alloc]init]; _nCharacteristics = [[NSMutableArray alloc]init]; count = 0; } 实现蓝牙的协议方法 (1)检查蓝牙状态 -(void)centralManagerDidUpdateState:(CBCentralManager *)central { switch (central.state) { case CBCentralManagerStatePoweredOn: { [self updateLog:@&quot;蓝牙已打开,请扫描外设&quot;]; [_activity startAnimating]; [_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@&quot;FFF0&quot;]] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }]; } break; case CBCentralManagerStatePoweredOff: [self updateLog:@&quot;蓝牙没有打开,请先打开蓝牙&quot;]; break; default: break; } } 注：[_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@”FF15”]] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }];中间的@[[CBUUID UUIDWithString:@”FFF0”]]是为了过滤掉其他设备，可以搜索特定标示的设备。 （2）检测到外设后，停止扫描，连接设备 //查到外设后，停止扫描，连接设备 -(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI { [self updateLog:[NSString stringWithFormat:@&quot;已发现 peripheral: %@ rssi: %@, UUID: %@ advertisementData: %@ &quot;, peripheral, RSSI, peripheral.identifier, advertisementData]]; _peripheral = peripheral; [_manager connectPeripheral:_peripheral options:nil]; [self.manager stopScan]; [_activity stopAnimating]; BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) { CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) { [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; } } if (!replace) { [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; } } （3）连接外设后的处理 //连接外设成功，开始发现服务 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]); [self updateLog:[NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]]; [self.peripheral setDelegate:self]; [self.peripheral discoverServices:nil]; [self updateLog:@&quot;扫描服务&quot;]; } //连接外设失败 -(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;%@&quot;,error); } -(void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;%s,%@&quot;,__PRETTY_FUNCTION__,peripheral); int rssi = abs([peripheral.RSSI intValue]); CGFloat ci = (rssi - 49) / (10 * 4.); NSString *length = [NSString stringWithFormat:@&quot;发现BLT4.0热点:%@,距离:%.1fm&quot;,_peripheral,pow(10,ci)]; [self updateLog:[NSString stringWithFormat:@&quot;距离：%@&quot;, length]]; } （4）发现服务和搜索到的Characteristice //已发现服务 -(void) peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ [self updateLog:@&quot;发现服务.&quot;]; int i=0; for (CBService *s in peripheral.services) { [self.nServices addObject:s]; } for (CBService *s in peripheral.services) { [self updateLog:[NSString stringWithFormat:@&quot;%d :服务 UUID: %@(%@)&quot;,i,s.UUID.data,s.UUID]]; i++; [peripheral discoverCharacteristics:nil forService:s]; if ([s.UUID isEqual:[CBUUID UUIDWithString:@&quot;FFF0&quot;]]) { BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) { CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) { [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; } } if (!replace) { [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; } } } } //已搜索到Characteristics -(void) peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error{ [self updateLog:[NSString stringWithFormat:@&quot;发现特征的服务:%@ (%@)&quot;,service.UUID.data ,service.UUID]]; for (CBCharacteristic *c in service.characteristics) { [self updateLog:[NSString stringWithFormat:@&quot;特征 UUID: %@ (%@)&quot;,c.UUID.data,c.UUID]]; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF01&quot;]]) { _writeCharacteristic = c; } if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) { [_peripheral readValueForCharacteristic:c]; [_peripheral setNotifyValue:YES forCharacteristic:c]; } } } } - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { [self updateLog:[NSString stringWithFormat:@&quot;已断开与设备:[%@]的连接&quot;, peripheral.name]]; } （5）获取外设发来的数据 //获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF02[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[1] == 0) { }else if (resultByte[1] == 1) { [self updateLog:@&quot;未知错误&quot;]; }else if (resultByte[1] == 2) { [self updateLog:@&quot;鉴权失败&quot;]; } } if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF04&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF04[%d] = %d\\n&quot;,i,resultByte[i]);} if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF05&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF05[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[0] == 0) { // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆撤防状态&quot;]; }else if (resultByte[0] == 1) { // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆设防状态&quot;]; } } } //中心读取外设实时数据 - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@&quot;Error changing notification state: %@&quot;, error.localizedDescription); } // Notification has started if (characteristic.isNotifying) { [peripheral readValueForCharacteristic:characteristic]; } else { // Notification has stopped // so disconnect from the peripheral NSLog(@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic); [self updateLog:[NSString stringWithFormat:@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic]]; [self.manager cancelPeripheralConnection:self.peripheral]; } } //用于检测中心向外设写数据是否成功 -(void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@&quot;=======%@&quot;,error.userInfo); [self updateLog:[error.userInfo JSONString]]; }else{ NSLog(@&quot;发送数据成功&quot;); [self updateLog:@&quot;发送数据成功&quot;]; } /* When a write occurs, need to set off a re-read of the local CBCharacteristic to update its value */ [peripheral readValueForCharacteristic:characteristic]; } 后记厂商一般会提供一份蓝牙血压计通信指令控制数据格式(通讯协议) 可根据该协议中定义的返回的十六进制数据，定义当前外设发送的不同数据的意义。最主要是用UUID来确定你要干的事情，特征和服务的UUID都是外设定义好的。我们只需要读取，确定你要读取什么的时候，就去判断UUID是否相符。 一般来说我们使用的iPhone都是做centralManager的，蓝牙模块是peripheral的，所以我们是want datas，需要接受数据。 判断状态为powerOn，然后执行扫描 停止扫描，连接外设 连接成功，寻找服务 在服务里寻找特征 为特征添加通知 通知添加成功，那么就可以实时的读取value[也就是说只要外设发送数据[一般外设的频率为10Hz]，代理就会调用此方法]。 处理接收到的value，[hex值，得转换] 之后就自由发挥了，在这期间都是通过代理来实现的，也就是说你只需要处理你想要做的事情，代理会帮你调用方法。[别忘了添加代理] 参考资料蓝牙相关基础知识 hacksugar: Bringing back the on-screen keyboard 蓝牙交互CoreBlueTooth iOS and bluetooth iOS蓝牙，CoreBluetooth框架简介及入门使用 想做iOS Bluetooth產品但又不想過MFI的討論 CoreBluetooth cannot find devices but iOS can 请教熟悉iOS的朋友一个问题 【译】iOS蓝牙编程指南 – 核心蓝牙概述 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"蓝牙开发","slug":"蓝牙开发","permalink":"http://XibHe.github.io/tags/蓝牙开发/"},{"name":"iOS BLE 开发","slug":"iOS-BLE-开发","permalink":"http://XibHe.github.io/tags/iOS-BLE-开发/"}]},{"title":"Masonry使用备忘","date":"2016-09-18T12:35:34.000Z","path":"2016/09/18/Masonry-Memo/","text":"记录使用 Masonry 过程中遇到的问题及解决方法，任何看似好用的框架在使用过程中都或多或少的有些瑕疵，解决问题的同时也会引入新的问题。 更新说明更新记录: 2016 年 09 月，第一版。 2018 年 07 月，补充关于使用Masonry更新坐标的问题。 2019 年 01 月，替换图片访问路径。 使用Masonry的场景在“我的”界面顶部区域用来展示用户的登录信息，顶部有两种样式的变换，即，由未登录—-&gt;已登录。如图所示， 其中头像区域是UIImageView，”登录/注册”是UILabel。登录成功后，头像区域会显示由服务器返回的头像地址生成的图片，并且其位置发生变化，不在居中显示，显示”登录/注册”的UILabel变为显示用户昵称，并且坐标位置发生改变。如图所示， 我的问题来了，在设置头像和标题位置时使用mas_remakeConstraints设置二者的约束，代码如图， 当从未登录切换到已登录时，已登录的头像位置会发生改变，变得特别大，不受约束控制。控制台会报如下错误， 刚开始没有意识到改变UIImageView的约束导致的新旧两种约束冲突造成的问题。在一个小时未解决该问题后，放弃了使用Masonry，改为使用代码做布局。今天，再回头看看这个问题，联想到忽略了什么东西，就打开Masonry文档从头开始仔细往下看，结果就看到了这句话， Sometimes you need modify existing constraints in order to animate or remove/replace constraints. In Masonry there are a few different approaches to updating constraints. 文档上列举了三种修改现有约束的方法， References你可以引用一个特定约束条件的约束，使表达式的结果分配给一个局部变量或一个类属性。 mas_updateConstraints作为一种选择，如果你只是去更新固有的约束值，你可以使用mas_updateConstraints这种便利的方法替换mas_makeConstraints。 mas_remakeConstraintsmas_updateConstraints用于更新一组约束，但要做那些费力的超出超出常量值的约束更新。这时就需要选择mas_remakeConstraints。mas_remakeConstraints类似于mas_updateConstraints，但它不是更新常量值，当再次为这些已经存在约束的视图设置约束前，它会移除掉该视图上的所有约束。这就让你可以为视图设置新的约束，而不用考虑移除之前已经存在的其他约束。 于是，我使用文档中提到的第三种方法，将所有的mas_makeConstraints换成了mas_remakeConstraints，就解决了约束错乱的问题。 使用Masonry后获取坐标值为0的问题加载页面头部会留白，如图， 1. 实际上是由于头部切换视图的的 width 为 0 导致。由于使用 Masonry 设置的头部视图，[self.tabView mas_makeConstraints:^(MASConstraintMaker *make) { make.left.top.right.equalTo(self.view); make.height.mas_equalTo(kTitleMenuTotalHeight); }]; 2. 在 self.tabView 的初始化类中的set方法里，需要再次设置它的位置，CGFloat totalTabW = self.width &gt; self.headerArray.count * kTitleMenuItemWidth ? self.headerArray.count * kTitleMenuItemWidth : self.width; [self.tabView mas_remakeConstraints:^(MASConstraintMaker *make){ make.top.equalTo(self);make.bottom.equalTo(self.dividerLineView. mas_top).offset(-0.5); make.centerX.equalTo(self); make.width.mas_equalTo(totalTabW); }]; 这里的 self.width 获取为 0，需要在完成 第1步 操作后，添加下面这行代码，即可获取到 self.tabView 的坐标值， //立即获取到frame [self.view layoutIfNeeded]; -layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews） layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout。根据Apple官方文档，layoutIfNeeded方法应该是这样的，layoutIfNeeded遍历的不是superview链，应该是subviews链。 参考文档Masonry使用 iOS - layoutSubviews总结 造成这个问题的主要原因是我没有认真看Masonry的文档，文档上说的已经很清楚了。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"Masonry","slug":"Masonry","permalink":"http://XibHe.github.io/tags/Masonry/"},{"name":"iOS适配","slug":"iOS适配","permalink":"http://XibHe.github.io/tags/iOS适配/"}]},{"title":"记一个关于线程的错误","date":"2016-09-11T15:23:34.000Z","path":"2016/09/11/记一个关于线程的错误/","text":"上周遇到一个问题，当前页面为一个UIWebView，当点该WebView上某个按钮进入下一个页面时，再通过该页面顶部返回按钮返回时，程序就会崩溃。（在开启了全局断点的情况下）控制台会输出如下提示： 程序崩溃在将要消失时，控制台给出 This application is modifying the autolayout engine from a background thread,whinch can lead to engine corruption and weird crashes.This will cause an exception in a future release. 的报错。 根据提示认为是后台线程在更新UI布局时，webView与JS的交互也在此时进行。交互操作会阻塞UI的显示及刷新。因此，又回到了一个老生常谈的准则上来了， 要在主线程刷新UI布局 。在调用本地应用于H5交互的方法时，要放到主线程中。 #pragma mark - 跳转购物车 - (void)goCart:(NSString *)shopNum { CLog(@&quot;jsString = %@&quot;,shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum]; dispatch_async(dispatch_get_main_queue(), ^{ [self.navigationController popToRootViewControllerAnimated:NO]; MallHomeViewController *mallHome = [LYSingle sharedSingle].mallVC; [mallHome setCurrentSelectIndex:3]; }); } #pragma mark - 商品上架(未开通店铺不能上架) - (void)cannotShelves { CLog(@&quot;cannotShelves&quot;); UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;要在主线程刷新UI&quot; delegate:self cancelButtonTitle:@&quot;我知道了&quot; otherButtonTitles:nil]; dispatch_async(dispatch_get_main_queue(), ^{ [alertView show]; }); } –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"线程","slug":"线程","permalink":"http://XibHe.github.io/tags/线程/"},{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://XibHe.github.io/tags/iOS多线程/"}]},{"title":"使用 cocoapods 时遇到的错误及错误的解决方案","date":"2016-08-21T07:58:00.000Z","path":"2016/08/21/关于cocoapod的二三事/","text":"1.The dependency AFNetworking (= 2.6.3) is not used in any concrete target.在cocoapods version 1.0 之后，默认生成的Podfile文件类似于 pod &#39;Alamofire&#39;, &#39;~&gt; 3.1.4&#39; pod &#39;SwiftyJSON&#39;, &#39;~&gt; 2.3.2&#39; 这样的默认设置。为了不发生如标题那样的错误，需要手动用 target “TargetName” do end 把需要 pod 的库包括进来。 target &quot;TargetName&quot; do pod &#39;Alamofire&#39;, &#39;~&gt; 3.1.4&#39; pod &#39;SwiftyJSON&#39;, &#39;~&gt; 2.3.2&#39; end 2.ios None of your spec sources contain a spec satisfying the dependency: IQKeyboardManager (~&gt; 4.0.0).报这个错误，可能是由于Cocoapods的配置库有损坏，Cocoapods建议删除本地副本重新clone。根据cocoapods官方博客的方案，在终端做出如下操作 (依照次序) 第一步: sudo rm -fr ~/Library/Caches/CocoaPods &amp;&amp; \\ 第二步: $ sudo rm -fr ~/.cocoapods/repos/master gem update --system &amp;&amp; \\ gem update &amp;&amp; \\ gem cleanup &amp;&amp; \\ pod setup 参考资料Pod install displaying error in cocoapods version 1.0.0.beta.1 intergating New Firebase.. error cocoapods pod repo update does not happen error in cocoapods Repairing Our Broken Specs Repository –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"cocoapod","slug":"cocoapod","permalink":"http://XibHe.github.io/tags/cocoapod/"}]},{"title":"关于iOS 7 Background Remote Notification(推送唤醒)","date":"2016-08-09T15:30:48.000Z","path":"2016/08/09/iOS 7 Background Remote Notification/","text":"更新说明更新记录: 2016 年 8 月，第一版 2017 年 8 月，增加配置极光推送的注意事项 Background Remote Notification简介Remote Notifications是 iOS7 在推送方面最大的变化，它允许应用收到通知后在后台（background）状态下运行一段代码，可用于从服务器获取内容更新。功能使用场景：（多媒体）聊天，Email更新，基于通知的订阅内容同步等功能，提升了终端用户的体验。 如何设置Remote notifications客户端设置需要在Xcode 中修改应用的 Capabilities 开启Remote notifications，如图： 当注册了Backgroud Modes -&gt; Remote notifications 后，notification 处理函数一律切换到下面函数，后台推送代码也在此函数中调用。 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler 这个函数也是iOS8之后获取远程推送调用的方法。 服务端设置 这个很重要，推送消息携带 content-available: 1 是Background 运行的必须参数，如果不携带此字段则与iOS7 之前版本的普通推送一样。服务端payload格式:aps增加content-available字段，类似于： payload example: {&quot;aps&quot;:{&quot;alert&quot;:&quot;example&quot;, &quot;sound&quot;:&quot;default&quot;, &quot;badge&quot;: 1, &quot;category&quot;:&quot;reply&quot;,&quot;content-available&quot;:&quot;1&quot; }} 这里集成的是极光推送，参考极光推送 Push API v3 的文档，发现了iOS 平台上发送 APNS 通知的规范。其中支持的字段中关键字 content-available 的类型为 boolean 。如果该字段为 true 说明是 Background Remote Notification ，如果不携带此字段则是普通的 Remote Notification 。这里需要特别注意的是服务器在配置 content-available: ture 时的正确性。如图，后台以java为例。 尚未传图 最后，当应用在后台挂起时，发起一个 Background Remote Notification(推送唤醒) 。客户端获取的数据，如下: userInfo = { &quot;_j_msgid&quot; = 2632357907; aps = { alert = &quot;\\U6717\\U81f4\\U96c6\\U56e2\\U9738\\U5dde\\U5e02(\\U53bf\\U7ea7)\\U603b\\U4ee3\\U7406\\U5546\\U5bb6\\U60a8\\U597d\\Uff01\\U60a8\\U7684\\U5e97\\U94fa\\U53c8\\U6709\\U65b0\\U8ba2\\U5355\\U4e86\\Uff0c\\U8ba2\\U5355\\U53f73cef6682b73ca,\\U8bf7\\U53ca\\U65f6\\U767b\\U5f55\\U5546\\U57ce\\U8fdb\\U884c\\U8ba2\\U5355\\U5ba1\\U6838\\U3002&quot;; badge = 1; category = identifier; sound = default; content-available = 1; }; } 参考资料极光客户端SDk教程 极光服务器端Push API v3 三种方式使得iOS应用能够在后台进行数据更新和下载 配置极光推送的注意事项使用极光测试生产环境下的推送时，发现无论通过我们自己的后台还是极光的后台使用Register ID发送通知，手机都无法收到通知。而在开发环境下是可以收到的。后来查了下极光文档中使用JPush iOS SDK注意事项: 如果你是直接运行安装到测试设备（运行调试状态），那你的安装的应用的证书环境只有可能是开发环境或者通配的。 而我恰恰是通过Xcode装的程序。 生产环境的正确测试姿势 常见问题-JPush合集 后记关于 Background Remote Notification(推送唤醒) 早在一年前就使用过，当时调研调试花费了大量时间。没想到现在又遇到了这个问题。结果，我又在阴沟里翻了船。可见做笔记，写博客总结的重要性。希望第三次闭着眼睛就能跳过这个坑。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"}]},{"title":"Objective-C与JS交互","date":"2016-07-12T16:00:00.000Z","path":"2016/07/13/JavaScriptCoreMutualH5/","text":"更新说明更新记录: 2016 年 7 月，第一版。 2017 年 8 月，增加OC调用JS方法相关介绍。 JavaScriptCore简介JavaScriptCore是iOS7引入的新功能，使用JavaScriptCore后可以实现js代码与本地native代码进行相互调用。 要使用JavaScriptCore，首先我们需要引入它的头文件 #import &lt;JavaScriptCore/JavaScriptCore.h&gt; 这个头里面引入了几个重要的对象 #import &quot;JSContext.h&quot; #import &quot;JSValue.h&quot; #import &quot;JSManagedValue.h&quot; #import &quot;JSVirtualMachine.h&quot; #import &quot;JSExport.h&quot; JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口 JSValue是JSContext执行后的返回结果，他可以是任何js类型（比如基本数据类型和函数类型，对象类型等），并且都有对象的方法转换为native对象。 JSManagedValue是JSValue的封装，用它可以解决js和原声代码之间循环引用的问题 JSVirtualMachine 管理JS运行时和管理js暴露的native对象的内存 JSExport是一个协议，通过实现它可以完成把一个native对象暴漏给js 具体的交互过程可以参见这篇博客https://imciel.com/2016/06/18/oc-js-communication/ OC与JS交互的方式OC与js交互，主要涉及到两方面: OC调用JS方法，将本地JS需要的值传递过去，供JS函数调用； JS调用OC的native方法，将JS函数中的返回值传递给本地方法，执行相应操作；下面将针对以上两条交互方式，展开来说。OC调用JS方法通过UIWebView展示JS页面，在UIWebView的代理方法中通过执行stringByEvaluatingJavaScriptFromString方法将JS代码执行结果以字符串方式返回， - (void)webViewDidFinishLoad:(UIWebView *)webView { NSString *text = aControl.titleLabel.text; NSString *jsMethod = [NSString stringWithFormat:@&quot;ocScrollToElementByName(&#39;%@&#39;)&quot;, text]; [self.contentView stringByEvaluatingJavaScriptFromString:jsMethod]; } 也可以在当前加载webView页面类的 - (void)viewWillAppear:(BOOL)animated 方法中调用JS方法，执行相关操作，如: 传递参数 // JS交互，传gid,刷新JS页面商品数量 NSString *gid = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;GoodInfoH5Gid&quot;]; if (gid &amp;&amp; gid.length &gt; 0) { NSString *jsMethod = [NSString stringWithFormat:@&quot;updateGoodNum(&#39;%@&#39;)&quot;,gid]; [_webView stringByEvaluatingJavaScriptFromString:jsMethod]; } 局部刷新列表 // 局部刷新 [_webView stringByEvaluatingJavaScriptFromString:@&quot;updatecartnumAndTotalPay()&quot;]; JS调用OC的native方法通过JavaScriptCore进行交互，需要在webView的加载完成的代理方法中设置交互上下文-JSContext,并将JS中的交互对象赋给当前类。下面将叙述如何使用JSExport设置引用名称来进行交互，使用JSExport引用名称空间后，对于调用了哪些JS方法就一目了然了。 JSExport引用名称空间交互设置js那边统一使用一个名为jsObject的对象来调用js的方法进行传值或触发某一特定的事件。在 js 中定义一个方法: &lt;html&gt; &lt;head&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function setContent(){ jsObject.shopCartNumChanged(totalNum); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;javascript:setContent(&#39;ios is: &#39; + typeof ios)&quot;&gt; &lt;/body&gt; &lt;/html&gt; 当点击 js 界面上的一个 “+” 号时，js 那边会查找 OC 代码通过JSContext注册的名为jsObject.shopCartNumChanged的调用方法。现在问题来了，在 OC 中该如何注册该方法呢?答案是使用语言穿梭机—JSExport协议。比如，我有一个 ShopCarViewController 的类。在.h中声明一个名为 MallJSExports 的协议。 // ShopCarViewController.h #import &lt;JavaScriptCore/JavaScriptCore.h&gt; @protocol MallJSExports &lt;JSExport&gt; - (void)shopCartNumChanged:(NSString*)shopNum; //购物车数量变化 - (void)orderGoBackToNative; //订单返回按钮 @end @interface ShopCarViewController : MallViewController @end 在.m中当然要声明并实现该协议的方法。 @interface ShopCarViewController()&lt;UIWebViewDelegate,MallJSExports&gt;{ } @property (nonatomic, strong) UIWebView *webView; @property (nonatomic, copy) NSString *shopNum; //商品数量 @end @implementation ShopCarViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. self.navigationItem.title = @&quot;购物车&quot;; _webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, screenWidth, self.view.height-49)]; [_webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:_webUrl]]]; _webView.delegate = self; _webView.detectsPhoneNumbers = NO; [self.view addSubview:_webView]; } #pragma mark - 在webView加载完成的代理方法里设置JSContext - (void)webViewDidFinishLoad:(UIWebView *)webView { //JS上下文对象 JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; context[@&quot;jsObject&quot;] = self; } #pragma mark - 购物车数量变化 - (void)shopCartNumChanged:(NSString *)shopNum { CLog(@&quot;jsString shopNum = %@&quot;,shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum]; } #pragma mark - 订单返回按钮 - (void)orderGoBackToNative { [self.navigationController popViewControllerAnimated:YES]; } 这里要注意的是 context[@ “jsObject” ] = self 中的的key值是和服务器商量好的, 即， js 中定义的回调方法 jsObject.shopCartNumChanged( )相一致。 在这里对 JSExport 的使用只是简单的设置了一下命名空间，将下标方法暴露给js对象方便服务器调用。其实， JSExport 协议主要用途是把objc复杂对象转换成JSValue并暴露给js对象。 JSExport 作为两种语言的互通协议。 JSExport 中没有约定任何的方法，连可选的(@optional)都没有，但是所有继承了该协议(@protocol)的协议（注意不是Objective-C的类(@interface)）中定义的方法，都可以在JSContext中被使用。 补充关于使用WKWebView进行交互。调用JS函数: [self.wkwebView evaluateJavaScript:@&quot;refreshList()&quot; completionHandler:^(id _Nullable rr, NSError * _Nullable error) { }]; 参考资料使用 JavaScriptCore 实现 JS和OC间的通信 JavaScriptCore框架在iOS7中的对象交互和管理 iOS JavaScriptCore使用 示例代码下载Demo –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"JavaScriptCore","slug":"JavaScriptCore","permalink":"http://XibHe.github.io/tags/JavaScriptCore/"},{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"},{"name":"iOS与JS交互","slug":"iOS与JS交互","permalink":"http://XibHe.github.io/tags/iOS与JS交互/"}]},{"title":"路开始的地方","date":"2016-01-16T04:04:48.000Z","path":"2016/01/16/summary/","text":"特别鸣谢老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！并附上他的博客地址 前言博客页面的搭建是在2015年6月15日，在老郭的指导下完成的。搭建博客的初衷完全是因为看到别人都有博客，而且界面很炫，为了自己的虚荣心才觉得自己也要整一个这样的博客。可是等到自己动手的时候，完全无从下手。什么是Hexo，Homebrew，MarkDown等等。这些都没有听说过。还好有老郭，他手把手的教我如何去配置这些东东。那时候觉得自己好2B。最后，倒是整出来了，看到了久违的Hello World，还是当年的配方，还是熟悉的味道。好吧，我承认我只是一时的冲动和虚荣心在作怪，我的博客在2015年6月15日止步于Hello World，从此，再也没有爬起来过。 自己思考原来就是件很快乐的事情，而教别人思考则是学习思考，锻炼思维的最好办法。 为什么写博客或许我并不是一个喜欢记录，总结的人。但还是因为工作的原因(每个周五都要发一份周报给老大)，还是养成了一个记录的习惯。我把周一到周五每天都做了什么事情，记录在一个黑色的笔记本上。 把那些未经整理的，杂乱无章的，解决的问题的过程和代码复制到了印象笔记上。以备以后查阅方便。遇到类似的问题就打开笔记，复制出一份代码。也未深究这段代码的意义何在，为什么可以解决问题。久而久之，便不会思考，真的就成为了代码的搬运工了。没有了思考，发现不了自己的短板，便陷在了这样一种自我满足的境地当中了。每天看似在前进，实际上是在原地绕弯。日复一日，剩下的只有惶恐和迷茫。变得越来越不自信。杂乱无章的笔记和随处存放的代码片段并不能引导我去思考制造这些Bug的原因。我要思考，要分享我的思考过程，希望得到别人认可的同时也能指出我的不足和错误。 解决问题的核心思想只有一个———一切都靠积累。 博客的开始回顾过去的2015年，我已经在新公司待了快一年了，虽然，不知道自己究竟都有哪些提升。但是，冥冥中又觉得自己还是有些收获的。当然这些收获都来自于师傅他老人家的谆谆教导。我不想忘记那些和师傅一起加班的日日夜夜里所带来的收获，我要把这些冥冥中的收获写下来，记录我在这些项目中的收获，以及那些尚未解决的问题所留下的遗憾。 期望以后能弥补这些遗憾。留住这些青春的记忆。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"路的开始","slug":"路的开始","permalink":"http://XibHe.github.io/tags/路的开始/"}]}]