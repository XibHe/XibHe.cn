[{"title":"再见! 2016!","date":"2017-01-15T13:25:10.000Z","path":"2017/01/15/再见！2016/","text":"结婚2016年注定是不平凡的一年，我和花花（我媳妇的外号）在2月14日领的结婚证，这天也是西方的情人节。从这天起我要履行法律赋予我作为一个丈夫的责任和义务。我和花花是大学同学，相识六年，经历了种种磨难和阻力，最终走到了一起。她是我的福星，我的天使，没有花花的鼓励和支持我不敢想象我会变成什么样子。谢谢你包容我的时不时的坏脾气，容忍我的懒散，不思进取，选择和我在一起。承担起本不该属于你的忧愁和压力。 我的挚爱，我的血肉。谢谢你一路的陪伴。# 生子16年，给了我太多的惊喜和感动。我又办成了人生的另外一件大事—孕育下一代。我们家小宝贝的出生好似给我注入了一剂强心剂，让我感到内心无比的强大。前期的彷徨无措，以及不知该如何适应父亲这个新角色的焦躁不安随着我们家小宝贝的降生，被一扫而空。又是一个给我带来好运的小天使，每每想到小家伙那粉嫩的面庞，心中就为之躁动起来。他的一举一动都牵动着我，同时，也感到肩上的责任越来越重了。我会为你打下一片大大的疆土。我的小宝贝。# 新工作因为种种原因，之前的公司主营业务出现了问题，于是，树倒猢狲散，我又开始了漫长的面试生涯。经过近一个月数十家公司的面试，最终入职了现在的公司。面试时也遇到很多自己之前没有深入去考录的问题，被打了几次脸之后，让我认识到自己的基础并不牢固，很多问题只有肤浅的认知。关于面试这一块的具体内容，需要整理成具体的内容，再发布到博客上，就当给自己提个醒，告诫自己前方还有一段很长的路要走。新的工作，给我最大的感受就是流程上的统一与协调。在开发新版本前，会走一个需求分析-&gt;原型设计-&gt;需求评审-&gt;UI设计评审-&gt;制定开发计划-&gt;开发计划评审的流程。虽然起初感到繁琐，但对流程的把控可以形成有效的开发计划，掌握开发过程中不同的产出环节，随着对流程的适应以及团队磨合，最终这个流程的时间也会缩短。最重要的是当项目延期或是需求出现问题，可以追溯到流程中那个环节出现了问题。刚接手现在正在做的这个项目时，觉得很烫手。不仅要面对开发进度的滞后，还要提防项目中随时可能出现的一些无以名状的Bug。觉得自己一个人有些力不从心，但又不得不咬牙顶上去。最终，通过不断加班加点的赶进度，不断的理解产品需求，迈过了这个坎。反而很享受这样解决问题的畅快，为自己以后填更大的坑积累的初始的经验。经过这五个多月的不断历练，最大的收货是：自己慢慢能把控好一个项目了。由最初的慌张，苦闷，到现在可以坦然的面对这些问题。在项目中对自己的要求更加严格了，对产品性能方面，有了一个基本的认识，并开始着手做一些性能上的优化工作。# 家庭这半年时间，加班比较多，这就导致了陪在家人身边的时间少了很多。起初，我觉得我是在履行我养家糊口的责任，从这一点出发是无可厚非的。但事实上，我的家人更需要我的陪伴，我不能陪伴小家伙一天天的成长，是我作为父亲最大的遗憾；我不能换位思考，体谅我妻子带孩子的艰辛，是我作为丈夫的不称职。曾听说过一句话：把家当做事业来经营，把事业当做家来爱。如果真正做到了这句话所说的那样，那么家庭与工作二者之间就会找到平衡点，一切的矛盾将会迎刃而解。同时，沟通的不及时也会加剧这种矛盾，所以，今年无论工作再忙也要抽出时间关心下我的妻子和儿子，让她们能感受到我对她们的爱。# 读书16年初，1月份读了一刀推荐的 &lt;&lt;把时间当做朋友&gt;&gt; ，尝试从心智层面上控制自己，告别拖延症。开始尝试制定每个月的工作学习计划。4月初读了一刀推荐的 &lt;&gt; 和 &lt;&gt; 对编写高质量的代码，提高代码质量有了初步的了解，对线程底层实现的原理有了一个大概的轮廓。但看这两本书时，太着急了些，未能将书中的精髓全部掌握，同时，也遗留了很多一知半解的问题。今年计划再拿出半个月的时间回顾一下这两本书中未搞懂的内容。五月中旬看了 &lt;&gt; 一书，书的内容很简单，浅显的讲了一下GitHub的原理和流程，如果想进一步了解Git的详细使用及具体操作，可以看Pro Git，GitBook上已经有第二版简体中文的翻译了。六月份还看了 &lt;&gt; 一书，不过是跳着看的，跳过了那些自己已经掌握的内容，看后，对现有知识进行了一些拓展。双十一的时候，在网上买了几本书，如下： &lt;&lt;传习录&gt;&gt; &lt;&lt;编程珠玑&gt;&gt; &lt;&lt;人类简史&gt;&gt; &lt;&lt;软技能:代码之外的生存指南&gt;&gt; &lt;&gt; &lt;&lt;啊哈!算法&gt;&gt; &lt;&lt;图解HTTP&gt;&gt; &lt;&lt;黑客与画家&gt;&gt; 这几本书里有之前听别人说起过的，也有一刀推荐的。这几本书中 &lt;&lt;软技能:代码之外的生存指南&gt;&gt; ， &lt;&lt;啊哈!算法&gt;&gt; ， &lt;&lt;图解HTTP&gt;&gt; 这三本书已经看了有些日子了。这些书有些是对现有知识的拓展和升华，打破我固有的思维，有的是个人喜好。读书的时间，开始时是早上在公交车上看，有时看某一本书看得厌烦了，就换另一本书看。个人觉得看纯技术书籍时，可以根据自己的口味搭配一本非技术的书籍来一起读，这样可以缓解因长期看一本书而造成的疲劳和厌烦。 以前认为读书的时间是千方百计的挤出来的，现在看来这样的想法有失偏颇。当我想偷懒，放松下来时，或是想玩手机时，就在心里告诫自己用这些时间来看书，反复这样几次后，竟然发现在这些时间内，比我千方百计挤出来的时间看的书还多。看来平时的时间都被浪费在了这些琐碎，无意义的事情上了。 博客关于博客，16年初开始写，一直到7月份才写了第二篇文章，全年只写了7篇文章。很多想写的东西，都只是被记录下来，并没有梳理成一篇文章，最后，都化作了尘埃，消失不见了。最开始时，想着什么都往博客上写，但那样纯粹是为了凑字数，可读性并不强。浪费了自己的时间，也对读这篇博客的人造成了困扰。到后来，太过于浅显东西没有写的必要，未经深入研究的东西，或是从别处直接复制粘贴别人的观点。这些都不是在写博客，而是在记流水账。因此，给自己定下了一个三不写的要求: 所描述的内容，逻辑不清，不写 没有经过自己验证过的内容，不写 对别人没有帮助，只是在记流水账的内容，不写 2017年会继续坚持写博客，写那些真正经过自己深入研究过的东西，写那些日常项目中真正遇到并最终解决的问题，写对自己对别人有用的东西。只有这样才能提高文章的质量，付出的时间才能得到最大化的利用。 新技术16年8月初，学习了最新的Swift 3.0，当然，现在最新的是Swift 3.01。从官网下了The Swift Programming Language(Swift 3.01)，通过官网下载时会跳转到iBooks，但由于一些众所周知的原因，iBooks中国区是无法下载的，需要使用美区账号登录iBooks。可以结合极客学院Wiki简体中文翻译看。目前，自己只看到了 Functions 这章，17年还需要继续学习剩下的部分，再使用Swift编写一个具体的项目。17年计划学习一些热更新的技术，并计划在自己做的项目中使用一种热更新技术，实现动态化的修改项目中的代码。17年，希望自己能在iOS之外，能入门一种新的技术，拓宽自己的视野，达到自己心中设定的新的高度，看到之前看不到风景。 挑战17年是公司发展历程中重要的一年，也是我所在项目组所开发的项目大范围推广的一年，我们将迎来更多的用户，更大的并发量，会根据市场反应快速迭代产品。我们渴望在项目中使用新的技术，不断的提高用户体验，同时，又能不影响项目上线时间。希望我们产品被更多的人使用，得到大家的认可。同时，希望我们团队 永远年轻，永远热泪盈眶。","tags":[]},{"title":"调试蓝牙扫码枪遇到的问题","date":"2016-12-09T01:51:47.000Z","path":"2016/12/09/iOS蓝牙开发简介  /","text":"iOS蓝牙开发简介蓝牙 4.0出现之前，蓝牙 2.0时只有iOS设备和苹果认证的MFI设备才可以被iOS设备检索到。蓝牙 4.0之后（硬件要4S，系统要iOS6以上才支持蓝牙 4.0），苹果开放了BLE(蓝牙4.0以低功耗著称，所以一般被称为BLE（bluetooth low energy））通道，没有MFI认证的蓝牙设备也可以连接非越狱的iOS设备了。 总结了一下，一共有五种方式可以实现蓝牙通信: 使用MFI认证的蓝牙模块的蓝牙产品 —— 开发使用ExternalAccessory框架，如果你的蓝牙模块还没设计，打算在AppStore上发布，打算使用蓝牙4.0以下（IOS设备都兼容），那你就抓紧找MFI认证的蓝牙模块吧。 使用苹果提供的CoreBluetooth framework框架 —— 只适用于支持蓝牙4.0的设备，无需越狱，无需使用MFI，可以发布在AppStore上。 GameKit framework —— 只能在iOS设备之间同一个应用内连接，从iOS7开始过期了，通过蓝牙可以实现文件的共享（仅限设备沙盒中的文件），此框架一般用于游戏开发（比如五子棋对战）。 Private API —— 使用私有API的应用程序不被允许在AppStore上发布。 Jailbreak 这里我使用的是第二种方式 —— CoreBluetooth。 核心概念CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类。 CBCentralManager：中心设备（用来连接到外部设备的管家） CBPeripheralManager：外部设备（第三方的蓝牙4.0设备） 这两组api分别对应不同的业务场景，左侧叫做中心模式，就是以你的app作为中心，连接其他的外设的场景，而右侧称为外设模式，使用手机作为外设别其他中心设备操作的场景。 服务和特征，特征的属性(service and characteristic):每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。 外设、服务、特征间的关系 连接测试检测蓝牙设备的连接强度，查询一定范围内的蓝牙设备列表。可以通过一款名为LightBlue的手机端软件来确定。在开启蓝牙的状态下，打开LightBlue搜索到当前范围内的设备列表，可以点击查看当前设备的UUID以及特征和服务的UUID，如图， 连接蓝牙扫码枪项目中需要连接蓝牙扫码枪，通过扫码枪扫描商品的条码，将得到的条码值传给终端设备。终端设备根据该条码值搜索该商品的全部信息。iPad开启蓝牙，通过设置蓝牙扫描枪，连接上iPad，但发现在调试状态下，并没有调用CBCentralManager的代理方法。使用LightBlue搜索当前范围内的蓝牙设备，无法找到当前连接到iPad上的蓝牙扫描枪。蓝牙扫描枪使用的是富立叶（cilico）ci6800这款。最后，看了产品说明，发现它的蓝牙模块是蓝牙2.0 + EDR。而不是最新的蓝牙4.0。在未做任何处理的情况下，iPad端任然可以所接收到扫码枪扫描条码后的到的码值。原来是扫码枪默认开启了HID模式，在该模式下iPad默认当前通过蓝牙连接的扫码枪为一个外接键盘，因此扫描后得到码值相当于通过敲击键盘输入。 这样也造成了一个问题，iPad上所有带有输入功能的操作，都无法通过点击输入框弹出软键盘。因为系统会将扫码枪当做键盘，所有软键盘的弹出或者隐藏都是通过扫码枪做操作。但事实上扫码枪并不能控制键盘的弹出。通过google找到了一种据说是可以解决该问题的方法点击查看。但该方法极不稳定，当扫码枪的连接状态在休眠/唤醒两种状态下来回切换时就会失效。偶尔会成功弹出键盘。 最后，在联系厂家需求帮助无果的情况下，不得不停止了该款扫码枪的适配。 连接蓝牙血压计为了验证自己的代码没有问题，是由于蓝牙扫码枪的蓝牙模块版本过低不支持CoreBluetooth。我又找来了一台据说支持蓝牙4.0的蓝牙血压计做测试。 代码实现的步骤 第一步，创建CBCentralManager。第二步，扫描可连接的蓝牙外设（必须在蓝牙模块打开的前提下）。第三步，连接目标蓝牙外设。第四步，查询目标蓝牙外设下的服务。第五步，遍历服务中的特性，获取特性中的数据或者保存某些可写的特性，或者设置某些特性值改变时，通知主动获取。第六步，在通知更新特性中值的方法中读取特性中的数据（再设置特性的通知为YES的情况下）。第七步，读取特性中的值。第八步，如果有可写特性，并且需要向蓝牙外设写入数据时，写入数据发送给蓝牙外设。 引入 CoreBluetooth头文件 1#import &lt;CoreBluetooth/CoreBluetooth.h&gt; 声明属性 123456@property (nonatomic, strong) CBCentralManager *manager;@property (nonatomic, strong) CBPeripheral *peripheral;@property (strong ,nonatomic) CBCharacteristic *writeCharacteristic;@property (strong,nonatomic) NSMutableArray *nDevices;@property (strong,nonatomic) NSMutableArray *nServices;@property (strong,nonatomic) NSMutableArray *nCharacteristics; 遵守协议 1@interface ViewController () &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt; 初始化数据 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.manager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; _cbReady = false; _nDevices = [[NSMutableArray alloc]init]; _nServices = [[NSMutableArray alloc]init]; _nCharacteristics = [[NSMutableArray alloc]init]; count = 0;&#125; 实现蓝牙的协议方法 (1)检查蓝牙状态 1234567891011121314151617-(void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; switch (central.state) &#123; case CBCentralManagerStatePoweredOn: &#123; [self updateLog:@\"蓝牙已打开,请扫描外设\"]; [_activity startAnimating]; [_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@\"FFF0\"]] options:@&#123;CBCentralManagerScanOptionAllowDuplicatesKey : @YES &#125;]; &#125; break; case CBCentralManagerStatePoweredOff: [self updateLog:@\"蓝牙没有打开,请先打开蓝牙\"]; break; default: break; &#125;&#125; 注：[_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@”FF15”]] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }];中间的@[[CBUUID UUIDWithString:@”FFF0”]]是为了过滤掉其他设备，可以搜索特定标示的设备。 （2）检测到外设后，停止扫描，连接设备 12345678910111213141516171819202122232425//查到外设后，停止扫描，连接设备-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123; [self updateLog:[NSString stringWithFormat:@\"已发现 peripheral: %@ rssi: %@, UUID: %@ advertisementData: %@ \", peripheral, RSSI, peripheral.identifier, advertisementData]]; _peripheral = peripheral; [_manager connectPeripheral:_peripheral options:nil]; [self.manager stopScan]; [_activity stopAnimating]; BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) &#123; CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) &#123; [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; &#125; &#125; if (!replace) &#123; [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; &#125;&#125; （3）连接外设后的处理 123456789101112131415161718192021222324//连接外设成功，开始发现服务- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123; NSLog(@\"%@\", [NSString stringWithFormat:@\"成功连接 peripheral: %@ with UUID: %@\",peripheral,peripheral.identifier]); [self updateLog:[NSString stringWithFormat:@\"成功连接 peripheral: %@ with UUID: %@\",peripheral,peripheral.identifier]]; [self.peripheral setDelegate:self]; [self.peripheral discoverServices:nil]; [self updateLog:@\"扫描服务\"];&#125;//连接外设失败-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@\"%@\",error);&#125;-(void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@\"%s,%@\",__PRETTY_FUNCTION__,peripheral); int rssi = abs([peripheral.RSSI intValue]); CGFloat ci = (rssi - 49) / (10 * 4.); NSString *length = [NSString stringWithFormat:@\"发现BLT4.0热点:%@,距离:%.1fm\",_peripheral,pow(10,ci)]; [self updateLog:[NSString stringWithFormat:@\"距离：%@\", length]];&#125; （4）发现服务和搜索到的Characteristice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//已发现服务-(void) peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; [self updateLog:@\"发现服务.\"]; int i=0; for (CBService *s in peripheral.services) &#123; [self.nServices addObject:s]; &#125; for (CBService *s in peripheral.services) &#123; [self updateLog:[NSString stringWithFormat:@\"%d :服务 UUID: %@(%@)\",i,s.UUID.data,s.UUID]]; i++; [peripheral discoverCharacteristics:nil forService:s]; if ([s.UUID isEqual:[CBUUID UUIDWithString:@\"FFF0\"]]) &#123; BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) &#123; CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) &#123; [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; &#125; &#125; if (!replace) &#123; [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; &#125; &#125; &#125;&#125;//已搜索到Characteristics-(void) peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; [self updateLog:[NSString stringWithFormat:@\"发现特征的服务:%@ (%@)\",service.UUID.data ,service.UUID]]; for (CBCharacteristic *c in service.characteristics) &#123; [self updateLog:[NSString stringWithFormat:@\"特征 UUID: %@ (%@)\",c.UUID.data,c.UUID]]; if ([c.UUID isEqual:[CBUUID UUIDWithString:@\"FF01\"]]) &#123; _writeCharacteristic = c; &#125; if ([c.UUID isEqual:[CBUUID UUIDWithString:@\"FF02\"]]) &#123; [_peripheral readValueForCharacteristic:c]; [_peripheral setNotifyValue:YES forCharacteristic:c]; &#125; &#125; &#125;&#125;- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error &#123; [self updateLog:[NSString stringWithFormat:@\"已断开与设备:[%@]的连接\", peripheral.name]];&#125; （5）获取外设发来的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@\"FF02\"]]) &#123; NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(\"testByteFF02[%d] = %d\\n\",i,resultByte[i]); if (resultByte[1] == 0) &#123; &#125;else if (resultByte[1] == 1) &#123; [self updateLog:@\"未知错误\"]; &#125;else if (resultByte[1] == 2) &#123; [self updateLog:@\"鉴权失败\"]; &#125; &#125; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@\"FF04\"]]) &#123; NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(\"testByteFF04[%d] = %d\\n\",i,resultByte[i]);&#125; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@\"FF05\"]]) &#123; NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(\"testByteFF05[%d] = %d\\n\",i,resultByte[i]); if (resultByte[0] == 0) &#123; // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@\"当前车辆撤防状态\"]; &#125;else if (resultByte[0] == 1) &#123; // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@\"当前车辆设防状态\"]; &#125; &#125;&#125;//中心读取外设实时数据- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123; if (error) &#123; NSLog(@\"Error changing notification state: %@\", error.localizedDescription); &#125; // Notification has started if (characteristic.isNotifying) &#123; [peripheral readValueForCharacteristic:characteristic]; &#125; else &#123; // Notification has stopped // so disconnect from the peripheral NSLog(@\"Notification stopped on %@. Disconnecting\", characteristic); [self updateLog:[NSString stringWithFormat:@\"Notification stopped on %@. Disconnecting\", characteristic]]; [self.manager cancelPeripheralConnection:self.peripheral]; &#125;&#125;//用于检测中心向外设写数据是否成功-(void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; if (error) &#123; NSLog(@\"=======%@\",error.userInfo); [self updateLog:[error.userInfo JSONString]]; &#125;else&#123; NSLog(@\"发送数据成功\"); [self updateLog:@\"发送数据成功\"]; &#125; /* When a write occurs, need to set off a re-read of the local CBCharacteristic to update its value */ [peripheral readValueForCharacteristic:characteristic];&#125; 后记厂商一般会提供一份蓝牙血压计通信指令控制数据格式(通讯协议) 可根据该协议中定义的返回的十六进制数据，定义当前外设发送的不同数据的意义。最主要是用UUID来确定你要干的事情，特征和服务的UUID都是外设定义好的。我们只需要读取，确定你要读取什么的时候，就去判断UUID是否相符。 一般来说我们使用的iPhone都是做centralManager的，蓝牙模块是peripheral的，所以我们是want datas，需要接受数据。 判断状态为powerOn，然后执行扫描 停止扫描，连接外设 连接成功，寻找服务 在服务里寻找特征 为特征添加通知 通知添加成功，那么就可以实时的读取value[也就是说只要外设发送数据[一般外设的频率为10Hz]，代理就会调用此方法]。 处理接收到的value，[hex值，得转换] 之后就自由发挥了，在这期间都是通过代理来实现的，也就是说你只需要处理你想要做的事情，代理会帮你调用方法。[别忘了添加代理] 参考资料蓝牙相关基础知识 hacksugar: Bringing back the on-screen keyboard 蓝牙交互CoreBlueTooth iOS and bluetooth iOS蓝牙，CoreBluetooth框架简介及入门使用 想做iOS Bluetooth產品但又不想過MFI的討論 CoreBluetooth cannot find devices but iOS can 请教熟悉iOS的朋友一个问题 【译】iOS蓝牙编程指南 – 核心蓝牙概述","tags":[]},{"title":"记一个在使用Masonry时遇到的问题","date":"2016-09-18T12:35:34.000Z","path":"2016/09/18/记一个在使用Masonry时遇到的问题/","text":"使用Masonry的场景在“我的”界面顶部区域用来展示用户的登录信息，顶部有两种样式的变换，即，由未登录—-&gt;已登录。如图所示， 其中头像区域是UIImageView，”登录/注册”是UILabel。登录成功后，头像区域会显示由服务器返回的头像地址生成的图片，并且其位置发生变化，不在居中显示，显示”登录/注册”的UILabel变为显示用户昵称，并且坐标位置发生改变。如图所示， 我的问题来了，在设置头像和标题位置时使用mas_remakeConstraints设置二者的约束，代码如图， 当从未登录切换到已登录时，已登录的头像位置会发生改变，变得特别大，不受约束控制。控制台会报如下错误， 刚开始没有意识到改变UIImageView的约束导致的新旧两种约束冲突造成的问题。在一个小时未解决该问题后，放弃了使用Masonry，改为使用代码做布局。今天，再回头看看这个问题，联想到忽略了什么东西，就打开Masonry文档从头开始仔细往下看，结果就看到了这句话， Sometimes you need modify existing constraints in order to animate or remove/replace constraints. In Masonry there are a few different approaches to updating constraints. 文档上列举了三种修改现有约束的方法， References你可以引用一个特定约束条件的约束，使表达式的结果分配给一个局部变量或一个类属性。 mas_updateConstraints作为一种选择，如果你只是去更新固有的约束值，你可以使用mas_updateConstraints这种便利的方法替换mas_makeConstraints。 mas_remakeConstraintsmas_updateConstraints用于更新一组约束，但要做那些费力的超出超出常量值的约束更新。这时就需要选择mas_remakeConstraints。mas_remakeConstraints类似于mas_updateConstraints，但它不是更新常量值，当再次为这些已经存在约束的视图设置约束前，它会移除掉该视图上的所有约束。这就让你可以为视图设置新的约束，而不用考虑移除之前已经存在的其他约束。 于是，我使用文档中提到的第三种方法，将所有的mas_makeConstraints换成了mas_remakeConstraints，就解决了约束错乱的问题。 参考文档Masonry使用 造成这个问题的主要原因是我没有认真看Masonry的文档，文档上说的已经很清楚了。","tags":[]},{"title":"记一个关于线程的错误","date":"2016-09-11T15:23:34.000Z","path":"2016/09/11/记一个关于线程的错误/","text":"上周遇到一个问题，当前页面为一个UIWebView，当点该WebView上某个按钮进入下一个页面时，再通过该页面顶部返回按钮返回时，程序就会崩溃。（在开启了全局断点的情况下）控制台会输出如下提示： 程序崩溃在将要消失时，控制台给出 This application is modifying the autolayout engine from a background thread,whinch can lead to engine corruption and weird crashes.This will cause an exception in a future release. 的报错。 根据提示认为是后台线程在更新UI布局时，webView与JS的交互也在此时进行。交互操作会阻塞UI的显示及刷新。因此，又回到了一个老生常谈的准则上来了， 要在主线程刷新UI布局 。在调用本地应用于H5交互的方法时，要放到主线程中。 123456789101112 #pragma mark - 跳转购物车- (void)goCart:(NSString *)shopNum&#123; CLog(@\"jsString = %@\",shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.navigationController popToRootViewControllerAnimated:NO]; MallHomeViewController *mallHome = [LYSingle sharedSingle].mallVC; [mallHome setCurrentSelectIndex:3]; &#125;);&#125; 123456789101112#pragma mark - 商品上架(未开通店铺不能上架)- (void)cannotShelves&#123; CLog(@\"cannotShelves\"); UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"\" message:@\"要在主线程刷新UI\" delegate:self cancelButtonTitle:@\"我知道了\" otherButtonTitles:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [alertView show]; &#125;);&#125;","tags":[]},{"title":"使用 cocoapods 时遇到的错误及错误的解决方案","date":"2016-08-21T07:58:00.000Z","path":"2016/08/21/关于cocoapod的二三事/","text":"1.The dependency AFNetworking (= 2.6.3) is not used in any concrete target.在cocoapods version 1.0 之后，默认生成的Podfile文件类似于 12pod 'Alamofire', '~&gt; 3.1.4'pod 'SwiftyJSON', '~&gt; 2.3.2' 这样的默认设置。为了不发生如标题那样的错误，需要手动用 target “TargetName” do end 把需要 pod 的库包括进来。 1234target \"TargetName\" do pod 'Alamofire', '~&gt; 3.1.4' pod 'SwiftyJSON', '~&gt; 2.3.2'end 2.ios None of your spec sources contain a spec satisfying the dependency: IQKeyboardManager (~&gt; 4.0.0).报这个错误，可能是由于Cocoapods的配置库有损坏，Cocoapods建议删除本地副本重新clone。根据cocoapods官方博客的方案，在终端做出如下操作 (依照次序) 第一步: 1sudo rm -fr ~/Library/Caches/CocoaPods &amp;&amp; \\ 第二步: 12345$ sudo rm -fr ~/.cocoapods/repos/mastergem update --system &amp;&amp; \\gem update &amp;&amp; \\gem cleanup &amp;&amp; \\pod setup 参考资料Pod install displaying error in cocoapods version 1.0.0.beta.1 intergating New Firebase.. error cocoapods pod repo update does not happen error in cocoapods Repairing Our Broken Specs Repository","tags":[]},{"title":"关于iOS 7 Background Remote Notification(推送唤醒)","date":"2016-08-09T15:30:48.000Z","path":"2016/08/09/关于iOS 7 Background Remote Notification/","text":"Background Remote Notification简介Remote Notifications是 iOS7 在推送方面最大的变化，它允许应用收到通知后在后台（background）状态下运行一段代码，可用于从服务器获取内容更新。功能使用场景：（多媒体）聊天，Email更新，基于通知的订阅内容同步等功能，提升了终端用户的体验。 如何设置Remote notifications客户端设置需要在Xcode 中修改应用的 Capabilities 开启Remote notifications，如图： 当注册了Backgroud Modes -&gt; Remote notifications 后，notification 处理函数一律切换到下面函数，后台推送代码也在此函数中调用。 1- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler 这个函数也是iOS8之后获取远程推送调用的方法。 服务端设置 这个很重要，推送消息携带 content-available: 1 是Background 运行的必须参数，如果不携带此字段则与iOS7 之前版本的普通推送一样。服务端payload格式:aps增加content-available字段，类似于： 123payload example:&#123;\"aps\":&#123;\"alert\":\"example\", \"sound\":\"default\", \"badge\": 1, \"category\":\"reply\",\"content-available\":\"1\"&#125;&#125; 这里集成的是极光推送，参考极光推送 Push API v3 的文档，发现了iOS 平台上发送 APNS 通知的规范。其中支持的字段中关键字 content-available 的类型为 boolean 。如果该字段为 true 说明是 Background Remote Notification ，如果不携带此字段则是普通的 Remote Notification 。这里需要特别注意的是服务器在配置 content-available: ture 时的正确性。如图，后台以java为例。 尚未传图 最后，当应用在后台挂起时，发起一个 Background Remote Notification(推送唤醒) 。客户端获取的数据，如下: 12345678910userInfo = &#123; \"_j_msgid\" = 2632357907; aps = &#123; alert = \"\\U6717\\U81f4\\U96c6\\U56e2\\U9738\\U5dde\\U5e02(\\U53bf\\U7ea7)\\U603b\\U4ee3\\U7406\\U5546\\U5bb6\\U60a8\\U597d\\Uff01\\U60a8\\U7684\\U5e97\\U94fa\\U53c8\\U6709\\U65b0\\U8ba2\\U5355\\U4e86\\Uff0c\\U8ba2\\U5355\\U53f73cef6682b73ca,\\U8bf7\\U53ca\\U65f6\\U767b\\U5f55\\U5546\\U57ce\\U8fdb\\U884c\\U8ba2\\U5355\\U5ba1\\U6838\\U3002\"; badge = 1; category = identifier; sound = default; content-available = 1; &#125;;&#125; 参考资料极光客户端SDk教程 极光服务器端Push API v3 三种方式使得iOS应用能够在后台进行数据更新和下载 后记关于 Background Remote Notification(推送唤醒) 早在一年前就使用过，当时调研调试花费了大量时间。没想到现在又遇到了这个问题。结果，我又在阴沟里翻了船。可见做笔记，写博客总结的重要性。希望第三次闭着眼睛就能跳过这个坑。","tags":[]},{"title":"JavaScriptCore与H5交互中使用JSExport设置引用名称空间","date":"2016-07-31T07:13:34.000Z","path":"2016/07/31/JavaScriptCore与H5交互中使用JSExport设置引用名称空间/","text":"JavaScriptCore简介JavaScriptCore是iOS7引入的新功能，使用JavaScriptCore后可以实现js代码与本地native代码进行相互调用。 要使用JavaScriptCore，首先我们需要引入它的头文件 #import &lt;JavaScriptCore/JavaScriptCore.h&gt; 这个头里面引入了几个重要的对象 12345#import \"JSContext.h\"#import \"JSValue.h\"#import \"JSManagedValue.h\"#import \"JSVirtualMachine.h\"#import \"JSExport.h\" JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口 JSValue是JSContext执行后的返回结果，他可以是任何js类型（比如基本数据类型和函数类型，对象类型等），并且都有对象的方法转换为native对象。 JSManagedValue是JSValue的封装，用它可以解决js和原声代码之间循环引用的问题 JSVirtualMachine 管理JS运行时和管理js暴露的native对象的内存 JSExport是一个协议，通过实现它可以完成把一个native对象暴漏给js 具体的交互过程可以参见这篇博客https://imciel.com/2016/06/18/oc-js-communication/ 使用JSExport设置引用名称空间js那边统一使用一个名为jsObject的对象来调用js的方法进行传值或触发某一特定的事件。在 js 中定义一个方法: 12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;Demo&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; function setContent()&#123; jsObject.shopCartNumChanged(totalNum); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload=\"javascript:setContent('ios is: ' + typeof ios)\"&gt;&lt;/body&gt;&lt;/html&gt; 当点击 js 界面上的一个 “+” 号时，js 那边会查找 OC 代码通过JSContext注册的名为jsObject.shopCartNumChanged的调用方法。现在问题来了，在 OC 中该如何注册该方法呢?答案是使用语言穿梭机—JSExport协议。比如，我有一个 ShopCarViewController 的类。在.h中声明一个名为 MallJSExports 的协议。 123456789101112// ShopCarViewController.h#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@protocol MallJSExports &lt;JSExport&gt;- (void)shopCartNumChanged:(NSString*)shopNum; //购物车数量变化- (void)orderGoBackToNative; //订单返回按钮@end@interface ShopCarViewController : MallViewController@end 在.m中当然要声明并实现该协议的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142@interface ShopCarViewController()&lt;UIWebViewDelegate,MallJSExports&gt;&#123;&#125;@property (nonatomic, strong) UIWebView *webView;@property (nonatomic, copy) NSString *shopNum; //商品数量@end@implementation ShopCarViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.navigationItem.title = @\"购物车\"; _webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, screenWidth, self.view.height-49)]; [_webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:_webUrl]]]; _webView.delegate = self; _webView.detectsPhoneNumbers = NO; [self.view addSubview:_webView];&#125;#pragma mark - 在webView加载完成的代理方法里设置JSContext- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; //JS上下文对象 JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; context[@\"jsObject\"] = self;&#125;#pragma mark - 购物车数量变化- (void)shopCartNumChanged:(NSString *)shopNum&#123; CLog(@\"jsString shopNum = %@\",shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum];&#125;#pragma mark - 订单返回按钮- (void)orderGoBackToNative&#123; [self.navigationController popViewControllerAnimated:YES];&#125; 这里要注意的是 context[@ “jsObject” ] = self 中的的key值是和服务器商量好的, 即， js 中定义的回调方法 jsObject.shopCartNumChanged( )相一致。 在这里对 JSExport 的使用只是简单的设置了一下命名空间，将下标方法暴露给js对象方便服务器调用。其实， JSExport 协议主要用途是把objc复杂对象转换成JSValue并暴露给js对象。 JSExport 作为两种语言的互通协议。 JSExport 中没有约定任何的方法，连可选的(@optional)都没有，但是所有继承了该协议(@protocol)的协议（注意不是Objective-C的类(@interface)）中定义的方法，都可以在JSContext中被使用。 参考资料使用 JavaScriptCore 实现 JS和OC间的通信 JavaScriptCore框架在iOS7中的对象交互和管理 iOS JavaScriptCore使用","tags":[]},{"title":"路开始的地方","date":"2016-01-16T04:04:48.000Z","path":"2016/01/16/summary/","text":"特别鸣谢老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！并附上他的博客地址 前言博客页面的搭建是在2015年6月15日，在老郭的指导下完成的。搭建博客的初衷完全是因为看到别人都有博客，而且界面很炫，为了自己的虚荣心才觉得自己也要整一个这样的博客。可是等到自己动手的时候，完全无从下手。什么是Hexo，Homebrew，MarkDown等等。这些都没有听说过。还好有老郭，他手把手的教我如何去配置这些东东。那时候觉得自己好2B。最后，倒是整出来了，看到了久违的Hello World，还是当年的配方，还是熟悉的味道。好吧，我承认我只是一时的冲动和虚荣心在作怪，我的博客在2015年6月15日止步于Hello World，从此，再也没有爬起来过。 自己思考原来就是件很快乐的事情，而教别人思考则是学习思考，锻炼思维的最好办法。 为什么写博客或许我并不是一个喜欢记录，总结的人。但还是因为工作的原因(每个周五都要发一份周报给老大)，还是养成了一个记录的习惯。我把周一到周五每天都做了什么事情，记录在一个黑色的笔记本上。 把那些未经整理的，杂乱无章的，解决的问题的过程和代码复制到了印象笔记上。以备以后查阅方便。遇到类似的问题就打开笔记，复制出一份代码。也未深究这段代码的意义何在，为什么可以解决问题。久而久之，便不会思考，真的就成为了代码的搬运工了。没有了思考，发现不了自己的短板，便陷在了这样一种自我满足的境地当中了。每天看似在前进，实际上是在原地绕弯。日复一日，剩下的只有惶恐和迷茫。变得越来越不自信。杂乱无章的笔记和随处存放的代码片段并不能引导我去思考制造这些Bug的原因。我要思考，要分享我的思考过程，希望得到别人认可的同时也能指出我的不足和错误。 解决问题的核心思想只有一个———一切都靠积累。 博客的开始回顾过去的2015年，我已经在新公司待了快一年了，虽然，不知道自己究竟都有哪些提升。但是，冥冥中又觉得自己还是有些收获的。当然这些收获都来自于师傅他老人家的谆谆教导。我不想忘记那些和师傅一起加班的日日夜夜里所带来的收获，我要把这些冥冥中的收获写下来，记录我在这些项目中的收获，以及那些尚未解决的问题所留下的遗憾。 期望以后能弥补这些遗憾。留住这些青春的记忆。","tags":[]}]