[{"title":"2017年度总结","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/2017deadline/","text":"转眼间2017就要结束了，回首过去的一年，有过彷徨，有过不安，也有收获的感动与喜悦。过完17年我就拥有四年开发经验了，一直觉得四到五年的阶段是区别高级开发与初中级开发的分水岭。但这并不使我感到高兴，我深知这四年时光中一多半是在蹉跎中度过的。往之不谏，来者可追！2018！我来了。 家庭对我这个年龄来说，结婚的很少，更别提孩子了。但我已经为人夫，为人父了！似乎用两三年的时间走完了别人十几年的路。太过年轻的我，总会时不时忘记自己身为父亲的责任，我媳妇(花花)总会不厌其烦的唤起我作为父亲该承担的责任。家里的大事小情，在花花的安排下井井有条。孩子的奶粉，尿不湿也不用我来操心，为了分担我的压力，花花早早给儿子断了母乳，离家挣钱。对花花我即心疼又愧疚，我不能一直用年轻作为借口，逃避身为男人的责任。家庭永远是第一位！ 每个人都有属于自己的人生遥控器，它无时无刻不掌握在你自己的手中，你可以随时按快进键让时间从你的手中逃走，你也可以按回退键，想想自己曾经的错过与失误，你也可以按跳过键，它的另外一个名字叫做逃避…… 从前有个精灵一直在寻找彩虹那端的金罐，但最后，他发现那只是一罐麦片。 博客年初给自己定下了一个目标：每周至少写一篇博客。到目前为止，算上这篇，一共是25篇。这25篇文章中，有5篇是译文，5篇是个人感悟，剩下15篇是技术上的分享。技术上的分享有些很肤浅，和大咖们由浅入深的技术文章比起来有些相形见绌。但我还是会坚持写下去的，须知泰山非一日之功。 写一篇鞭辟入里的爽文真的很费时间，前期需要阅读大量的相关文章，技术文档。最难得还是将所要描述的知识点与实际的代码，产品需求结合起来。因此，当你在自己的项目中解决了一个棘手的bug，或者实现了一个复杂的产品需求时，你再将这些解决问题的方案写成博客，就会有一种“下笔如有神”的感觉。就好比最近写了一篇名为利用JenKins持续集成iOS项目时遇到的问题博文，通篇写下爱特别顺畅。因为这些流程都是我切身经历过得，在这里也只是再复述一篇操作流程而已。 相比之下这篇文章 — AFNetworking到底做了什么？ 写起来就不那么顺利，自己没有切实经历过，整个AFNetworking的源码，马马虎虎的读了两遍，不能透彻理解其中的精髓。也只能转载别人的观点。 自从给自己定下了一周至少写一篇博客的目标后，每到周末就特纠结，搜肠刮肚的想着如何结合实际开发构思出一篇好博文。有时实在没有好的点子，就翻译Medium和湾区日报上推荐的英文文章，或者写一些个人心得体会。 今年写的一些技术性文章也有不尽如人意的地方，有些文章，写的很粗浅，没有刨根问底追溯到本质上。有些文章是迫于一周要写一篇博文而拼凑成的，今年不会如此只求量而不求质了。但以文字的形式记录分享开发心得的习惯，一旦养成，就不会轻易舍弃，这算是2017年一个明显的收获吧！ 读书今年看完了《图解HTTP》、《黑客与画家》、《软技能:代码之外的生存指南》。正在看的有《人类简史》、《啊哈!算法》。看《啊哈!算法》时，看的快忘得也快，还是没有结合实践，将书上的算法，用代码实现一遍。偶然在知乎上看到你是怎么看完《JavaScript权威指南》《JavaScript高级程序设计》等这类厚书的？的提问，摘录其中一个赞同数最高的回答： 与其说看书不如说看目录，从目录里找到感兴趣的章节，看掉，看到中途没兴趣了，就放下下次再看。工作中碰到什么问题不明白需要参考了，还是看目录，才大概会在什么章节里，探索一番，中间如果碰到感兴趣的，看掉，看到中间没兴趣了，放下，下次再看。要不了多久，整本书的70%-80%都翻遍了，其中有20%-30%翻了不止一遍，这些往往是核心的知识；至于剩下的20%没看过的，以后或许有机会的，没机会也不要紧，很多时候自己已经通过各种机缘学到了。 所以看技术厚书不在于多块或多慢，而是从容。 其中，我认为结合书中知识点，理论联系实践是最为有效的掌握知识点的方法。读一些非技术的书籍，最重要的是能够让自己心安。 此心安处是吾乡 关于买书，今年没有买一本书。因为去年买的书，大概有七八本吧！只看完了三本，还有向公司申请采购的3本技术书籍，手中库存的书足够我看了。2018年在此立一个flag：看完6本书！ 新部门今年12月份时被调到一个新部门，开始接触到公司最为核心的项目。想想就有些小激动啊！因此，也会给自己提出更高的要求，写功能模块时要注意与其他功能的耦合性，兼顾需要考虑程序的性能，容错机制的相应。现有的开发模式，耦合性太高，如何实现高可用的组件化，降低功能模块间的耦合性？将是我们这个团队在18年需要重点考录的问题。希望能为这次项目模块的优化重构尽自己的一份力量。 新技术9月初接触微信小程序，和部门另外两个H5一起开发公司的一款小程序。中间吃了小程序产品原型还是是基于原生App思维而设计的亏，同时，也由于自己没有完全吃透小程序开发文档，在实现一些功能时踩了坑。 这次小程序开发经历使我意识到自己的技术短板，陷入对技术的狂热之中。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。 请勿陷入对技术的狂热之中 若是早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不再积极进取，不再学习新技术。这种开发者被称为“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。 2018年，新的一年，要在原有技术的基础之上找到突破口，将自己以前囫囵吞枣的知识点再好好品味一番。同时，也不能仅仅局限于iOS一方面的技术。 愿景家人身体健康，自己技术日臻成熟。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"2017","slug":"2017","permalink":"http://XibHe.github.io/tags/2017/"},{"name":"年度总结","slug":"年度总结","permalink":"http://XibHe.github.io/tags/年度总结/"}]},{"title":"(译)创业就是要发起一场思想运动","date":"2017-12-08T16:00:00.000Z","path":"2017/12/09/Build a Movement/","text":"作为一个创业者，我并不喜欢和开发者在午餐时间发生争论。 ”这是胡说，“我们的首席技术官回复。“MailChimp的产品并不比其他产品好，这只是另一个发送消息的通讯工具而已。当它竞争对手提供同样的功能只需要花费几块钱时，为什么每月要额外花费200美元呢？“ 我想说服他，MailChimp确保我们的电子邮件广告系列投递到顾客的收件箱，而不是他们的垃圾邮件文件夹。 但是他一直用我没有完全明白的技术解释来反驳我。 “看，我们甚至可以建立我们自己的电子邮件机器人，做同样的事情，”他补充说。“你只是因为他们的品牌知名才使用它。” 是的，在一定程度上他说的很对。 在过去的几年中，MailChimp已经建立了一个标志性的品牌以其设计为中心的方法和非传统的营销活动。 猴子吉祥物广告牌没有提到他们的名字…“MailKimp”和参与其他趣味取名活动达到了3.34亿人…以设计为中心的年度报告与风格… MailChimp的赠品也是非常规的。为猫咪准备的免费猴子帽子打动了像我一样准备付更多钱的超级粉丝。 在一个任何人都可以一夜之间复制你的产品的世界里，MailChimp选择为猫咪编织猴子帽子，而不是进行军备竞赛建立更多的功能。 毕竟，公司甚至还接到一些大客户的公开信和警告，如果没有更高级的功能，就有可能转向竞争对手。 MailChimp的回答？ 重点打造品牌客户的爱心。 当我们接近2017年年底时，从未在外部资金上花费一分钱的电子邮件创业公司正在准备结束令人兴奋的增长达1500万客户的一年。 但是猴子生意足够了。 让我们着眼大局，了解这对初创企业如何在当今混乱的世界取得成功意味着什么： 你不必扰乱整个行业:尽管许多企业家正忙于构建下一个Uber或Facebook，但这是一个我们需要消除的神话。MailChimp并没有打乱任何一个行业，但它却在一个日益拥挤的市场上建立起了猴王国。 如果你不打扰或创造一个全新的市场，你仍然可以在竞争激烈的行业里建立一个帝国:而且它涉及越来越多的超级粉丝，他们虔诚地跟随你的运动，即使你收取溢价，或者拒绝参加建立更多特征的军备竞赛，仍然会推荐你的品牌。 但是，秘密是什么？ 你如何接触民众，发展你的粉丝俱乐部，让你按自己的规则玩游戏，而不用担心竞争？ 选择各不相同，但一些世界上最成功的创业公司使用两个强大的战略: 首先显然是“MailChimp方式”，即，将您的产品推销为高品质的品牌。正如他的创始人Ben Chestnut解释的那样: 我们为商业客户制作应用程序，使用低价位的零件，然后以高质量，以设计为中心，可爱的B2C品牌推广应用程序。 但是越来越多的蓬勃发展的创业公司使用另一种策略 - 不一定需要以设计为中心的方法。 它需要反过来影响人的思维： 不要扰乱一个行业，扰乱思想 正如马克·博切克（Mark Bonchek）在他广受欢迎的哈佛杂文中所强调的那样： 成功销售和销售创新的公司能够改变人们，不仅关注他们的产品，而且关心他们自己，市场和世界的想法。 不要销售产品，销售一种全新的思维方式。 拿Drift来说，今天科技界的新星之一。 并不是强迫人们理解他们的产品，像Drift这样的“推动者”推销思想的根本转变，即，引起他们创新的原始洞察力。 对Drift而言，最初的洞察力导致了营销和销售方式的破旧，仍然依赖网站形式和烦人的销售后续行动。 这就是为什么，他们没有硬去销售或用产品信息淹没他们的博客，而是谈论今天的营销和销售技巧是怎样的，或者为什么营销自动化和电子邮件营销被打破。 这与你的价值主张不同。这是一个关于世界如何运作的假设（通常是无意识的），“Bonchek补充道。 当你将其视为模板时，该逻辑很容易应用于任何创业项目： 我们支持[插入]，并将人们思考[插入]的方式转变为[插入]。 例如，Drift支持新的营销和销售方式，将人们对营销和销售的看法转变为更多的谈话驱动，个性化和人性化。 另外两家标志性公司–Basecamp和Salesforce也在重新思考现有的心智模式方面处于领先地位。 Basecamp的创始人通过倡导“非硅谷之路”，改变人们对管理，生产力，时间，增长或创业公司运作方式的看法，来壮大自己的超级粉丝。 Salesforce捍卫“无软件”的口号，将思想从打包的安装软件转移到云计算和软件即服务。 建立一个改变人们思维的引擎 改变人们目前的思维模式不是一朝一夕就能实现的。 相反，你将需要一个可持续的引擎，一次又一次地在不同的环境和情况下向人们展示新的心智模式。 例如，尽管Drift的博客每月已经超过了10万人，他们打开新的渠道，达到他们无法达到的观众，否则他们不会通过： 他们一年一度的“超级增长”会议，专门讨论营销和销售的未来; 他们的“寻找智慧”播客，通过音频对话传播他们的信息。 像Drift一样，Basecamp的创始人们建立了一个多渠道的引擎，通过他们的畅销书，如’返工‘，他们的流行博客和播客来接触新的人。 尽管如此，建立一个引导人们去思考新的思维方式的方法并不是保留给创业公司的。 像GE这样的大公司已经认识到他们称之为“市场份额之前的分享”的重要性。 GE的首席营销官Beth Comstock解释了为什么他们大量投资于内容引擎: 真正好的创新需要在被接受之前得到解释……这意味着成为一家内容工厂 - 从数据到视频，再到社交媒体，讲述媒体和方法的故事。 MailChimp的方式，Drift的方式，或着你的方式 从博主到创业创始人，今天的制作者们都越来越关注： 噪音太大，竞争如此激烈。 像SaaS这样的空间变得越来越有竞争力，公司觉得他们差不多是在出售商品，或者他们的产品可以在一夜之间复制。 这就是为什么在今天这个历史上最混乱的市场上，建立一场运动比以往任何时候都重要。 建立它，以MailChimp方式，漂移的方式，或你的方式。不管你采取什么样的路线，在企业中有一个与自己相得益彰的要素是一致的：对自己忠实。 对于MailChimp来说，这意味着推出非常规的营销活动，故意错误地发音他们的名字： 我们相信与客户建立关系的最好方式就是成为你自己。 对我们来说，这意味着我们的名字有乐趣。 对于Drift来说，这意味着在他们的首席营销官和首席执行官之间进行诚实的交谈 虽然世界上充斥着假装看起来专业的播客，Drift的非正式播客风格是“寻求智慧”拥有忠实粉丝的原因之一。 正如Basecamp的创始人所指出的那样，倾注于自己的产品是一种从人群中脱颖而出的有力方式： 如果你成功了，人们会试着复制你所做的。但是有一个很好的方法来保护自己免受抄袭： 让你成为你的产品或服务的一部分。注入你对销售方式的独特看法。 把自己投入到产品和产品周围：你是如何销售的，你是如何提供产品支持的，你是如何向顾客解释产品的，以及你是如何交付产品的。 竞争者永远不能复制你的产品。 这对生意有好处。 - 不要建立一个初创公司，而是发起一场运动 - 从第一天开始。 如果你做得对，像我这样的超级粉丝可能会自愿花午餐时间，因采用你提供的方案而与他人进行激烈的讨论。 原文地址Don’t Build a Startup, Build a Movement –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"创业","slug":"创业","permalink":"http://XibHe.github.io/tags/创业/"}]},{"title":"AFNetworking到底做了什么？","date":"2017-11-25T16:00:00.000Z","path":"2017/11/26/AF3.x/","text":"最近在对接一个demo，主要是调用一下SDK，实现一些功能。发现这个demo的网络请求部分是基于NSURLConnection做的一些简单调用。用起来感觉总是怪怪的，于是就想切换回自己一直在用的AFNetworking。结果，和我想的还是不太一致。同时，也暴露出一个严重的问题：对AFNetworking实现原理，到底做了什么？可以说是一窍不通。之前一直以为对AFNetworking很熟悉了，现在看来，也只是停留在调用AFHTTPSessionManager的表明。 NSURLSession， NSURLSessionDataTask这两个类是iOS做网络请求的核心类，而AFNetworking则是对其做了一系列封装，简化了使用系统原生API做网络请求的过程。 更新说明更新记录: 2017 年 11 月，第一版。 2017 年 12 月，对具体的步骤进行归类整理。 对AFNetworking调用是做了一层简单的封装，将请求时用到的各种参数在一个继承自NSObject的类中统一配置。如下， + (void)postWithUrl:(NSString*)url params:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间 manager.responseSerializer = [AFJSONResponseSerializer serializer]; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@&quot;text/html&quot;]; [manager POST:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSDictionary *bodyObjDic = [responseObject objectForKey:@&quot;body&quot;]; CLog(@&quot;bodyObjDic = %@&quot;,bodyObjDic); NSString *code = [bodyObjDic objectForKey:@&quot;code&quot;]; CLog(@&quot;url = %@,code = %@&quot;,url,code); if ([code isEqualToString:@&quot;200&quot;]) { if(success) success ([responseObject objectForKey:@&quot;body&quot;]); } else if(code == nil){ NSError *error = [NSError errorWithDomain:@&quot;请求错误&quot; code:-1 userInfo:nil]; if(failure) failure(error); } } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { if([@&quot;NSURLErrorDomain&quot; isEqualToString:error.domain]){ error = [NSError errorWithDomain:@&quot;请监测您的网络环境&quot; code:error.code userInfo:nil]; } if([@&quot;NSCocoaErrorDomain&quot; isEqualToString:error.domain]){ error = [NSError errorWithDomain:@&quot;服务器繁忙，请稍候重试&quot; code:error.code userInfo:nil]; } if(failure) failure(error); }]; } 再将所有用于请求的url都放在这个类的类别中，统一管理。如下， /** 注册接口 */ + (void)getRegistedWithParams:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure { [self postWithUrl:[NSString stringWithFormat:@&quot;%@&quot;,kILVBHost] params:params success:^(id JSON) { if(success){ success(JSON); } } failure:^(NSError *error) { if(failure){ failure(error); } }]; } demo在网络请求时，会将参数转换并设置到HTTPBody中，上面那种直接使用AFHTTPSessionManager进行POST请求的方式就不行，其无法在请求时将请求的参数设置到request的HTTPBody中。于是，尝试通过新建一个NSMutableURLRequest请求，通过设置它的HTTPBody到达目的。如下， + (void)postWithUrl:(NSString*)url params:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间 manager.responseSerializer = [AFJSONResponseSerializer serializer]; NSError *requestError = nil; NSMutableURLRequest *request = [manager.requestSerializer requestWithMethod:@&quot;POST&quot; URLString:url parameters:params error:&amp;requestError]; request.HTTPBody = [NSData data]; [manager.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { CLog(@&quot;data = %@,response = %@&quot;,data,response); }]; } 但请求时会报500的错误。看来还需要接着往深了抛，看看AFNetworking到底做了什么？ 这里之所以会设置manager.requestSerializer为： [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; 是将NSMutableURLRequest与manager.requestSerializer混为一谈了。 demo中通过NSMutableURLRequest设置相应的请求头的属性值，如下： NSURL *URL = [NSURL URLWithString:url]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL]; if (data){ [request setValue:[NSString stringWithFormat:@&quot;%ld&quot;,(long)[data length]] forHTTPHeaderField:@&quot;Content-Length&quot;]; [request setHTTPMethod:@&quot;POST&quot;]; [request setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [request setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; [request setHTTPBody:data]; } 而manager.requestSerializer用于设置AFHTTPRequestSerializer(请求参数解析类)的，之所以会报解析或者服务器先关错误，是由于没有设置网络请求的解析方式导致。而responseSerializer默认使用了JSON的解析方式，这也是为什么当使用AFN进行网络请求时，JSON会自动进行解析的原因。这里如果想进行默认的request和response序列化，就要在manager的默认设置完成之后，在开始进行网络访问前使用： AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.requestSerializer = [AFJSONRequestSerializer serializer]; manager.responseSerializer = [AFJSONResponseSerializer serializer]; 即可实现返回数据的自动解析。 AFNetworking到底做了什么？AFNetworking概述图片所在原文链接 AF分为如下5个功能模块： 网络通信模块(AFURLSessionManager、AFHTTPSessionManger) 网络通信信息序列化/反序列化模块(Serialization) 网络状态监听模块(Reachability) 网络通信安全策略模块(Security) 对于iOS UIKit库的扩展(UIKit) AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的上层封装。而其余的四个模块，均是为了配合AFURLSessionManager类的网络通信做一些必要的处理工作。如上图，所示。 其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager去做。 以上内容原文链接 对外接口类AFHTTPSessionManagerAFHTTPSessionManager不做实事，只是提供了对外调用的接口。 调用父类方法进行初始化 - (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } //.... return self; } 类似网络请求方法中，调用父类方法拿到task，这个类仅仅是把得到的task，resume即可 NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot; URLString:URLString parameters:parameters uploadProgress:nil downloadProgress:downloadProgress success:success failure:failure]; // 开始任务 [dataTask resume]; AFHTTPSessionManager还做了一件很重要的事，就是把传过来的参数，编码成我们请求时需要的request，并且传给父类去做网络请求。 NSURLSession， NSURLSessionDataTask NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; AFNetworking请求核心类：AFURLSessionManagerNSURLSessionDataTask,AFHTTPSessionManager的初始化方法，触发了这个类所有的初始化初始化方法： - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration； - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super init]; if (!self) { return nil; } if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; // queue并发线程数为1，这个是代理回调的queue self.operationQueue.maxConcurrentOperationCount = 1; // 注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法。 self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 各种响应转码 self.responseSerializer = [AFJSONResponseSerializer serializer]; // ssl证书，是验证证书，还是公钥，还是不用 self.securityPolicy = [AFSecurityPolicy defaultPolicy]; #if !TARGET_OS_WATCH self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; #endif // 设置存储NSURL，task与AFURLSessionManagerTaskDelegate的词典（重点，在AF中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理） self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; // 设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; // 为所管理的session的所有task设置完成块,此方法为生成session之后就调用 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { // 置空处理 for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self; } 这个方法初始化了一些我们后续需要用到的属性，其他的都很简单，唯一比较费解的两处可能是： self.operationQueue.maxConcurrentOperationCount = 1; [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { //置空处理 }]; 我们首先来讲讲这两个操作的作用： 第一是让回调的代理queue是串行的，即请求完成的task只能一个个被回调。 第二是清空了session中所有task。 - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { // 第一件事，创建NSURLSessionDataTask，里面适配了Ios8以下taskIdentifiers，函数创建task对象。 __block NSURLSessionDataTask *dataTask = nil; // 其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理 url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask; } 类似这个类中很多方法这样的方法，这些方法主要做两件事： 调用session的方法，传request过去去生成task。注意这里调用了url_session_manager_create_task_safely函数去执行的Block,这个函数实现如下： static void url_session_manager_create_task_safely(dispatch_block_t block) { if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) { dispatch_sync(url_session_manager_creation_queue(), block); } else { block(); } } 简单来讲就是为了适配iOS8以下task创建，其中taskIdentifiers属性不唯一，而这个属性是我们之后添加代理的key，它必须是唯一的。 所以这里做了一个判断，如果是iOS8以下，则用串行同步的方式去执行这个Block，也就是创建session。否则直接执行。 给每个task创建并对应一个AF的代理对象，这基本上是这个类的核心所在了，这个代理对象为其对应的“task做数据拼接及成功回调。 方法如下： - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler { AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系 delegate.manager = self; delegate.completionHandler = completionHandler; // 这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应 dataTask.taskDescription = self.taskDescriptionForSessionTasks; // 将AF delegate对象与 dataTask建立关系 [self setDelegate:delegate forTask:dataTask]; // 设置AF delegate的上传进度，下载进度块 delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock; } 将AF delegate对象与dataTask建立关系 - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task { // 断言，如果没有这个参数，debug下crash在这 NSParameterAssert(task); NSParameterAssert(delegate); // 加锁保证字典线程安全 [self.lock lock]; // 将AF delegate放入以taskIdentifier标记的字典中（同一个NSURLSession中的taskIdentifier是唯一的） self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // 为AF delegate 设置task 的progress监听 [delegate setupProgressForTask:task]; // 添加task开始和暂停的通知 [self addNotificationObserverForTask:task]; [self.lock unlock]; } 以上两个方法创建了一个AFURLSessionManagerTaskDelegate的代理，把这个代理和task的taskIdentifier一一对应，放到我们最早初始化的字典里，建立起映射。 我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，这些代理开始调用了： NSURLSessionDelegate： - (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(NSError *)error； - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler; NSURLSessionTaskDelegate： - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend； - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error； NSURLSessionDataDelegate： - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler； - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask； - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data； - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler； NSURLSessionDownloadDelegate： - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location； - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite； - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes； AFURLSessionManager一共实现了如上所列举的一大堆NSUrlSession相关的代理。 而只转发了其中3条到AF自定义的delegate中： NSURLSessionTaskDelegate： - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error; NSURLSessionDataTaskDelegate： - (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data; NSURLSessionDownloadTaskDelegate： - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location; AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。 总结一下，这些代理主要是做了一些额外的处理，并且调用了它的属性Block： @interface AFURLSessionManager () @property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid; @property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge; @property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession; @end 等属性…… 我们可以利用这些Block，做一些自定义的处理，Block会随着代理调用而被调用，这些代理帮我们做了一些类似数据分片、断点续传、https认证等工作 除此之外，有3个代理方法回调了我们的task的AF代理，包括请求完成的代理，收到数据的代理，以及下载完成的代理，以第一个为例： - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 根据task去取我们一开始创建绑定的delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) { // 把代理转发给我们绑定的delegate [delegate URLSession:session task:task didCompleteWithError:error]; // 转发完移除delegate [self removeDelegateForTask:task]; } // 公用Block回调 if (self.taskDidComplete) { self.taskDidComplete(session, task, error); } } 通过我们之前设置的task和AF代理映射，去调用AF代理，并且把这个task从映射字典中移除。 接着就调用了AF的代理：(自定义代理3条中的一条) // AF实现的代理！被从urlsession那转发到这 - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; // 用来存储一些相关信息，来发送通知用的 __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; // 存储responseSerializer响应解析对象 userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; // Performance Improvement from #2672 // **注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存** NSData *data = nil; if (self.mutableData) { data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; } // 继续给userinfo填数据 if (self.downloadFileURL) { userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; } else if (data) { userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; } // 错误处理 if (error) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; // 可以自己自定义完成组 和自定义完成queue,完成回调 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, error); } // 主线程中完成通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); } else { dispatch_async(url_session_manager_processing_queue(), ^{ NSError *serializationError = nil; // 解析数据 responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 如果是下载文件，那么responseObject为下载的路径 if (self.downloadFileURL) { responseObject = self.downloadFileURL; } // 写入userInfo if (responseObject) { userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; } // 如果解析错误 if (serializationError) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; } // 回调结果 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, serializationError); } dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); }); } } 虽然这个方法有点长，但是它主要做了两件事： 调用responseSerializer按照我们设置的格式，解析请求到的数据。 用completionHandler把数据回调出去，至此数据回到了用户手中。 到这里，AF的整个主线流程就完了，当然，我们跳过了很多细节没有讲，比如responseSerializer的各种格式的解析过程，还有为了监听task的开始和挂起通知，所做的method swizzling，这里对iOS7的兼容问题的处理，算是相当精彩了。 以上内容原文链接 处理请求和响应：AFURLSerialization对发出请求以及接收响应的过程进行序列化，这涉及到两个模块： AFURLResponseSerialization AFURLRequestSerialization 前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。我们首先会对 AFURLResponseSerialization 进行简单的介绍，因为这个模块使用在 AFURLSessionManager 也就是核心类中，而后者 AFURLRequestSerialization* 主要用于 AFHTTPSessionManager** 中，因为它主要用于修改 HTTP 头部。 有关解析类的详情见原文： 处理请求和响应 AFURLSerialization（三) 小结本来想自己写关于AFN的使用心得，但发现自己的水平有限，不能把AFN主要做了什么？它是如何实现网络请求和解析的？这些问题说明白。只能将大牛文章中的精彩内容粘贴出来，做了一个简短的整理。这里引述涂耀辉在AFNetworking到底做了什么? (终)一文中所说的一句话： AFNetworking中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。 参考资料如何使用 AFNetworking 3.0 设置 Request.HttpBody AFNetworking到底做了什么？ AFNetworking到底做了什么？(二) AFNetworking 概述（一） 处理请求和响应 AFURLSerialization（三)","tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://XibHe.github.io/tags/AFNetworking/"}]},{"title":"(译)软件开发这份工作到了35岁之后就是尽头了吗","date":"2017-11-18T16:00:00.000Z","path":"2017/11/19/dead-end job /","text":"我想你会问3个不同的问题，也许应该修改一下这个问题。我们来分解一下吧： 年龄歧视是软件开发行业中的问题吗？ 你应该把自己的职业转向管理角色，而不是个人开发者角色吗？ 软件开发个人开发者是一个死胡同吗？ 在Quora上关于这些问题的提问，每个问题都有详细的回答，其中细节如上所述，所以我将简要地讨论每个问题。 对于年龄歧视，我不认为有人会否认这个行业有一定的年龄歧视。你可以看看几乎所有硅谷公司的新员工的平均年龄。我怀疑，大多数中等雇佣年龄远低于30。然而，这并不一定意味着官方的公司政策不会雇用超过一定年龄，种族，性别，性别偏好或其他特征的候选人。 为什么在高科技产业中存在年龄歧视，原因是多方面的，并非是所有公司一起商量好不雇用年长员工。一方面，许多公司发现，使用新的大学毕业生（麻省理工学院和斯坦福大学等）作为招聘的主要对象是最容易的。新毕业生便宜。他们有一个稳定的质量。他们不受其他公司经验的束缚。他们是一张白纸，比较容易教他们企业文化，软件方法论，最佳实践，并与参与其他业务的新毕业相互配合工作。 我认为，硅谷的任何人都不会认为，如果你有一个在相关技术方面拥有3年扎实编程经验的候选人（加上也是有名望的毕业生），不是一个好的候选人。事实上，我甚至可以说N年开发经验并不重要，没有确切的说明，有N年相关经验的候选人比N + 1年经验的候选人要好，所有其他因素是平等的，技能 以及与公司正在进行的业务相关的经验。 对于工程师来说，保持相关性的技术变化太快的说法可能是一回事，但是构建网络的核心技术已经存在了几十年了。C语言早在七十年代末就出现了，已近有将近四十多年的历史了。Javascript语言，第一次出现在1997年，大概是20年前。这意味着几十年开发经验的工程师，他们的工作已经接近退休年龄，整个职业生涯一直专注于C和运行Unix服务器。这样的工程师非常少，有这么多的经验，但是我怀疑有谁会试图宣称刚刚毕业的22岁的人肯定比60岁的人好，相比之下，他们的一些人已近专研了40多年技术。当然，这些类型的工程师很少。 因此，对于问题的另一方面，我不认为软件工程是一个死胡同的事业。我想说的是，在薪酬增长方面，在一定的时间之后，它会趋于稳定。部分原因就是工程师本质上是人为的商品。除非你是一个非常特别的工程师，事实上，你总是可以被其他人取代。与其他竞争性行业相比，我认为这有助于保持软件工程工资水平。不过，我几乎可以保证，对软件工程师的需求将超过应聘者中新毕业生或其他人的供应，所以你总能找到工作。不过，你可能不会每年收到那些10％的指数提升，就像你两三年前那样。 最后，关于转为管理者是否是一个更好的选择，我想问为什么只考虑这个选项？当然有许多职业道路可供选择。你可以转换到另一个工程领域。例如，许多不喜欢创造产品的软件工程师会转移到其他角色，有时在同一个公司，例如运营，产品管理，项目管理，质量保证，或者更少的技术，如销售或行政职位。我也有一些完全改变职业的朋友，比如全职教学。 最后让我说，以为自己为例，在和那些具有扎实工程背景的经理人员一起工作时，我很欣赏他们，最好是与公司相关技术的软件工程，所以请不要急于进入工程管理的职业道路。对于我们这些将来可能不得不与你打交道的人，作为开发者，可以获得5年或6年的良好工程实践经验。了解这个行业是如何运作的，作为一个经验丰富的开发者。只有这样，才能考虑把你的职业转向管理方向。就像你不会雇用花店来建造布鲁克林大桥。同样也不会聘请没有任何开发经验的人担任项目经理。 原文地址Is software development really a dead-end job after age 35-40? –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"职业生涯","slug":"职业生涯","permalink":"http://XibHe.github.io/tags/职业生涯/"}]},{"title":"凌冬将至","date":"2017-11-10T16:00:00.000Z","path":"2017/11/11/introspect/","text":"至此光棍节来临之际，祝各位光棍们节日快乐，年年无今日，岁岁无今朝，早日脱单。最近一个月不是很忙，之前做的项目在8月中旬停了下来，项目是停了下来，但整个项目组却闲不下来。九月份接手了一个新需求，为公司的另一个项目开发录入药品的小程序。工期算上测试、发布大概是二十天。这中间虽然是第一次接触小程序开发，最后，跌跌撞撞的总算是顺利上线了。 开发小程序的这段时间，总是有些难熬，自己之前并没有HTML、CSS、JavaScript的基础，在w3cschool上看了两天的HTML、CSS基础，就硬着头皮上了。不过还好有一个前端老司机带着，一起踩踩小程序的坑。在前两年前端很火的时候，我就很想跟风学习一下了，但总是给自己找各种理由。最后，学习计划就不了了之了。这次的学习动机来的如此强烈，看来只有将自己的学习动力与工作中的业务需求捆绑起来，才能迈出这第一步。 随着开发的深入，不得不惊讶于小程序“用完即走”的设计理念。与移动端APP相比，小程序真的很小，开发成本小的多。不得不感慨，移动开发的凌冬将至，或许早已来临了。苹果的光环正在消退，不只是iOS开发，没有哪种技术是长盛不衰的，对所有的与技术相关的开发者而言: 请勿陷入对技术的狂热之中 自从今年以来，发现了自己的技术短板。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。 最近两年以来，互联网的发展不再像早期那样粗放了，对各种技术人员的需求趋于稳定。“一招鲜，吃遍天”的时代终会落幕，全栈会成为一种趋势。不只贫穷会限制我们的想象力，作为一名开发者，我们因对某项技术的狂热崇拜也会限制我们在业务需求上的想象力。应戒之，慎之。 但无论如何增加知识广度的同时，先扪心自问自己所擅长技术是否全面掌握了。拿我自己来说，也有四年多 iOS 开发经验了，但做的项目都是很普通的那种。这里并不是说普通项目不能提高开发水平，相对于那些业务逻辑复杂的项目，其复杂的关联业务、交互设计会早早的暴露出性能方面的问题，因此，开发者不得不从各方面考虑，最终深入研究这些技术点，并形成最终的优化方案。而普通应用很少遇到性能上的瓶颈，开发者也早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不在积极进取。我管这种开发者叫“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。 这也是很多初级中级 iOS 开发者的共性，没有深入某一具体的方向解决对应的问题，没有自己的技术深度。当我们被全栈开发这种趋势追赶着拼命向前奔命，花费时间、精力学习那些新技术时，需要反思自己有没有达到所擅长领域的技术深度，对掌握的知识，是肤浅还是真正的精通。 互联网发展非常快，每天每个月都有很多的新技术面世。在我们朝着全栈一路狂奔时，需要思考为什么要用这个技术？它能解决什么问题？有什么弊端吗？为了技术而技术，考虑问题的全面性就会差很多。裹足不前不行，盲目追新亦是不行，这里很考验我们对新技术的判断，最终这些技术都要对应业务场景，或许多经历几次因业务需求变化而导致的通宵加班，彻夜上线才会让开发者有所反思，经历几次痛苦的重构才会刻骨铭心吧！ 但无论如何，凌冬将至，大家过冬的粮食都储备充足了吗？ –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"自省","slug":"自省","permalink":"http://XibHe.github.io/tags/自省/"}]},{"title":"利用JenKins持续集成iOS项目时遇到的问题","date":"2017-11-05T16:00:00.000Z","path":"2017/11/06/JenKins-Continuous-Integration/","text":"持续集成(Continuous Integration，简称CI)是一种软件开发实践：许多团队频繁地集成他们的工作，每位成员通常进行日常集成，进而每天会有多种集成。每个集成会由自动的构建（包括测试）来尽可能快地检测错误。许多团队发现这种方法可以显著的减少集成问题并且可以使团队开发更加快捷。 CI是一种开发实践。实践应该包含3个基本模块，一个可以自动构建的过程，自动编译代码，可以自动分发，部署和测试。一个代码仓库，SVN或者Git。最后一个是一个持续集成的服务器。通过持续集成，可以让我们通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。 持续集成的优点 缩减开发周期，快速迭代版本 自动化流水线操作带来的高效 随时可部署 极大程度避免低级错误 持续化集成工具—JenKinsJenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 JenKins的用途: 构建项目自动化打包可以省去开发人员好多时间，重要的是，Jenkins为我们维护了一套高质量可用的代码，而且保证了一个纯净的环境。 可以用来自动化测试，在本地生成大批的测试用例，每天利用服务器不断的跑这些用例。 静态代码分析，可以检测出很多代码的问题，比如潜在的内存泄露的问题。 随时部署，Jenkins在打包完成之后可以设定之后的操作，这个时候往往就是提交app到跑测试用例的系统，或者部署到内测平台生成二维码。 开始安装JenKins方法一: 直接下载安装包需要注意选择自定义安装， 取消”Start at boot as jenKins”的勾选， 安装完成后在Terminal中输入, open /Applications/Jenkins/jenkins.war 即可打开Jenkins 方法二: 使用命令行安装安装JenKins， $ brew install jenkins 若brew无效？则需要安装homebrew， $ ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 启动JenKins， $ jenkins 启动JenKins后使用浏览器访问JenKins， 地址为: http://localhost:8080/ 使用安装包安装后会自动打开，如果端口冲突那么请修改端口 defaults write /Library/Preferences/org.jenkins-ci httpPort 7070 推荐使用方法二安装JenKins，使用命令行可以避免后面构建项目时，报一些莫名其妙的权限错误。 安装插件若使用git做源码管理，则需要安装 GIT plugin GitHub plugin 这两个插件，为了方便管理打包证书，需要安装插件 Keychains and Provisioning Profiles Management 由于需要使用Xcode编译环境，因此必须要安装插件 Xcode integration 下面这两个方式都可以找到插件管理 配置构建环境在配置构建环境前，我们先来导入一下打包证书，点击系统管理，找到刚才添加的插件Keychains and Provisioning Profiles Management，点击选取文件，导入名为login.keychain的钥匙串文件。 这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/管理员用户名/.jenkins/workspace/项目目录名称，(.jenkins是隐藏文件)。 如图所示， 其中，Keychains中的Identities输入项，对应的是刚才点击Upload后钥匙串中的测试证书名称，发布证书名称(需要输入证书名称)。 Provisioning Profiles中对应的是刚才上传的证书配置文件。这些配置文件的存放路径为:/Users/管理员用户名/Library/MobileDevice/Provisioning Profiles 这样Adhoc证书和签名文件就在Jenkins中配置好了，接下来我们只需要在项目的构建配置中指定相关文件即可。 注意: 有些升级了最新的Mac OS系统后，/Users/管理员用户名/Library/keychains目录下没有login.keychain文件，有的是一个名为login.keychain-db的文件，这是需要将login.keychain-db文件copy到桌面，修改成文件名为login.keychain。点击”选取文件“，选取并上传这个修改名称后的login.keychain文件。 导入证书后需要在”系统管理“–&gt;”系统设置“里再设置”Xcode Builder“时，访问证书的全局路径。如图， “Keychain path“为钥匙串的本地路径，”Keychain password“为访问钥匙串的密码。设置完成后不要忘记点击”保存“。 新建项目新建 -&gt; 输入项目名称 -&gt; 选择“构建一个自由风格的软件项目” -&gt; 点击ok就行了。 源码管理如图所示， 其中，Repository URL对应的是svn的路径，Credentials为登录svn时的用户账号密码，点击”Add”按钮添加即可。Check-out Strategy最好选择每次update最新代码前都revert下，而不是“Use ‘svn update’ as much as possible” ，因为我使用的是CocoaPods管理的第三方，每次打包运行pod install会修改了工程配置文件，如果下次自动打包前不先revert再update的话会出现冲突。 构建触发器这里就是告诉jenkins什么时候自动构建,这里我同时设置了每周一到周五在每天的8点到9点之间执行一次,当然也可以不设置。 构建环境勾选“Keychains andProvisioning Profiles Management”和“Mobile Provisioning Profiles”。 这里Code Signing Identity和Provisioning Profile选项中对应上文Keychains and Provisioning Profiles Management插件中导入的钥匙串文件中的证书及证书的配置文件。当然也可以不勾选Mobile Provisioning Profiles。 构建(构建步骤)点击”增加构建步骤”选项，因为我使用的是CocoaPods管理的第三方，打包前先运行pod install –verbose –no-repo-update安装下第三方库。 注意:执行pod install命令时，需要cd到pod文件所在的目录，${WORKSPACE}是项目在JenKins中的工作目录，而我的项目由于多套了一层目录BusinessMall，因此需要加上这层目录${WORKSPACE}/BusinessMall，否则，在构建时就会报: [!] No `Podfile’ found in the project directory. Build step ‘Execute shell’ marked build as failure 的错误。在执行完pod install后，就可以使用Xcode构建项目打包环境了。 添加构建步骤-&gt; Xcode 在”General build settings“中，点击”Settings“按钮设置相关参数。 Target要与Xcode项目中Target的名字对应 Clean before build设置为YES 勾选”Pack application，build and sign .ipa？“的复选框，会弹出设置生成ipa包的几个参数项。如图， Export method，ipa的类型(‘development’, ‘ad-hoc’, ‘enterprise’ or ‘app-store’) .ipa filename pattern，ipa的名称。 Output directory，输出ipa的文件路径。 注意:这里如果Xcode的版本低于9.0，就可以正常输出ipa包。如果Xcode版本不低于9.0，就会由于Xcode 9.0不在允许你访问钥匙串里的内容，而输出ipa失败。具体的解决方法请参照后面”构建项目时遇到的几个问题“中具体的解决方法。 继续设置”Code signing &amp; OS X keychain options“证书信息，如图， 其中，Development Team ID为开发团队ID,可以在钥匙串中的证书详情里查看。勾选Unlock Keychain，显示为之前上传的login.keychain文件。 如果项目使用了cocoaPods,需要配置Advanced Xcode build options,设置 Xcode Schema File，设为Xcode项目中的schema Xcode Workspace File，这里设置绝对路径，不需要带上.xcworkspace后缀。如果项目中没有workspace后缀，那就在“Xcode Project File”上填.xcodeproj文件的路径。 Build output directory，设为${WORKSPACE}/build/ 注意:Xcode Workspace File为绝对路径，也就是Jenkins用于构建项目的workspace目录中，.xcworkspace文件所在目录的路径。 如果路径不正确，则在构建项目时，会报: open BusinessMall.xcworkspace The file /Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall.xcworkspace does not exist. Build step ‘Execute shell’ marked build as failure 的错误。 构建后操作添加构建后操作步骤，使用脚本将生成的ipa包上传到fir或者蒲公英等三方平台，扫码下载安装。 参考http://blog.fir.im/jenkins/使用官方工具fir-plugin-1.9.5.hpi插件上传ipa包到fir。 构建项目时遇到的几个问题1. pod: command not found pod install/var/folders/gn/rqsybgtn7f50w67111kj1hhw0000gn/T/hudson3821369083140563198.sh: line 2: pod: command not foundBuild step ‘Execute shell’ marked build as failure 解决方法: 在系统管理–&gt;系统设置，增加”全局属性”，勾选Environment variables，增加键值对列表。如图， 其中，PATH是固定的，值是在终端输入: $echo $PATH 命令获取，将输入命令后得到的值粘贴过来就可以了。 2. ruby_executable_hooks: No such file or directory Pod: env: ruby_executable_hooks: No such file or directoryBuild step ‘Execute shell’ marked build as failure 从jekyll有时也会报这个错误得到启示，可能是由于执行pod命令的路径粗存在问题。在终端使用命令: $ which pod 查看pod的安装路径为: /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod，而执行pod install的shell的环境变量中可能没有该路径。于是使用命令: $ gem env 查看SHELL PATH:，发现列表中没有/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod这条路径。查阅了一些资料(What it is and How to Modify the Shell Path in macOS Sierra and OSX using Terminal)后，发现可以在根目录的.bash_profile中增加永久的路径。在终端输入命令: $ sudo vi ~/.bash_profile 打开根目录下的.bash_profile文件，将路径/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod插入: export PATH:”/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod:$PATH”结束编辑esc后，输入:wq保存。在终端输入命令: $ source ～/.bash_profile 让这个配置文件在修改后立即生效。此时，再查看gem env发现SHELL PATH:列表中，增加了/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod这条路径。 3. `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException) /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/lib/ruby/ site_ruby/2.2.0/rubygems.rb:271:in find_spec_for_exe&#39;: can&#39;t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException) from /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/lib/ ruby/site_ruby/2.2.0/rubygems.rb:299:inactivate_bin_path’ from /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/bin/pod: 23:in &lt;main&gt;&#39; from /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:ineval’ from /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in `‘ Build step ‘Execute shell’ marked build as failure 子所以在构建项目时出现这个错误，是因为看到一篇文章(cocoapods插件GEM_PATH的配置)，说是修改Xcode中CocoaPods插件的GEM_PATH:中的路径与SHELL PATH:中路径一致就能解决: env: ruby_executable_hooks: No such file or directory 这个错误。于是就在~/.bash_profile文件中增加了一条GEM路径 export GEM_PATH=”/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod” 构建项目后就会报上面的错误，仔细看看，觉得是多了一条无效的执行路径导致的。于是，就删除了那条新添的GEM_PATH，再次构建就不报这个错误了。 4. in `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) in `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) 更新一下gem版本，终端命令如下； $ sudo gem update –system 有时在输入命令后会出现ssh相关的网络错误提示，可以在终端输入命令: gem sources -a http://gems.ruby-china.org/ 将源地址换为ruby-china。 5. 报xcodebuild: error: The workspace ‘Project’ does not contain a scheme named ‘Project’.的错误 Going to invoke xcodebuild:, scheme: Project, sdk: DEFAULT, workspace: Project, configuration: Debug, clean: YES, archive:NO, symRoot: DEFAULT, configurationBuildDir: /Users/ignat/.jenkins/workspace/Project/build, codeSignIdentity: DEFAULT[Project] $ /usr/bin/xcodebuild -scheme Project -workspace Project.xcworkspace -configuration Debug clean build CONFIGURATION_BUILD_DIR=/Users/ignat/.jenkins/workspace/Project/buildBuild settings from command line: CONFIGURATION_BUILD_DIR = /Users/ignat/.jenkins/workspace/Project/build xcodebuild: error: The workspace ‘Project’ does not contain a scheme named ‘Project’.FATAL: Build directory does not exist at /Users/ignat/.jenkins/workspace/Project/build. Potential configuration issue.Build step ‘Xcode’ marked build as failureFinished: FAILURE 在Xcode中，选择Manage Scheme，勾选对应的Shared。 6. 构建时报 NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list. Error Domain=IDEProvisioningErrorDomain Code=9 “”BusinessMall.app” requires a provisioning profile with the Push Notifications feature.” UserInfo={NSLocalizedDescription=”BusinessMall.app” requires a provisioning profile with the Push Notifications feature., NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list.} EXPORT FAILED 最后错误提示，EXPORT FAILED，可知是导出ipa包时出的错。根据提示”provisioningProfiles” dictionary in your Export Options property list.在网上搜了一下这个plist文件的用处，发现原来新版的Xcode 9将不会允许你访问钥匙串里的内容，除非设置allowProvisioningUpdates。 具体的解决方式是: 自己动手写脚本替代插件（插件本质是帮助我们生成打包脚本代码）。于是，在JenKins里，点击项目的”配置“选项，在”构建“中，添加xcodebuild -archivePath，xcodebuild -exportArchive -archivePath的脚本命令，输出ipa包。如图， 具体的脚本命令如下: xcodebuild -archivePath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/output/debug/BusinessMall.xcarchive&quot; -workspace BusinessMall.xcworkspace -sdk iphoneos -scheme &quot;BusinessMall&quot; -configuration &quot;Release&quot; archive xcodebuild -exportArchive -archivePath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/output/debug/BusinessMall.xcarchive&quot; -exportPath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/ipa/debug/&quot; -exportOptionsPlist &#39;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/ipa/debug/ExportOptions.plist&#39; -allowProvisioningUpdates 脚本中的构建路径为JenKins下对应的archivePath，ipa包的输出路径。其中，需要特别注意的是ExportOptions.plist的存放路径。手写ExportOptions.plist文件过于麻烦，不如让XCode帮我们生成。使用XCode 9打包并导出后的文件夹里就有这样一份文件可以直接拿过来用。修改后的plist文件，如图， 之后就在项目所在的目录下，新建一个名为ipa/debug/的目录，将修改后的ExportOptions.plist文件放在这个目录下。在Jenkins中使用SVN管理源码，因此，我需要将这个新增的文件上传SVN，这样在我每次构建项目，输出ipa时就能直接从SVN上拉取这个plist文件，通过设置ExportOptions.plist’ -allowProvisioningUpdates就能访问钥匙串中的打包证书，输出ipa包了。 注意:设置了allowProvisioningUpdates字段后，在打包过程中会弹出是否允许访问钥匙串内容的弹窗，这时需要多次点击“始终允许”按钮。 7. 构建时报error: exportArchive: The data couldn’t be read because it isn’t in the correct format. error: exportArchive: The data couldn’t be read because it isn’t in the correct format. EXPORT FAILED 关掉bitcode重新打包就可以了…… 参考https://forums.developer.apple.com/thread/21193 写在最后中间使用过命令: sudo gem install -n /usr/local/bin cocoapods –pre 重装过CocoaPods，目前CocoaPods的版本为: 1.4.0.beta.2。也可以输入命令: $ sudo gem install cocoapods -v 0.39.0 安装特定版本的CocoaPods。 由于给iOS项目构建版本时必须依赖于xcodebuild环境。现在是在一台Windows上部署Jenkins环境，可以配置节点，在另一台Mac电脑上打包。具体操作，可以参考这篇文章—Jenkins自动打包 配置mac slave节点 参考资料w3cschool Jenkins How to solve “/usr/bin/env: ruby_executable_hooks: No such file or directory”? /usr/local/bin/pod No such file or directory How to delete a gem path? What it is and How to Modify the Shell Path in macOS Sierra and OSX using Terminal 手把手教你利用Jenkins持续集成iOS项目 cocoapods插件GEM_PATH的配置 cocoaPods安装2017 以及遇到的坑 Xcodebuild fails in jenkins with cocoapods xcodebuild commands give different results when run from the command line than when run from within Jenkins Jenkins自动打包 配置mac slave节点 Jenkins+XCode9自动打包错误处理 xcode 9 beta export options not working #9589 Xcode 7 Enterprise Distribution not working –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"持续化集成","slug":"持续化集成","permalink":"http://XibHe.github.io/tags/持续化集成/"},{"name":"JenKins","slug":"JenKins","permalink":"http://XibHe.github.io/tags/JenKins/"}]},{"title":"直播那些事","date":"2017-10-30T16:00:00.000Z","path":"2017/10/31/live/","text":"直播技术经过近两年的迅速发展，已经很成熟了。从十月份开始接触与直播相关的技术，中间花了一周左右的时间，对市面上几种流行的三方直播SDK做了调研和对比。今天是月末最后一天，就做一个阶段性的总结吧！ 更新说明更新记录: 2017 年 10 月，第一版。 2017 年 11 月 11 日，增加相关说明。 2017 年 11 月 13 日，增加直播原理。 直播原理1. 一个完整直播app实现流程1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动 2. 一个完整直播app架构 3. 一个完整直播app技术点 4. 流媒体相关参数帧: 每帧代表一副静止的图像。 帧率: 每秒显示的图片数。影响画面流畅度，与画面流畅度成正比:帧率越大，画面越流畅；帧率越小，画面越有跳动感。 由于人类眼睛的特殊生理结构，如果所看画面之帧率高于16的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。 码率：图片进行压缩后每秒显示的数据量。 分辨率：（矩形）图片的长度和宽度，即图片的尺寸压缩前的每秒数据量: 帧率X分辨率(单位应该是若干个字节)压缩比: 压缩前的每秒数据量/码率 （对于同一个视频源并采用同一种视频编码算法，则：压缩比越高，画面质量越差。） 视频文件格式：文件的后缀，比如.wmv,.mov,.mp4,.mp3,.avi,主要用处，根据文件格式，系统会自动判断用什么软件打开,注意: 随意修改文件格式，对文件的本身不会造成太大的影响，比如把avi改成mp4,文件还是avi. 视频封装格式：一种储存视频信息的容器，流式封装可以有TS、FLV等，索引式的封装有MP4,MOV,AVI等，主要作用：一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、封装起来.注意：会发现封装格式跟文件格式一样，因为一般视频文件格式的后缀名即采用相应的视频封装格式的名称,所以视频文件格式就是视频封装格式。 视频封装格式和视频压缩编码标准：就好像项目工程和编程语言，封装格式就是一个项目的工程，视频编码方式就是编程语言，一个项目工程可以用不同语言开发。 对比几种不同的直播SDK对比市面上常用的直播平台，这里分别是：阿里云、zego、七牛云、腾讯云。这里根据业务需求，对比以上四个平台的指标为：支持的最大连麦上限，是否提供实时视频通话的解决方案，是否提供聊天室功能(IM)，可拓展性等。 阿里云直播阿里云直播中有提供连麦功能，但连麦上限最终确认4人（不能添加上限），不符合公司功能需求。视同阿里云提供的连麦demo，如图， 超过三个连麦观众时会提示：连麦观众不能超过3个。 在阿里云提交工单后，得到了最终的反馈，如图， 最后，联系了技术支持，连麦上限最终为4人。 zego直播zego直播中提供实时视频通话、连麦互动直播和即时通讯功能，实时视频场景的典型使用案例是同一房间内的成员（如微信群视屏），进行实时视频对话同一房间中的用户均可发起视频通话。连麦功能支持20个连麦观众。 提供了实时视频通话的解决方案，如图 七牛云直播七牛云提供强大的直播以及连麦服务，有提供强大的连麦功能，且无上限，受限于客户端的总体带宽，建议8路以下。 腾讯云直播腾讯云分为直播、互动直播、移动直播多种视频服务， 互动直播(ILVB)多对多连麦，最多支持8人同时连麦。移动直播(MLVB)提供即时通讯等一体化直播的解决方案，但最多同时支持3人连麦(见工单)。这二者都是在直播(LVB)基础之上做的延伸拓展。 最后，对比以上四种直播，单从技术上考虑，zego以其一体化的解决方案，超出20路的连麦数，做工精良并频繁更新的Demo被重点考虑。从价格上考虑，阿里云和腾讯云的价格比较有优势。最后暂时选择了阿里云，原因可能是公司的云服务器用的是阿里云吧！ 关于demo该demo为整理后的阿里云直播连麦demo，添加了一些注释，为了突出直播所需的主功能，demo只集成直播所需的基本的API。通过对demo添加Tag，区别不同的功能。其中，Tag为V0.1的版本集成最基本的直播推拉流功能，Tag为V0.2的版本集成连麦功能。点击下载链接 注意:阿里云的连麦demo中并未集成聊天室功能，在引入的SDK中，有一个名为AlivcLiveChatRoom.framework。该SDK暴露的AlivcLiveClient.h文件中，注明了聊天室相关的API，但创建聊天室和发送聊天消息的方法都加了__deprecated_msg的注释： - (void)createChatRoomWithName:(NSString *)chatRoomName success:(void(^)())successBlock error:(void (^)(NSError *error))errorBlock __deprecated_msg(&quot;暂未开放,请勿使用,参考Demo与appServer交互&quot;); - (AlivcLiveChatMessage *)sendMessage:(AlivcLiveConversationType)conversationType content:(NSString *)content success:(void (^)(long messageId))successBlock error:(void (^)(NSError *error, long messageId))errorBlock __deprecated_msg(&quot;暂未开放,请勿使用,参考Demo与appServer交互&quot;); 在阿里云提交工单，工程师回复目前阿里云直播SDK不再提供聊天室功能了。不过通过阿里云DEMO接口文档中所列出的错误码，其中，有返回2040，2050的错误码， 2040 创建环信聊天室失败 2050 消息发送到环信失败 可见，阿里云聊天室之前是环信即时通讯方案，只是现在移除了。接口详情见: DEMO接口文档 写在最后这篇关于直播的文章写得很粗浅，只是记录了阿里云直播SDK的使用。没有详细系统的描述直播原理、主要直播技术及其实现。下面几篇文章对直播做了系统的介绍: 如何开发出一款仿映客直播APP项目实践篇 -【服务器搭建+推流】 如何开发出一款仿映客直播APP项目实践篇 -【原理篇】 如何开发出一款仿映客直播APP项目实践篇 -【采集篇 】 如何开发出一款仿映客直播APP项目实践篇 -【播放篇】 参考资料【如何快速的开发一个完整的iOS直播app】(原理篇)","tags":[{"name":"直播","slug":"直播","permalink":"http://XibHe.github.io/tags/直播/"}]},{"title":"(译)为何许多开发者仍然喜欢用Objective-C，而不是Swift","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/SwiftUsageRate/","text":"iOS SDK已经发布很多年了，开发人员纷纷涌向Objective-C，他们力图通过开发会大卖应用程序而获得丰厚的回报。但那样的时代如今已不复存在了：Swift已经面世三年多了，与Objective-C相比，大大地获取了大家的关注度。 Objective-C - 从应用程序开发世界冉冉升起的明星 - 沦为苹果生态系统中的二等公民。即使OC仍然会在WWDC的一两个板块中被提及，但世界各地的大部分会议都在谈论Swift，苹果正努力推动Swift在教育领域的应用，使用Swift作为主要的语言。 但是如果你仍然在使用Objective-C，你并不孤单 - 许多开发者仍然喜欢使用Objective-C相对于Swift，并且有很好的理由。我与一些Objective-C开发者联系，询问他们是否感觉继续使用Objective-C开发会受到指责，下面的内容就是他们不得不说的… 注意：这里表达的意见是个人意见，可能不代表雇主的意见; 人们按照他们回应的顺序列出; 一些回答在长度上进行了变更。 阻止你将Swift作为开发语言的主要原因是什么？史蒂夫·特劳顿 - 史密斯：我有几个原因避免了Swift。 首先，我不喜欢使用它 - 我发现这个语言比ObjC更难阅读和解析，尤其是在循环和switch语句中的if-let变量赋值（这在Apple的体例中是混乱的，像ARKit一样)。我不是尝试各种不同语言为各种平台编写东西的新手，而且Swift绝对是我见到的可读性很低的语言。 我还不相信苹果参与设计这个语言的初衷 - 四年之后，Swift并不用于iOS，OS或框架的重要部分（我在Twitter上保留了苹果公司的Swift应用程序，macOS很少采用它的新特性相对于iOS来说)。我明白为什么会这样（ABI的稳定性等），但如果苹果没有使用Swift，我不明白为什么我需要代表他们进行beta测试。在Swift准备好之前，我没有什么期待，而且在此期间我获得了Objective-C所带来的一切好处。 我完全相信，只是因为苹果建立了一些东西，并说这是前进的道路并不意味着它是正确的选择。 有趣的是，在最初的几年中，我曾经听说过苹果与Swift的任何人分开，苹果公司当然是大量的ObjC开发人员，而Swift对于许多人来说，对我们来说是一个惊喜。 而且我完全相信，只是因为苹果建立了一些东西，并表示这是前进的道路并不意味着它是正确的选择 - 我们已经看到了一大堆错误（DNS 解析服务 discoveryd，iOS 7，iOS 8）或’mehs ‘（macOS，Touch Bar）在过去几年里，而且看到如何摆脱这些不好因素带来的负面影响。 迈克尔·劳尔：我看不到激励。我在Objective-C方面非常有成效，我将语言视为非常优雅，简洁，富有表现力。如果Swift有一流的（异步）并发，我会高兴的跳起来。相比之下，我听说缓慢的编译时间，大量的运行时库重复，我还没有看到运行时性能的显着提升。 丹·莱弗斯：对于技术原型预演Demo或非常小的项目，我将使用Objective-C，纯粹为了在经过相当长的时间（通常可能与这些类型的客户端）之后的易于更新。我还为许多客户保留了Objective-C应用程序，而且没有时间（或将其切换到Swift的理由）。在Swift中构建这样的项目的代码通常会把它当做演示原型的Demo来简单使用。 彼得·莫尔纳尔：在3.0版本之前，我的主要障碍是缺少源代码兼容性，即使4.0之后，我还在等待ABI的稳定性。我认为这是剩下的唯一一个问题，如果源兼容性有效，我个人觉得这对我来说很重要。 托德·托马斯：Xcode对Swift的支持似乎很好笑。从大型项目的愚蠢长编译时间到重构和调试。Tweetbot for Mac是一个相当可观的项目，在2012款的Retina MBP上编译它需要44秒。这包括1个框架，1个库和应用程序本身。此外，Swift的ABI仍然不稳定 - 当我不需要使用我的应用程序包含的所有库被全部缓慢的构建为应用时。 伊恩·麦克道尔：我们有一大堆共享的C++代码，用于我们的业务逻辑，它与Windows和Android共享。我们在Objective-C中的本地UIKit/AppKit中编写我们的UI，并且有很多Objective-C++文件在两种语言之间桥接。至今，除了几个脚本和内部工具之外，我们还没有采用Swift。据使用Swift的其他团队说，编译时间比Objective-C / C ++慢。 我们有数百个Xcode项目，最终编译成一个巨大的静态库，链接到每个应用程序二进制文件。这样做可以减少应用启动时间。我们花费大概6小时流畅的构建我们的应用，不会增加很多时间。 西蒙·沃尔夫：我的主要编码项目是一个客户端，它是一个已经发展了几年的大型代码库。虽然我也会引入一些Swift进去，因为我做的很多工作涉及到编辑现有的代码，它阻止我使用太多Swift。 我也意识到作为一个开发者，每次有一个新的主要版本的Swift的更新，我都会将那些工作中可以用到拿来用，但这不是我真正需要的。 马科·阿门特：对我来说，这不是对Swift本身的判断，而是一个务实的决定：我已经是Objective-C的专家，在使用它方面极富生产力，而切换到Swift的好处并不足以说服我。 马塞尔·维赫尔：我最多的工作包括一些复杂的元编程和 C 进行部分混合的objective - C的动态消息部分。在使用Swift后所有的这些都会变得更加困难，例如，你无法在Swift中编写CoreData。还很纠结：我只是试图找到一些用Swift编写的Apple Pencil示例代码。结果浪费了我一天时间。 你有没有觉得开发人员可能会对使用Objective-C或者在社交媒体上谈论鄙视？史蒂夫·特劳顿 - 史密斯：真的吗？使用ObjC非常不受欢迎，或者说你喜欢ObjC 胜过 Swift。Swift有一个真正大规模的炒作人群，这个是你无法阻止的。 像任何充满激情的球迷一样，没有任何理由参与讨论。 Swift用户与我一样（或更多）了解其缺点，但是由于感知到的好处，他们很乐意做出妥协。我不是，也不觉得同样的好处。 迈克尔·劳尔： 实际上。我觉得我一直在为自己对Objective-C的认同而保卫自己不受外界的干扰。 我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。 丹·莱弗斯：当然，有一个新的和有光泽的驱动器。这最终有多少的iOS社区呢，所以它不是完全不足为奇，仍然存在很多争议。我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。 彼得·莫尔纳尔：当我正在阅读职位和职位描述时，这种感觉更多，不一定在社交媒体上。大家现在正在寻找高级Swift开发人员。 托德·托马斯：我并没有太多的担心。这个应该让应用程序自己来决定。如果它是好的，用户不会在乎它是用什么语言编写的。 伊恩·麦克道尔：对于仍然使用Objective-C，我感觉到一些耻辱，但并不多。 我使用Swift为我的个人项目，并爱上它，并理解我们在工作中不使用它的原因。 西蒙·沃尔夫：有一点，因为我不相信Swift是坏的，Objective-C是一个真正的Cocoa语言，我不会避免对Swift的利弊的热烈争论。我也没有看到人们对Objective-C开发人员太粗鲁，但作为Mac开发人员，我倾向于处于iOS社区的边缘，这可能是大多数冲突的地方。我不认为Mac开发人员很乐意使用最新最好的。我们还在争为NSCell争论(NSTableView中的NSCel)。 马科·阿门特：这已经开始了，但是每个过渡都是这样发生的。Objective-C开发人员为Carbon开发人员开辟了乐趣。这只是一个自然的发展历程，每当你的语言不在当前考虑范围内的，只要你的语言不被视为“进步语言”。但是你仍然以务实的原因使用它。作为网络上的PHP开发人员，我习惯了这一点。 当你看到开发者会议上大多数时间都在讨论Swift的使用时，你的感受是什么？史蒂夫·特劳顿 - 史密斯：毫无感觉，一个只有Swift的会议是对我没有任何影响。在语言还未完善之前，以及苹果尚未大规模使用之前，我并不关心Swift最佳做法或设计模式。我不想整理十几个社区主导的设计模式，我等待苹果对于Swift的进一步完善。 一个只有Swift的会议是对我没有任何影响。 知道Swift是苹果发展的一个真正的“未来”，已经做了很多工作来推动我彻底远离应用程序; iOS 7 UI与Swift一对一转换的冲击让我觉得这不是我想要开发的平台。 迈克尔·劳尔：这是可悲的。当然，我可以翻译我看到的一切，但比以前付出了更多的努力。而且我拒绝在任何要求使用Swift例子的会议上谈论它。幸运的是，还可以参加一些除了Swift之外的会议。 丹·莱弗斯：至少他们大都一致！ 彼得·莫尔纳尔：我认为这是演变的一部分，但它是真实的 - 在Objective-C周围没有太多的吸引力。Swift是新的，由于它不断变化，有很多话要说，显然这些新的话题也在快速过时。 托德·托马斯：我想如果你想要向前看，开发者会议应该谈论Swift。我不介意个人使用Swift，但也不要过度重视会议上对Swift的讨论。 伊恩·麦克道尔：我感觉很好，这是未来！ 西蒙·沃尔夫：我不介意，我意识到Swift是新的闪亮的东西，因为我知道Swift足够好了解它，真的不用担心我。如果我把我的头埋在沙滩上，而不是继续学习Swift，那么我可能会被遗忘，然而我不认为这种做法有利于成为一个好的开发者。 马尔科·阿门特：它不打扰我。大多数会议组织者和与会者都比我做得更紧密，所以当然应该使用Swift。将Swift代码片段从会议，教程和StackOverflow转换为Objective-C，只是继续使用Objective-C的成本之一，迄今尚未证明特别繁重的。 但随着时间的推移，这种转换负担会增加。 马塞尔·维赫尔：我不得不承认，我发现很多Swift的讨论非常肤浅，经常因为不知情而被嘲笑，所以我感到失望。我知道这听起来很苛刻，而且有明显的例外，然而很仍然感到吃惊。 你认为Swift的引入有助于或阻碍Objective-C作为一种语言的发展吗？史蒂夫·特劳顿 - 史密斯：Swift对于Objective-C开发绝对是灾难性的; 对于任何新的API或功能，我不再具有示例代码，WWDC幻灯片，教程，GitHub或StackOverflow。无论StackOverflow千禧年的笑话，但是失去了对所有这些上下文和知识的访问是毁灭性的。在这方面，ObjC语言本身已经获得了一堆生活质量/语法糖功能，以帮助它更好地与Swift进行交互，所有这些都是梦幻般的。 对于Objective-C开发，Swift绝对是灾难性的。 我非常厌恶为了让Swift存活而使ObjC死去 - 如果两种语言可以彼此独立存在，对于像我这样的开发人员来说是非常好的，他们可以选择最适合手头任务的语言。Swift背后的激情，大规模的推广宣传，苹果停止为开发人员创建ObjC资源。 迈克尔·劳尔：使用Swift的主要好处，“我们”要感谢轻量级泛型和可空性，但这是关于它的。如果背后有相同的人力投入，我只会希望Objective-C能获得Swift这样的好处。 丹·莱弗斯：我认为这最初是有帮助的，但我现在强烈感觉到，这样的做法有些舍本逐末了。 托德·托马斯：我认为这有帮助。他们为Swift的语言添加了许多有用的东西，所以我们不能抱怨。 伊恩·麦克道尔：Objective-C已经从Swift获得了一些很好的功能，包括@available语法和可空性说明符。这是一种稳定的语言，我没有想到它会改变任何事情。 在Swift中打包可能是一个痛苦，但它帮助我在Objective-C中采用更好的打包方式。 西蒙·沃尔夫：对于Swift导致的结果，Objective-C有一些变化和改进，这是有帮助的。另外，写一点Swift也鼓励我去看看我的Objective-C代码是否完美，而且我不太愿意让空对象去操作底层的一些东西。在Swift中打包可能是一个痛苦，但它帮助我在Objective-C中采用更好的打包方式。 马尔科·阿门特：Swift已经有效地停止了Objective-C作为一种语言的开发。 这并不奇怪或不合理，但幸运的是Objective-C相当成熟。前几年Swift的引入带来了许多改进，应该保持Objective-C可用，直到我们大部分人都转移到Swift。 马塞尔·维赫尔：显然受到阻碍，即使Objective-C很好，但Swift的出现结束了Objective-C进一步的发展！ 更令人惊奇和不安的是，一些首选Swift作为语言编写的三方库中有很多明显的缺陷。一些对Swift的改进被阻止，以使Swift看起来不错，虽然我很确定这不是怎么回事。 然而，最大的负面影响就是那些可能阻止Swift后续发展的一系列做法。我们正在尽我们所能创造一种脱离控制的Swift，而苹果忽略了所有这一切。这是一个犯罪。 你怎么看？除了上述所有问题，我还问到人们使用Objective-C已经有多长时间了，因为我认为公平地说，在精通一门语言后，选择继续使用或这彻底放弃时总是很重要。 听到大多数人说他们在iPhone SDK第一次启用或不久之后立即使用Objective-C，几个人已经使用了十多年，其中一个人27了——是的,27岁。我应该补充说，一位回应者表示他们最近开始使用Objective-C，所以也许还存在一些固执的人。 另外还有一件事：去年，我写了一本名为Objective-C for Swift Developers的书，在介绍中，我介绍了一个题为“我喜欢Objective-C”的部分，这里是我写的一些话： 当我阅读本书的第一本完整的草稿时，我想到了自己，“哇，这看起来像是Snark的Objective-C指南”，因为几乎每一章都觉得是在抱怨。 结果，我花了一些时间来编辑这本书，让它更加完美 - 不是因为我试图用人造光线向你呈现东西，而是因为我真的很喜欢用Objective-C编码。在Apple发布Swift时，我就开始使用Swift了，并且在早期就发布了一款Swift应用程序到App Store上。因此，在许多方面，和Swift相比Objective-C只是看起来很糟糕，我已经使用Swift很长时间了，再次使用Objective-C感觉有点像从长期生活的大城市回到老家过圣诞节一样。 我不知道我是否喜欢Objective-C，因为我有斯德哥尔摩综合症，或者是因为苹果的API是如此强大。无论如何，我认为重要的是你意识到，一些令人惊奇的软件已经与Objective-C一起构建，许多人始终如一的爱着她。 当你在这本书中发现让你感到沮丧的事情时，你要温柔一点：这是一种古老的语言，经历了坎坷的发展历程。它为我们提供了很好的服务。至少，在它慢慢远离人们视线时应该被尊重! 谢谢Steve 史蒂夫·特劳顿 - 史密斯，迈克尔·劳尔，丹·莱弗斯，彼得·莫尔纳尔，托德·托马斯，伊恩·麦克道尔，西蒙·沃尔夫，马尔科·阿门特，以及马塞尔·维赫尔，花时间对这篇文章发表观点。 现在结束了 - 如果你仍然喜欢在Swift上使用Objective-C，可以在Twitter上联系我！ 原文地址Why many developers still prefer Objective-C to Swift –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"Swift","slug":"Swift","permalink":"http://XibHe.github.io/tags/Swift/"}]},{"title":"小程序开发总结","date":"2017-09-24T16:00:00.000Z","path":"2017/09/25/wx-mini-AppSummary/","text":"小程序开发结束已经两天了，这是第一个我参与的小程序项目。回顾开发过程中踩过的种种坑，剖析项目中的痛点，需要优化的地方。以后如何避免这样的问题？是否从此入坑H5了？自己的知识短板是什么？ 之前一直从事iOS开发，对web前端没有过多了解。单凭一腔热血去开发小程序，初识比较迷茫，纠结于html和css的样式，js的数据交互等基础知识。但项目周期短，任务重，需要与pc，平板进行数据同步。就没有太多时间去理会前端基础知识，都是现学现用。 就是产品有些坑，设计的小程序产品原型还是是基于原生App的思维。因此，设计出的UI效果图，页面数据展示效果多数是原生App的效果，有些设计甚至与小程序组件相悖。为了实现与UI设计一致的效果，就需要花费很多时间自定义数据交互组件。 开发时没有完全吃透小程序开发文档，在实现某个功能时一直拿不定主意。以下是踩过的一些坑: 小程序页面路径只能是五层，请尽量避免多层级的交互方式。 页面之间传递数据和变量的方式需要统一，不统一传参方式，一旦出现数据展示问题，会增加调试的难度。 一定要将多次调用的功能或样式封装起来，否则，重复相同功能代码会增加.js文件的代码量，使代码不易读。 使用swiper滑块视图容器时，一定要将滑块控制的页面抽离成单独的页面，放在一个页面中，当处理不同页面的数据交互时，会对其他不相干的页面数据造成干扰。 读取页面定义的变量时，不要忘记使用that关键字，把this对象复制到临时变量that，否则会找不到原来的对象。 wx.showToast吐司，当title文字超出限制，不会自适应宽高，需要自定义弹出框。 注意navigator 组件的几种跳转方式的不同之处。 小程序变量不支持下划线命名，若使用下划线命名会造成变量无法赋值。 避免快速点击，多次触发bindtap事件，造成打开多个相同页面。 小程序写着还是很纠结的，这是内心的真实想法: 一定是上辈子缺德事干多了，这辈子才会被安排写小程序！ 通过这次开发小程序的机会，发现了自己的知识短板，正是这些短板让自己裹足不前。以下是短板高发区: 在哪些工作上花费时间最多? 可以改进的重复性劳动 自己没有完全理解的东西 你回答不出来的面试题 对比以上几点快速找出你的技术短板，然后消除它。你必须要确切知道自己需要学什么，保证焦点正确。不要让这些短板成为你的“痛点”。 我是否陷入了对技术的狂热之中？因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。 人生多艰，无暇他顾。 于是我局限在自己的世界中，变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"总结","slug":"总结","permalink":"http://XibHe.github.io/tags/总结/"}]},{"title":"小程序页面跳转","date":"2017-09-15T16:00:00.000Z","path":"2017/09/16/wx.navigateTo/","text":"微信小程序页面跳转API时需要注意，官方文档中强调：“为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。” 也就是说在连续使用navigateTo进行页面跳转时，若当前页面若正好是第5级，则点击该页面任何绑定触发事件的控件，都不会有任何反应。 更新说明更新记录: 2017 年 9 月，第一版。 2017 年 10 月，增加页面跳转流程图及跳转说明。 小程序中页面导航的API为了避免发生超过五级页面而无法跳转的悲剧，首先要了解清楚小程序中页面导航的API。小程序中页面导航API有五个，两个跳转新页面的API分别为wx.navigateTo和wx.redirectTo，一个用来做重置操作的API为wx.reLaunch，一个用于跳转到tabBar的API为wx.switchTab，还有一个API名为wx.navigateBack，用于返回页面。 wx.navigateBack 在小程序的初始版本中只能回到上一个页面，在最新版本的更新中给 navigateBack 添加了一个参数 delta，用于决定需要返回几层页面，返回的页面数，如果delta大于现有页面数，则返回首页。 几种跳转方式的不同之处navigator 组件的默认跳转方式与 wx.navigateTo 相同，而如果添加 redirect 属性，则与 wx.redirectTo 的跳转方式相同。 navigateTo 在官方文档中描述如下： 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面。 通过 navigateTo 跳转后，可点击左上角的按钮返回上一个页面。而如果多次调用 navigateTo 之后，就需要返回多次才能回到初始页面。因此，官方在此处有一个限制。 注意：为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。 不过上述五层的限制只是针对 navigateTo，redirectTo 则无此限制。因为 redirectTo 的行为是： 关闭当前页面，跳转到应用内的某个页面。 注意: 使用redirectTo跳转到一个之前加载过的页面，不会再次调用该页面的onLoad方法。 通过 redirectTo 跳转后，则无法返回跳转前的页面。但并不是无法调用 navigateBack，而是调用之后，会回到使用 redirectTo 跳转前的上一个页面。 页面栈可以通过 getCurrentPages 方法获取： getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。 上述的「页面路径」可以对应为页面栈中的元素，页面栈中的最后一个元素就是当前显示的页面，页面跳转就是新页面入栈的过程。 上述三种页面 API 的区别在于： navigateTo 不会将旧页面出栈； redirectTo 会将旧页面出栈，再将需要跳转到的页面入栈； navigateBack 则是将页面栈最后一个元素出栈，因此倒数第二个元素会成为最后一个元素，即变成「当前页面」。 结合下面这个例子，如图， 小程序包含 A、B、C、D 四个页面，A 页面为首页。小程序启动后，在 A 页面中，我们通过 navigateTo 跳转到 B 页面，然后在 B 页面中再通过 navigateTo 跳转到 C 页面。 如果通过navigateTo跳转到 D 页面，则在D页面调用navigateBack会返回到C页面；如果通过redirectTo跳转到 D 页面，则在D页面调用navigateBack会发现不是返回C 页面，而是返回到了 B 页面。 因为调用redirectTo 跳转到 D 页面，redirectTo 会将当前页面出栈，即将 C 页面出栈，再将 D 页面入栈，这时候，页面栈中的元素则会变为 A、B、D。 navigateTo 不会将旧页面出栈，因此通过 navigateTo 跳转后，页面栈中元素个数会加一，因此在页面栈中元素个数达到 5 之后再调用 navigateTo 会失败，出现无法跳转的错误。 redirectTo 会在将旧页面出栈后，再将新页面入栈，因此通过 redirectTo 跳转，页面栈中元素个数会保持不变，所以即使在页面栈中元素达到 5 个之后再调用 redirectTo 也能成功跳转。 实际业务流程业务流程:点击主页面的“扫码录入”按钮，页面跳转微信扫一扫页面，通过扫描条形码读取商品信息，若扫码到该商品信息存在数据库中，则获取数据库中的信息并将这些商品信息带至至“商品信息”页面，可以在商品信息页面对商品信息进行编辑。编辑结束后，点击商品信息页面底部的保存按钮，保存该条商品的最新信息。 为了在点击页面底部的“保存”按钮后直接跳转至微信扫一扫页面，达到快速扫码录入商品信息的目的。解决方案: 直接返回主界面，点击“扫码录入”按钮，跳转至微信扫一扫页面； 点击底部“保存”按钮后，立即调用wx.scanCode打开扫一扫页面； 方案1直接被否定了，原因是用户会频繁调用扫一扫进行商品信息的录入。如果在用户录入一天商品信息后，返回到主页面，再一次点击“扫码录入”按钮跳转至扫一扫页面进行商品录入或查询。会使得录入这一操作的连续性被打断，降低录入操作整体流畅度。 方案2在点击保存按钮后直接打开扫一扫固然可以保证操作的连贯性，但此时若在扫一扫页面不做扫码操作，而是点击扫一扫左上角的返回按钮，则返回到上个页面—商品信息保存页面。此时，如果点击“保存”按钮会对商品信息进行重复保存。 那么，能否在微信扫一扫页面做相应处理呢？比如，点击扫一扫左上角的返回按钮时，直接返回到首页。由于扫一扫页面是直接调用wx.scanCode而来的，其并不是以压栈的方式出现在页面控制的层级中。因此，无法通过getCurrentPages()函数获取对应的层级关系。 另外一种方式，针对方案2的问题，需要在点击“商品信息”页的“保存”按钮后做出特别处理，于是在点击保存绑定的事件中设置: saveTap: function (res) { wx.request({ url: requestUrl.LookForGoodsUrl data: { &quot;userId&quot;: userId, &quot;goodsId&quot;: numResult, &quot;name&quot;: name, &quot;factory&quot;: factory, }, header: { &#39;content-type&#39;: &#39;application/json&#39; }, success: function (res) { if (res.data.code == &#39;0000&#39;) { // 保存成功 wx.redirectTo({ url: &#39;../homePage/homePage&#39; }) } } }) } 将最新商品信息上传至服务器，关闭当前页面，跳转到应用内的某个页面。再调用: wx.scanCode({ var numResult = res.result; if (numResult.substring(0, 2) == &#39;69&#39;) { wx.request({ url: requestUrl.LookForGoodsUrl data: { &quot;userId&quot;: userId, &quot;goodsId&quot;: numResult, }, header: { &#39;content-type&#39;: &#39;application/json&#39; }, success: function (res) { if (res.data.state == &#39;1&#39;) { // 存在该商品 wx.redirectTo({ url: &#39;../goodsInfo/goodsInfo?goodsChart=&#39; + goodsChart + &#39;&amp;goodsId=&#39; + goodsId, }) } } }) } }) 调用扫一扫，获取商品条码，将获取的条码作为参数上传服务器得到服务器返回的商品信息。再将这些信息传递并跳转至“商品信息”页，展示这些信息。再次扫描商品条码时，重复以上操作。 但是为了在商品信息页面点击“保存”按钮时关闭当前页面，使用了wx.redirectTo，会先返回到首页（homePage），然后再调出扫一扫页面。这期间会出现短暂（大概2~3秒钟）的停顿，停顿期间页面(homePage)仍然可以操作，会误触页面上的其他点击事件。最后，即使在该页面(homePage)加上loading，以防止误触。仍然无法回避短暂停顿后再跳转扫一扫页面的问题。 最后的解决方案是: 点击商品信息页的“保存”按钮后，将该按钮隐藏。这样当从扫一扫页面返回商品信息页时就不会出现重复保存数据的问题了。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"wx.navigateTo","slug":"wx-navigateTo","permalink":"http://XibHe.github.io/tags/wx-navigateTo/"}]},{"title":"爱之初体验 - 小程序","date":"2017-08-31T16:00:00.000Z","path":"2017/09/01/wx-mini-AppBlindDate/","text":"开发小程序已经有两周了，从最开始踌躇满志到现在喜忧参半。这中间经历了许多波折，好像又回到了第一次初恋时的感觉，迫切，含蓄，喜悦，又苦于不能迅速了解对方的方方面面，而感到沮丧。但随着一步步的接触，由浅入深，终会瓜熟蒂落，水到渠成。 框架小程序由视图层，逻辑层，渲染层三部分组成的一整套框架。框架使用自己的视图层描述语言WXML(.WXML文件中使用的是view标签构建视图，相当于CSS中的div标签。)和WXSS，逻辑层是基于JavaScript框架。视图层和逻辑层间微信提供了用于数据交互，事件绑定的丰富组件和API。 框架的核心是一个响应的数据绑定系统。整个系统分为两块: 视图层(View) 和逻辑层(App Service)。框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会发生相应的更新。 组件框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。什么是组件: 组件是视图层的基本组成单元。 组件自带一些功能与微信风格的样式。 一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。 但使用起来还是有些不足，很多组件的风格与微信风格类似，不想使用这种风格的组件就需要自定义组件，而自定义需要花费一些额外的时间，就算自定义成功了，仍需要经过仔细的测试，确保该自定义组件在交互上不会与基础组件产生偏差。 API框架提供了丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。 说明： wx.on 开头的 API 是监听某个事件发生的API接口，接受一个 CALLBACK 函数作 为参数。当该事件触发时，会调用 CALLBACK 函数。 如未特殊约定，其他 API 接口都接受一个OBJECT作为参数。 OBJECT中可以指定success, fail, complete来接收接口调用结果。开发工具 在原有的公众号网页调试工具的基础上，推出了全新的微信开发者工具，集成了公众号网页调试和小程序调试两种开发模式。 在8月30日和8月31日，对开发工具进行了很大的更新。全新的视觉和交互体验，新增了申请测试报告功能，新增WXS功能。 开发中填的坑微信小程序填坑记录希望对你有帮助。 学习心得 多看官方文档，多看几遍，遇到问题时再看，没有问题时继续看； 关注论坛最新动态； 基础知识一定要过关（小程序的框架，组成部分，运行机制，自身限制）； 不要眼高手低，人家的demo下载下来跑起来，看懂之后一定要自己尝试写一遍； 找一个自己熟悉的逻辑，开始模仿（结合实际的项目需求，一步一步解决遇到的问题）。 遗留问题模态窗体上的textarea多行输入框，当滑动整个页面时，会将textarea里输入的内容一起滑动至输入框外部，随着滑动的方向一起滑动。官方文档中备注了关于textarea的一个tip: textarea组件是由客户端创建的原生组件，它的层级是最高的。 或许正是由于textarea是最高层级导致的滑动问题。 demo下载wxModeList 参考资料微信公众平台 | 小程序 小程序中的循环列表，在点击时改变当前项的背景颜色 小程序操作按钮悬浮固定在底部 动态的显示或隐藏控件 微信小程序从子页面退回父页面时的数据传递 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"小程序","slug":"小程序","permalink":"http://XibHe.github.io/tags/小程序/"},{"name":"初体验","slug":"初体验","permalink":"http://XibHe.github.io/tags/初体验/"}]},{"title":"二次筛选功能开发心得","date":"2017-08-22T16:00:00.000Z","path":"2017/08/23/FilterError/","text":"一个类似于京东搜索结果页的筛选功能，侧边栏条件筛选器，根据不同的数据类型进行条件筛选及筛选条件的排列展示。 构建原理及使用到的技术点 RunTime继承组合 遇到的问题 筛选列表距离顶部状态栏距离过近筛选列表展示选中数量限制替换二次筛选结果页数据源循环移除数组元素报错在筛选更多，跳转的搜索页面进行搜索调用两次接口请求 解决的方式替换二次筛选结果页数据源需求中要求替换筛选条件的数据源,表述如下: 选中的选项需要在二次筛选条件选择页中显示，选中的选项为默认展开的选项时，无需变更选项的位置，若选中的不是默认展开的选项，需要将选中的选项放到二次筛选条件选择页中，并代替筛选条件选择页中没被选择的默认展开的选项的位置，按照选中的时间顺序正序占据页面中的默认展开的选项的位置（举例说明：筛选条件选择页中的默认展开的选项是1、2、3、4、5，默认展开的选项选中的是2和4,然后用户点击查看更多的选项，先选了11然后又选了9的选项,根据逻辑，筛选条件选择页中显示的选项依次显示的是：11、2、9、4、5），若选中的选项被取消选择，选项的位置按照选中时的位置显示，不更改选项的位置。 如图，二次筛选结果页和生产厂家搜索列表页 当生产厂家筛选数据源大于6项时，只展示5个生产厂家，并显示“更多生产厂家 &gt;”的跳转提示。点击跳转至生产厂家搜索列表页面，在搜索页面会根据搜索关键字展示所有的生产厂家列表信息。该列表会展示上个页面勾选的生产厂家，并将其置于列表最前面。现在需要做的是: 当勾选列表页中一个或多个生产厂家，该生产厂家是二次筛选结果页(上一个页面)中，默认展示5个生产厂家中从未出现的一个，是一个新的生产厂家。则需要替换掉二次筛选结果页，生产厂家一栏中未被勾选的一个或多个生产厂家，直到全部替换完成。 方案一: 进行多层嵌套循环遍历，判断如果对象的selected属性为YES，则跳出当前循环并做一个标记，再从新进行外层循环。这样就需要设置至少两个以上的标记在循环遍历的基础之上再进行循环遍历。增加了逻辑判断的复杂性，也使代码变得不易读。 针对方案一不足之处，将方案一中的杂糅在一起的逻辑判断抽离成不同的情况，形成方案二。 方案二: 需要定义两个可变数组，_dataList(二次筛选结果页，生产厂家数据源)，_selectList(生产厂家搜索页，所有勾选的生产厂家数据源)。对二者进行嵌套循环遍历，需要考录到三种不同情况，并对这三种情况进行一一判断。① _dataList全部包含了_selectList中的元素；② _dataList不包含_selectList中的元素；③ _dataList包含部分_selectList中的元素。 针对以上三种情况对应的具体步骤: ① 遍历找到_dataList中的_selectList元素，变更生产厂家Model中selected状态，将这些选中的元素放到_dataList中元素位置的最前面； ② 直接将_selectList插入到_dataList的最前面； ③ 先替换，再插入新元素到_dataList中，最后再将生产厂家Model中selected为YES的元素前置到_dataList的最前面位置。 方案二仍需要进行大量的判断，操作起来仍旧复杂。那么，有没有简单粗暴，提刀就干的方案呢？下面就要说说方案三了。 方案三: 在生产厂家搜索列表页面直接进行操作。在二次筛选结果页点击跳转至生产厂家搜索页时，传入已经选中生产厂家的数组_selectList，生产厂家搜索结果列表页的数据源_datalist(包含当前已选中生产厂家的数组_selectList和所有未选中的生产厂家)。点击”确定“按钮时，去除_datalist中已选中的生产厂家的Model，然后使用block反向将去除后的_datalist和_selectList传给二次筛选结果页。 这样在二次筛选结果页就能直接操作已经处理过的筛选数据了，不用再进行复杂的逻辑判断了。总的来说，这种替换原有页面数据源的操作，以后还是在可以对数据源进行修改的页面进行处理，避免最后需要进行复杂的逻辑判断。 参考文档ZYSideSlipFilter Objective-C NSMutableArray mutated while being enumerated? Collection was mutated while being enumerated –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"二次筛选","slug":"二次筛选","permalink":"http://XibHe.github.io/tags/二次筛选/"},{"name":"NSArray enumerate","slug":"NSArray-enumerate","permalink":"http://XibHe.github.io/tags/NSArray-enumerate/"}]},{"title":"重构webView页面间跳转逻辑","date":"2017-08-06T16:00:00.000Z","path":"2017/08/07/reconsiderUrlPush/","text":"在处理webView页面内的跳转逻辑时，需要在当前webView中点击某个按钮push到另一个webView页，在这个新的webView页中仍然可以操作页面上的点击事件，跳转到其他webView页面。于是，这些webView页面可以相互跳转，不断跳转新的或者之前的webView页面。 业务需求点击商品进入到“商品详情”页(GoodInforH5WebViewController)，点击店铺进入“店铺详情”页(ShopInfoH5WebViewController)，其中(“商品详情”页和”店铺详情”页均为webView)。其中，店铺详情页和商品详情页可以相互跳转。 当前逻辑在继承于UINavigationController的自定义导航控制器MyNavigationController里做判断，重写方法: - (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated { if (self.viewControllers.count &gt; 0) { if ([self respondsToSelector:@selector(interactivePopGestureRecognizer)]) { self.interactivePopGestureRecognizer.delegate = nil; } viewController.hidesBottomBarWhenPushed = YES; if ([viewController isKindOfClass:[GoodInforH5WebViewController class]] || [viewController isKindOfClass:[ShopInfoH5WebViewController class]]) { viewController.navigationItem.leftBarButtonItem = [UIBarButtonItem itemWithTarget:self action:@selector(backRootViewController) image:@&quot;navigation_back&quot; highlightImage:@&quot;navigation_back&quot;]; } } [super pushViewController:viewController animated:YES]; } 重写GoodInforH5WebViewController和ShopInfoH5WebViewController的返回事件。即，backRootViewController。在backRootViewController方法里做相应页面的跳转操作。 在GoodInforH5WebViewController页面的viewWillAppear方法里进行页面跳转逻辑的判断。如下: 前方高能预警!!! - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:NO animated:NO]; //[_webView reload]; CLog(@&quot;self.navigationController.viewControllers count = %ld&quot;,[self.navigationController.viewControllers count]); CLog(@&quot;self.navigationController.viewControllers = %@&quot;,self.navigationController.viewControllers); // 若是经首页;分类列表页面;订单中心;商业店铺列表页;我的收藏,且viewControllers&lt;5,则设置pop回上一页的标识;商家促销,且viewControllers&lt;5,则设置pop回上一页的标识 if ([_fromWebUrl isEqualToString:@&quot;home_bussinessUrl&quot;] || ([_fromWebUrl isEqualToString:@&quot;assortment_searchByCate&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@&quot;sellOrderCenter_buyOrders&quot;] || ([_fromWebUrl isEqualToString:@&quot;My_collectionListUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@&quot;businessShopSearchList_goodInfo&quot;] || ([_fromWebUrl isEqualToString:@&quot;ActivityViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || ([_fromWebUrl isEqualToString:@&quot;BusinessPromoteViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5)) { [[NSUserDefaults standardUserDefaults] setObject:@&quot;1&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@&quot;search_searchByKey&quot;] || [_fromWebUrl isEqualToString:@&quot;business_shopSearch&quot;] || ([_fromWebUrl isEqualToString:@&quot;home_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 6) || [_fromWebUrl isEqualToString:@&quot;businessShopSearchList_shopInfo&quot;] || ([_fromWebUrl isEqualToString:@&quot;home_productDetailUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 4) || ([_fromWebUrl isEqualToString:@&quot;ShopCarListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 4)){ // 从GoodsListViewController跳转至原生商品详情页面;从顶部搜索等页面跳转至原生商品详情页面; 从商业店铺搜索结果列表页跳转,点击返回至self.viewControllers[2]的页面;若是从搜索首页，分类的搜索结果页跳转而来,返回搜索商品列表页;若是从商业店铺列表页跳转而来，则返回到店铺详情的H5页面;从首页商品--&gt;商品详情--&gt;店铺详情--&gt;商品详情，并且viewControllers&gt;=4，则返回店铺详情页;从原生购物车跳转而来,且viewControllers&gt;=4，则返回店铺详情页; [[NSUserDefaults standardUserDefaults] setObject:@&quot;2&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@&quot;shopInfor_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 7) || ([_fromWebUrl isEqualToString:@&quot;assortment_searchByCate&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;My_collectionListUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;ActivityViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] == 5)) { // 若是从商业店铺详情搜索跳转而来;若是从分类列表页跳转而来;若是从我的收藏跳转而来，且viewControllers&gt;=5，则返回店铺详情页面。 [[NSUserDefaults standardUserDefaults] setObject:@&quot;3&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if (([_fromWebUrl isEqualToString:@&quot;home_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 6) || ([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 6)) { // 从搜索商品列表--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=6，则返回店铺详情页；从订单详情页--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=6，则返回店铺详情页； [[NSUserDefaults standardUserDefaults] setObject:@&quot;4&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else if ([_fromWebUrl isEqualToString:@&quot;shopInfor_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 7) { // 从搜索商品列表--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=7，则返回店铺详情页。 [[NSUserDefaults standardUserDefaults] setObject:@&quot;5&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } else { [[NSUserDefaults standardUserDefaults] setObject:@&quot;0&quot; forKey:KPopHomeIndentify]; [[NSUserDefaults standardUserDefaults] synchronize]; } } 这里是通过设置一个名为KPopHomeIndentify的NSUserDefaults对象用于存储navigationController中，当前页面的层级。通过设置一个名为_fromWebUrl的字符串，用于判断是哪个页面跳转而来的。二者结合起来，设置经过GoodInforH5WebViewController页面的返回逻辑。 当触发商品详情页的跳转链接时，需要在webView的shouldStartLoadWithRequest代理方法里做判断，当request的绝对地址中包含店铺详情的路径时，则push到店铺详情页。如下: #pragma mark - UIWebViewDelegate -(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { _absoluteUrl = [request.URL absoluteString]; // push到店铺详情页面 if ([_absoluteUrl rangeOfString:@&quot;appLink/showBusyInfo?&quot;].location != NSNotFound) { ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init]; shopInforH5WebVC.webUrl = _absoluteUrl; shopInforH5WebVC.fromWebUrl = _fromWebUrl; [self.navigationController pushViewController:shopInforH5WebVC animated:YES]; return NO; } else { return YES; } } 再回到自定义导航控制器MyNavigationController重写的返回事件中: - (void)backRootViewController { CLog(@&quot;self.viewControllers = %@&quot;,self.viewControllers); NSString *popIndentify = [[NSUserDefaults standardUserDefaults] objectForKey:KPopHomeIndentify]; UIViewController *viewCtl; if ([popIndentify isEqualToString:@&quot;0&quot;]) { viewCtl = self.viewControllers[0]; } else if ([popIndentify isEqualToString:@&quot;1&quot;]) { viewCtl = self.viewControllers[1]; } else if ([popIndentify isEqualToString:@&quot;2&quot;]) { viewCtl = self.viewControllers[2]; } else if ([popIndentify isEqualToString:@&quot;3&quot;]) { viewCtl = self.viewControllers[3]; } else if ([popIndentify isEqualToString:@&quot;4&quot;]) { viewCtl = self.viewControllers[4]; } else if ([popIndentify isEqualToString:@&quot;5&quot;]) { viewCtl = self.viewControllers[5]; } [self popToViewController:viewCtl animated:YES]; } 同样是结合GoodInforH5WebViewController中设置好的KPopHomeIndentify进行判断。根据KPopHomeIndentify存储的导航控制器中的页面层级，在导航控制器中通过这些层级获取到对应的页面viewController，最后popToViewController到这些页面中。 重构原因看了上面那一片高能预警的代码逻辑，重构原因就不言而喻了。 *逻辑判断复杂，每次新增与商品详情，店铺详情相关页面时，都需要新增一系列对应页面层级的判断逻辑； *给调试造成困难，与商品详情，店铺详情关联的页面很多，需要进行多场景的关联测试； *最重要的一点:每次从商品详情页跳转到店铺详情都需要重新重新alloc一个新的ShopInfoH5WebViewController对象，耗费了很多资源。 重构逻辑通过设置NSUserDefaults存储页面层级方式进行页面跳转的逻辑，不易操纵，并且非常的不合理，也降低了代码的可读性。设想一下，这里之所以明确不同跳转页面在navigationController中的层级关系，是为了返回操作能回退到指定页面。而导致该冗余代码的罪魁祸首是:每次触发商品详情页或店铺详情页的跳转链接时，都会重新alloc一个新的对象。在进行多次跳转操作后，navigationController中控制的层级就会一直增加，若想在pop操作时跳转到指定页面，就必须明确所要跳转页面在导航控制器中的层级。 那接下来的操作就很明确了，首先移除GoodInforH5WebViewController中viewWillAppear里的一堆判断代码；然后，在webView的代理方法shouldStartLoadWithRequest中增加跳转判断，如下: #pragma mark - UIWebViewDelegate -(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { _absoluteUrl = [request.URL absoluteString]; CLog(@&quot;_absoluteUrl = %@&quot;,_absoluteUrl); // push到商业店铺详情页面 if ([_absoluteUrl rangeOfString:@&quot;appLink/showBusyInfo?&quot;].location != NSNotFound) { UIViewController *shopInfoH5WebViewController; for (shopInfoH5WebViewController in self.navigationController.viewControllers) { if ([shopInfoH5WebViewController isKindOfClass:[ShopInfoH5WebViewController class]]) { // addExtractBankCardVCIndex = [self.navigationController.viewControllers indexOfObject:addExtractBankCardVC]; [self.navigationController popToViewController:shopInfoH5WebViewController animated:YES]; break; } else if ([shopInfoH5WebViewController isKindOfClass:[GoodInforH5WebViewController class]]) { ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init]; shopInforH5WebVC.webUrl = _absoluteUrl; shopInforH5WebVC.fromWebUrl = _fromWebUrl; [self.navigationController pushViewController: shopInforH5WebVC animated:YES]; break; } } return NO; } else { return YES; } } 这里遍历navigationController.viewControllers中所有视图控制器。如果存在店铺详情(ShopInfoH5WebViewController)对象类，则直接popToViewController到该控制器中；如果不存在，则alloc一个新的店铺详情(ShopInfoH5WebViewController)，并pushViewController到该页面。 最后仍然需要在自定义导航控制器MyNavigationController重写的返回事件（backRootViewController）中做跳转的逻辑判断。如下: - (void)backRootViewController { CLog(@&quot;self.viewControllers = %@&quot;,self.viewControllers); // 当前视图控制器 UIViewController *currentVC = [self.viewControllers lastObject]; // 视图控制器的层级 NSInteger currentVCIndex = [self.viewControllers indexOfObject:currentVC]; // 上一个页面的视图控制器 UIViewController *previousVC = self.viewControllers[currentVCIndex - 1]; if ([currentVC isKindOfClass:[GoodInforH5WebViewController class]]) { if ([previousVC isKindOfClass:[ShopInfoH5WebViewController class]]) { [self popToViewController:previousVC animated:YES]; } else { [self popViewControllerAnimated:YES]; } } else if ([currentVC isKindOfClass:[ShopInfoH5WebViewController class]]) { // 其他会跳转到店铺页面视图的跳转逻辑 UIViewController *previoussLastVC; if ((currentVCIndex - 2) &gt;= 0) { previoussLastVC = self.viewControllers[currentVCIndex - 2]; } else { previoussLastVC = [self.viewControllers firstObject]; } if ([previousVC isKindOfClass:[GoodInforH5WebViewController class]] ) { // 我的积分跳转 if ([previoussLastVC isKindOfClass:[OrderDetailsViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 我的收藏 else if ([previoussLastVC isKindOfClass:[MyCollectionViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 分类 else if ([previoussLastVC isKindOfClass:[LonchH5WebController class]] &amp;&amp; [self.viewControllers[0] isKindOfClass:[AssortmentViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } // 首页，分类搜索结果页 else if ([previoussLastVC isKindOfClass:[SearchResultViewController class]]) { [self popToViewController:previoussLastVC animated:YES]; } else { [self popToRootViewControllerAnimated:YES]; } } else { [self popViewControllerAnimated:YES]; } } } 这里通过获取当前页面层级，以及当前页面上一个页面的层级，通过这些层级做相应的跳转操作: 如果当前页面是商品详情页(GoodInforH5WebViewController)，再进一步判断它的上个页面是否为店铺详情页(ShopInfoH5WebViewController)，若是则popToViewController到上个页面，否则直接popViewControllerAnimated； 如果当前页面是店铺详情页(ShopInfoH5WebViewController)，则需要判断当前视图层级是否越界(当前页面层级currentVCIndex不会超过3级，可能会遇到导航控制器中只有1个视图控制器的情况)，这里与商品详情页不同的是:增加了其它会跳转到店铺页面视图的跳转逻辑。需要对这些页面（积分、我的收藏、分类、搜索结果页）的跳转进行判断。 总结事不过三，过则重构! –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"重构","slug":"重构","permalink":"http://XibHe.github.io/tags/重构/"}]},{"title":"(译)一个给iOS App瘦身的奇怪窍门","date":"2017-07-22T16:00:00.000Z","path":"2017/07/23/One Weird Trick to Lose Size/","text":"流行的社交网络应用程序超过400M。每周更新一次，每年你下载的应用总量接近20G。 自从我们推出了Halide，我们听到的最令人意想不到的赞美就是它的大小。 在11M，我们将在一年内推出较少数据的更新，而不是社交网络应用进行频繁更新。 一个朋友问道：“所以你没有使用Swift。” 毕竟，Swift将其标准库捆绑到你的应用程序中，使应用大小增大。 Halide几乎完全是使用Swift编写的。 我们是怎么做的？ 我们从技术位开始吧。 这里有很多关于如何减少App大小的重要评论。 测量，不要猜从Xcode导出版本构建。 选择“Save for Ad Hoc deployment.”。假设你的应用程序支持app thinning（此时真的应该这样做），请选择“Export for Specific Devices.”。确保选中“ Rebuild from bitcode ”。 你不仅可以获得最终包的大小，还可以获得App Thinning报告。检查你的应用程序包，找到最大存储空间的占用者。 使用 Asset Catalogs将资源保存在资源目录中。当你上传应用程序时，Apple将其分解为特定设备的版本，因此具有2x屏幕的设备不会获得3x资源，反之亦然。 运行 PNG-crush将资源放入目录之前，请运行pngcrush。 根据QA1681，Xcode将自动压缩资源目录之外的PNG资源。 尝试JPEG格式照片由于UI资源格式限制以及PNG格式资源更加精细。这可能构成了你应用程序中大部分资源，但如果你有照片，请尝试使用JPEG格式。这样做会有些压力。 现在进入到一个困难步骤的实现经过这么辛苦的工作，你只能删掉一个100M项目中几M的文件。我不知道如何告诉你，但你需要更少的代码。 选择正确的方式Halide有大概15000行用Swift编写的代码。这包括一个实时视频处理器，一系列自定义控件，以及我们控制AVFoundation的平台。有趣的是我并没有写代码。 通过使用自动布局，我绘制了数千条样板。许多开发人员仍然坚持手工布局。也许他们不明白自动布局，也许他们听到朋友的朋友关于自动布局如何缓慢的言论。（事实并非如此。） 我看到太多的开发人员 - 特别是在大型公司 - 发明内部布局引擎。这简直太疯狂了。当Apple在操作系统上捆绑一个精细的布局引擎时，不要用自己定制的框架来增大应用程序。 我们可以通过删除Interface Builder来减少100k。用户手册和设置几乎完全是具有约束条件的IB。相机UI的高级布置也类似如此。但我们认为短期内开发进度是值得肯定的。 避免Library过大检查许多大型应用程序的包，你会发现几十个第三方框架，大小从100k到几兆。 我不使第三方库。这虽然有点极端，但我们有一个独特的情况。 很多第三方库不具备我们所需要的功能。iOS开发社区拥有大量的JSON映射器，但对于DNG文件的低级操作没有任何意义。 但是我之前提到的视频处理呢？我可以听到你大声喊叫，“GPUImage是可扩展的！你的做法太疯狂了!” 从我对Periscope的堆栈的经验来看，我们看到从GPUImage到内部解决方案的巨大收益。如果实时图像处理不是你业务的一部分，GPUImage就会很好。但是鉴于我们对Halide的长期愿景，以及实时渲染的作用，重要的是能掌控这样的组件。 由于文件太大，我从未引入过GPUImage。但是作为自己疯狂的结果，我避免了在我们的应用程序中捆绑125个未使用的过的滤镜。 PSPDFKit具有相似的成功经验，取代了太大的框架： 我们很高兴地告诉你，使用PSPDFKit 6.8 for iOS，我们重写了数字签名实施的核心，以改进检测，验证和更好的错误报告。因此，我们也设法完全放弃了对OpenSSL的依赖，从而减少了二进制文件的大小。 不要感染 Not-Invented-Here 综合征，有很多理由来避免使用三方库。 不要在分析和A / B测试中浪费资源我们不会使用任何第三方分析或崩溃报告服务。首先，我们不是很乐意将用户数据发送给广告公司。让我们暂停这样的想法。 数据不是免费的。在大型应用中，每个动作都会记录一个分析事件。大型应用程序需要日志记录基础设施 - 唯一标识用户，重复数据删除请求，缓存日志，重试失败等。这些操作都会进行叠加。 A / B测试更糟糕。你的典型社交网络应用程序由于没有人使用而死在的A / B测试上。 我们出于代码膨胀的考虑避免了分析和A / B测试。这只是我们的产品理念。知道太多的数据会扭曲你的想法。你发现自己在优化某个不存在的特殊场景，而不是真的去关注用户实际会不会有这样的需求。 所以我们使用苹果分析。它只是简单的记录，没有任何代码更改。并且免费。它尊重用户的隐私，需要选择加入。我们的选择加入率为32％，这对我们的需求是很好的。 有分析的时间和地点。我们不确定我们的最优价格，所以我们可以在那里进行实验。然而，我们在业务驱动的分析和产品开发之间保持隔离。 你需要一致的目标我们是一个两个人的开发团队。我们通过销售产品赚钱。我们顺其自然的成长。当用户高兴时，他们会向朋友们推荐我们。小应用让我们开心，我们认为用户也很开心。 我们的建议并不能帮助应用程序包很大的App。社交网络通过广告赚钱，广告客户需要详细的分析广告定位。 大型应用程序拥有数百名开发人员，组成数十个团队，每个团队都有独立的季度目标。 你走的越快，你达成的目标越多，你的晋升越有可能。 想想这是可以理解的，“这个三方库节省了我们一个星期的开发时间，但是在我们的应用程序中增加了1M。那么我们的App已经是几百M了，还有其它办法吗？” 大型组织充满带来意想不到后果的合理想法。 据说工程师想得到提升。输送功能不会让你达到目的。建立一个新的布局引擎。该公司甚至获得了工程博客的招聘诱饵。 唯一的解决方案是高层领导宣布：“我们将减少我们的应用程序大小。”不幸的是，科技CEO们不会使用8G的储存空间的iPhone，他们不会生活在网速受限的地区。 这不是一个毫不费力的努力。自从Halide发布以来，我们收到了来自世界各地的大量消息，感谢我们努力保持App的小巧。 减小App安装包大小真的有一个奇怪的伎俩：专注于你的客户。 原文地址One Weird Trick to Lose Size –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"App瘦身","slug":"App瘦身","permalink":"http://XibHe.github.io/tags/App瘦身/"}]},{"title":"第一个父亲节","date":"2017-06-17T16:00:00.000Z","path":"2017/06/18/First-father's-day/","text":"我和妻子是大学同学，在恋爱长跑五年后结了婚。妻子老家不是我们那边的，但是在同一个省，最开始的地域原因，造成了我家人对她的偏见。我们俩克服了种种阻碍，在15年情人节那天领了证。 我们的小孩比计划来的早，妻子一直很期待在猴年能生一个聪明伶俐的猴宝宝。当得知自己要作父亲的那一天，内心感受是复杂的，有期待，也有忐忑。觉得自己没有做好成为一个父亲的准备。伴随着孩子快要出生，我的这种焦虑感越发的明显了。在妻子待产期间，没有全身心的去照顾她，总是把工作中的压力和不快带到家里。终于，在一个周三的早上爆发了…… 最后，还是妻子在妻子的安慰下，我才渐渐平复了自己的心情。 由于老家人和妻子之间的矛盾，再加上我父母都不在老家，不能照顾快要临产的妻子。最终选择在我妻子老家待产。孩子出生那天的凌晨十二点多，那时我并不在妻子身边，电话那头当妻子告诉我小家伙出生了，是个男孩时，我就再也控制不住自己的激动，惊喜，幸福的感情了。当得知妻子由于羊水不足而剖腹产时，听着电话一头，妻子有气无力的声音。当时真想给自己一巴掌，我没有尽到作丈夫的责任，在妻子临盆时不能陪在她身边，给她鼓励，让她安心。还让我岳母，一个50多岁，腿脚不便利的老人家为我妻子跑前跑后，楼上楼下的张罗妻子生产的一切事宜。 像我这样的渣男竟然还有女人给我生孩子，把自己的终身幸福托付给我。我上辈子一定是积了什么大功德了！无法忘记第一次见到小家伙的场景，他紧握着一双小手，眼睛半闭半睁，好奇的打量着周围的一切。虽然我嘴上一直在埋怨小家伙让他妈妈挨了一刀，但心里还是对他充满了怜爱。唯一遗憾的是，陪在她们母子身边的时间太短，不等小家伙满月我就不得不离开她们母子俩，带着不舍与留恋重新投入到工作中。 这次端午节回家，小家伙给了我一个大大的惊喜。刚一见面，盯着看了我半天，然后就用一双小手抚摸我的脸，最后，嘿嘿一笑，扑到我的怀里。那一刻，时间仿佛静止，而我又找到了初恋的感觉[害羞]。这不禁又让我感慨了一番：不能时刻陪在你身边，经历你的成长，听到你第一次喊爸爸。终究是我无法弥补的遗憾。这里不奢望能得到你的原谅，只希望将来的某一天你能理解。成年人的生活里没有容易二字。爱❤你我的小宝贝！ 再过一个多月我们家宝宝就一岁了，这一年来我经历了很多，也成长了很多。感谢妻子的宽容和奉献，她总是迁就我的时不时就发作的小情绪，安慰我，鼓励我，支持我。尽她最大的力量来爱我和儿子。爱❤你我的大宝贝！你和儿子就是我的一切，我的天下无双。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"父亲节","slug":"父亲节","permalink":"http://XibHe.github.io/tags/父亲节/"}]},{"title":"《黑客与画家》小记","date":"2017-05-30T16:00:00.000Z","path":"2017/05/31/hacker-and-artist/","text":"郭一刀推荐的一本书，一本关于创业经历，软件开发，个人品味的书。也许是书中的章节相互独立，给我的感觉像是集合了众多的tips。而这些闪光点，或是忠告，或是建议，或者结合了很多事实而形成的结论。读后给我一种醍醐灌顶的感觉，Paul结合自己的创业和开发经历，将计算机编程的本质娓娓道来。全书大致分成三个部分: 解释了什么是黑客，黑客是如何看待这个世界的。 黑客去的成果，这些成果对世界的影响，如何创造财富？用黑客的方法防止垃圾邮件。 黑客心目中完美的编程语言是什么样的，为什么黑客如此执着于设计新的编程语言。 Paul是世界上首个互联网应用程序Viaweb的开发者之一。创建的Viaweb公司后来被雅虎收购，改名为Yahoo!Store。后来Paul成为一名资深的投资人，作为一名成功的创业者同时也是一名熟练使用Lisp语言的专家。他的经历很生动，完美诠释黑客文化的基础和核心。其中是我印象深刻的是一段关于如何促成潜在的买方掏钱收购自己创业公司的论述: 大多数时候，促成买方掏钱的最好办法不是让买方看到有获利的可能，二手让他们感到失去机会的恐惧。对于买家来说，最强的收购动机就是看到竞争对手可能收购你。我们发现这会使得CEO们连夜行动。次强的动机则是让他们担心如果现在不买你，你的高速成长将使得未来的收购耗资巨大，甚至你本身可能变成一个他们的竞争对手。 Paul曾经学习过绘画，绘画是一门艺术性很强，同时需要欣赏者有着相应的鉴赏和审美能力的创作方式。Paul总是能将自己的编程和创业经历与之结合起来，切中要害的指出二者之间的联系。 关于设计者的品味，只要你开始思考这个问题，你就会发现不同的领域对于“美”的理解有着惊人的相似度。优秀设计的原则是许多学科的共同原则，一再反复地出现。 好设计是简单的设计 好设计是永不过时的设计 好设计是解决主要问题的设计 好设计是启发性的设计 好设计通常是有点趣味性的设计 好设计是艰苦的设计 好设计是看似容易的设计 好设计是对称的设计 好设计是模仿大自然的设计 好设计是一种再设计 好设计是能够复制的设计 好设计常常是奇特的设计 好设计是成批出现的 好设计常常是大胆的设计 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"《黑客与画家》","slug":"《黑客与画家》","permalink":"http://XibHe.github.io/tags/《黑客与画家》/"}]},{"title":"使用JSExport进行JS交互时遇到的一个问题","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/使用JSExport进行JS交互时遇到的一个问题/","text":"在使用JSExport与OC和JS进行通信，遇到一个问题，无法调用JS传递的最新购物车商品数量的交互方法。 解决方法将之前的放在VC里的JS交互方法抽离到单独的一个类中，这个类继承NSObject。不做任何特别的处理，将 JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; context[@&quot;jsObject&quot;] = self; 这句代码，从 - (void)webViewDidFinishLoad:(UIWebView *)webView 移到， - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType 该代理方法中，就能每次都调用JS与OC的交互方法。 JavaScriptCore使用注意JavaStript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换，而在回调JavaScript方法的时候最好是在刚开始调用此方法的线程中去执行那段JavaStript方法的代码。 参考文献iOS js oc相互调用（JavaScriptCore）（二）ios 与 js交互一点心得 Demo点击下载 遗留问题这里只有获取购物车最新商品数量时，无法调用JS交互方法，其他的JS交互方法仍然可以调用。那么获取JSContext的时机是什么 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"JSExport","slug":"JSExport","permalink":"http://XibHe.github.io/tags/JSExport/"},{"name":"JS里通过对象调用方法","slug":"JS里通过对象调用方法","permalink":"http://XibHe.github.io/tags/JS里通过对象调用方法/"}]},{"title":"(译)HTTPS的工作原理","date":"2017-04-26T16:00:00.000Z","path":"2017/04/27/HTTPS/","text":"HTTPS只是标准HTTP协议涂上一层美味的SSL/TLS加密信息。 除非出现严重错误,它可以防止人们因infamous Eve查看或修改那些构成你浏览中产生的请求；让你可以安全的在你的电脑和服务器之间发送密码、通信和信用卡信息等数据。当绿色小挂锁和字母“https”出在你的地址栏时，并不意味你所访问的网站仍是之前的，而不是已经被篡改过的，当你打开网页时这些标识至少帮助你安全地访问网页。 1.什么是HTTPS以及它做了什么?HTTPS是著名的HTTP协议，是在SSL / TLS(以下简称为“SSL”)加密层之上。服务器和客户端仍然通过完全相同的HTTP协议进行通信，但二者的通信是建立在一个安全的SSL连接,加密和解密请求和响应体系之上的。SSL有两个主要目的: 验证你所访问的服务器的正确性 确保你与服务器之间的数据通信，无论是你发送给服务器的还是服务器返回给你的信息不被篡改 真正非常聪明的部分是任何人都可以拦截您与服务器交换的每一个消息，包括您同意使用密钥和加密策略的消息，仍然无法读取任何实际发送的数据。 2.如何建立SSL连接通过握手建立客户端和服务器之间的SSL连接，其目的是: 为了确实与客户端通信服务器的正确性 双方已经同意一个“密码套件”，其中包括二者将用于交换数据的加密算法 双方已就此算法达成任何必要的密钥 一旦连接建立，双方可以使用约定的算法和密钥来安全地发送消息给彼此。我们将把握手分为3个主要阶段 - 发送Client Hello报文，证书交换和密钥交换。 1.客户端发送Client Hello报文 — 握手开始于客户端发送Client Hello报文。这包含服务器通过SSL连接到客户端所需的所有信息，包括各种密码套件及其支持的最大SSL版本。服务器使用Server Hello报文进行响应，报文中包含客户端所需的类似信息，包括根据客户端的偏好决定将使用哪个加密套件和SSL版本。 2.证书交换 — 现在连接已经建立起来了，服务器必须向客户端证明其身份。这是使用SSL证书来实现的，这是一个很小的类似于护照的东西。SSL证书包含各种数据，包括所有者的名称，附加的属性（例如域），证书的公钥，数字签名和有关证书有效期的信息。客户端检查隐式信任该证书，或者它被隐式信任的几个证书颁发机构（CA）之一被验证和信任。更多关于证书的要求。注意服务器还可以要求通过证书证明客户端的身份，但这通常只发生在非常敏感的应用程序中。 3.密钥交换 — 客户端和服务器交换的实际消息数据的加密将使用一种对称算法来完成，该算法在发送Client Hello报文阶段已被认可。对称算法使用单个密钥进行加密和解密，与需要公钥/私钥对的不对称算法相反。双方需要就此单一的对称密钥达成一致，即使用非对称加密和服务器的公钥/私钥可以安全地实现这一过程。 客户端生成用于主对称算法的随机密钥。它使用在发送Client Hello报文阶段中同意的算法和服务器的公钥（在其SSL证书上找到）对其进行加密。它将此加密密钥发送到服务器，使用服务器的私钥对其进行解密，握手会话中有趣部分就这样完成了。双方都充满乐意，如同他们正在和正确的人交谈，并且秘密地同意对对方加密他们即将发送的数据的密钥。HTTP请求和响应现在可以通过对明文消息进行加密后发送。 3.证书3.1信任在最基本的层次上，SSL证书只是一个文本文件，任何具有文本编辑器的人都可以创建一个。实际上，您可以创建一个证书，声称您是Google Inc.，并且你掌握域名gmail.com。如果这是事实，SSL就是一个笑话;身份验证基本上是客户端询问服务器“你是Google吗？”，服务器回复“呃，是的，这是一张纸，’我是Google’写的”，客户说“好，这是我所有的数据”。阻止这场闹剧的魔法是在数字签名中，允许一方验证另一方的纸张是否合法。为什么你可能信任证书有两个明智的原因： 如果它在你隐含信任证书的列表上 如果能够证明它是被上述列表中的一个证书的控制器所信任 第一个标准很容易检查。您的浏览器具有可从其中查看，添加和删除证书颁发机构(CA)可信SSL证书预先安装的列表。这些证书由一个集中的（在理论上，一般在实践中）组织来控制，这些组织非常安全，可靠和值得信赖，如Symantec，Comodo和GoDaddy。如果服务器从该列表中提供证书，那么您可以信任它。 第二个标准很难。服务器很容易说：“er，我的名字是er，来自微软，你信任Symantec和er，他们完全相信我，所以很酷。”一个有点聪明的客户端可能会去问Symantec“我有一个来自微软的服务请求，说你相信他们，这是真的吗？”但即使Symantec说“是的，我们知道他们，微软是合法的”，您仍然不知道声称是Microsoft的服务器实际上真的是微软还是某些入侵者。这时候数字签名该登场了。 3.2数字签名如前所述，SSL证书具有关联的公钥/私钥对。公钥作为证书的一部分分发，私钥被保密。这对非对称密钥用于SSL握手，以交换另一个密钥，供双方对数据加密和解密。客户端使用服务器的公钥加密对称密钥，并将其安全地发送到服务器，服务器使用其私钥对其进行解密。任何人都可以使用公钥加密，但只有服务器可以使用私钥进行解密。 数字签名的情况恰恰相反。证书可以由另一个机构“签署”，从而有效地记录在案，“我们已经证实该证书的控制人也控制证书上列出的属性（域名）”。在这种情况下，权限使用其私钥（广义地说）加密证书的内容，并且该密文作为数字签名附加到证书中。任何人都拥有权限使用公钥对该签名进行解密，并验证其是否为预期的解密值。但只有证书的所有者才能使用私钥加密内容，所以只有所有者才能实际创建一个有效的签名。 因此，如果服务器声称拥有由Symantec（或其他CA）签署的Microsoft.com的证书，那么您的浏览器不需要为此签名。如果是合法的，Symantec将使用（超秘密）私钥来生成服务器的SSL证书的数字签名，因此您的浏览器使用可以使用（超公共）公钥来检查该签名是否有效。Symantec将采取措施确保他们正在签署的组织真正拥有Microsoft.com，因此，鉴于您的客户信任Symantec，可以确定它真的在与微软公司对话。 3.3自签名请注意，所有根CA证书都是“自签名”，这意味着使用自己的私钥生成数字签名的证书。根CA证书没有什么特别之处 — 你可以生成自己的自签名证书，并使用它来签署其他证书。 但是，由于您的随机证书不会作为CA预先加载到任何浏览器的任何地方，所以他们都不会相信你所签署的自己的或他人的证书。你是有效地说“呃，我真的是微软，这里是我自己签发并签署的身份证件”，所有正常运行的浏览器都会弹出一个非常严重的错误信息，以回应你的诡计。 这给所有浏览器和操作系统发行商带来了巨大的负担，只能信任干净的根CAs，因为他们的用户最终信任vet网站并保持证书安全的组织。这不是一件容易的事。 3.4你相信什么？有趣的是，你的客户在技术上并不试图验证是否应该信任发送证书的一方，而是应该信任证书中包含的公开密钥。SSL证书是完全公开和公共的，因此任何攻击者都可以获取Microsoft的证书，拦截客户端对Microsoft.com的请求，并向其提供合法的证书。客户端会接受这一点，并开始愉快地握手。 但是，当客户端加密将用于实际数据加密的密钥时，它将使用该真实证书中的真实的Microsoft公钥进行此操作。由于攻击者没有Microsoft私钥来解密，所以他们现在被终止了。即使握手完成，它们仍然无法解密密钥，因此无法解密客户端向其发送的任何数据。只要攻击者不控制受信任的证书的私钥，正常的秩序就会顺利进行下去。如果客户骗取了受信任的证书，攻击者控制了证书和公钥，那么麻烦就开始了。 4.真的很有趣的事实4.1咖啡店可以通过网络监控我的HTTPS流量吗?不。公钥密码使用方法的魔力意味着攻击者可以观察客户端和服务器之间交换的每一个字节数据，并且仍然不知道你们之间所说的话大致等于多少交换的数据量。然而，你的正常HTTP流量在不安全的Wi-Fi网络上仍然非常脆弱，而且脆弱的网站可能会成为任何数量的解决方案的受害者，这些方法可能会欺骗您通过纯HTTP或在完全错误的地方发送HTTPS流量。例如，即使登录表单通过HTTPS提交用户名/密码组合，如果表单本身通过HTTP安全地加载，那么攻击者可能会在到达您的计算机的途中拦截表单的HTML，在修改后将登录详细信息发送到他们自己的服务器。 4.2我的公司可以通过网络监控我的HTTPS流量吗？如果使用由自己公司控制的机器，那么是可以监控的。请记住，在每个信任链的根源都是一个隐含信任的CA，并且这些权限的列表存储在您的浏览器中。您的公司可以使用他们的机器访问权限，将自己的自签名证书添加到这个CA列表中。然后他们可以拦截您的所有HTTPS请求，提供声称代表相应网站的证书，由他们的假CA签名，因此毫无疑问，您的浏览器信任这些CA签名。由于使用其狡猾的证书的公钥对所有HTTPS请求进行加密，所以可以使用相应的私钥来解密和检查（甚至修改）您的请求，然后将其发送到其预期位置。他们可能不会这样做。但他们可以。顺便提一句，这也是你如何使用代理来检查和修改iPhone应用程序所提供的其他无法访问的HTTPS请求。 4.3那么Lavabit和联邦调查局怎么了？Lavabit是2013年NSA泄漏疯狂期间爱德华·斯诺登（Edward Snowden）的超级安全的电子邮件提供商。正如我们所看到的，无数标准黑客可以允许联邦调查局看到Lavabit和其客户之间的任何数据。没有Lavabit SSL证书的私人密钥，黑客们是不可能监听到这些数据的。然而，一位有益的美国法官告诉Lavaff创始人Ladar Levison，他不得不交出这个钥匙，有效地让联邦调查局自由地监视核心的内容。Levison通过在4点类型的11个硬拷贝页面上交出2,560个字符的键，试图停下来，但是被要求执行一个命令，必须以有用的格式交出私钥，否则将会面对每天5000美元的罚款。一旦他遵守了这个命令，Lavad的CA证书颁发机构GoDaddy就会认为证书被破坏了，就撤销了证书。这将Lavabit证书添加到证书吊销列表（CRL）中，该证书撤销列表（CRL）是客户端不再信任以提供安全连接的可信证书的列表。妥协的结果，自签名或其他不可信任的证书导致浏览器显示一个大的红色错误消息，并且阻止或彻底禁止用户进一步的操作。不幸的是，浏览器将继续信任破坏的证书，直到它们将最新的更新提交给CRL，这个过程在实践中显然是不完美的。 5.结论HTTPS不是不可破解的，SSL协议必须不断发展，因为对其的新攻击一直在快速的发展演化。但是，如果看不到您的消息，那么传输秘密数据的方式仍然是令人印象深刻的方式。当然，这里没有提及许多实现细节，例如握手消息的确切格式和顺序，缩短的握手来接收最近的会话而不必重新协商密钥和密码套件，以及每个阶段可用的许多不同的加密选项。要记住的关键是，尽管HTTPS将数据安全地保护到目的地，但绝对不会对您（作为用户或开发人员），保护您免受XSS或数据库泄漏或任何其他事情造成的严重影响。时刻保持警惕。 在威尔·史密斯的不朽言辞中，“在黑暗中行走，要时刻注意，防止突发的暴力。”。如果你喜欢这片文章，你可能会喜欢我的另一篇文章解释SSL2015年FREAK漏洞的细节。 原文地址How does HTTPS actually work? 参考资料 《图解HTTP》 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"译文","slug":"译文","permalink":"http://XibHe.github.io/tags/译文/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://XibHe.github.io/tags/HTTPS/"},{"name":"HTTPS的工作原理","slug":"HTTPS的工作原理","permalink":"http://XibHe.github.io/tags/HTTPS的工作原理/"}]},{"title":"iOS下的图形绘制","date":"2017-04-23T16:00:00.000Z","path":"2017/04/24/Graphics-rendering/","text":"图形绘制iOS系统本身提供了两套绘图的框架，即UIBezierPath 和 Core Graphics。而前者所属UIKit，其实是对Core Graphics框架关于path的进一步封装，所以使用起来比较简单。但是毕竟Core Graphics更接近底层，所以它更加强大。 UIBezierPathUIKit中的UIBezierPath是Core Graphics框架关于path的一个封装。可以创建基于矢量的路径，例如椭圆或者矩形，或者有多个直线和曲线段组成的形状。我们可以用moveToPoint: 和 addLineToPoint:方法去构建。moveToPoint:设置我们想要创建形状的起点。从这点开始，我们可以用方法addLineToPoint:去创建一个形状的线段。我们可以连续的创建line，每一个line的起点都是先前的终点，终点就是指定的点。closePath可以在最后一个点和第一个点之间画一条线段。 - (void)drawRect:(CGRect)rect { UIColor *color = [UIColor colorWithRed:0 green:0.7 blue:0 alpha:1]; [color set]; UIBezierPath* aPath = [UIBezierPath bezierPath]; aPath.lineWidth = 5.0; aPath.lineCapStyle = kCGLineCapRound; aPath.lineJoinStyle = kCGLineCapRound; // 起点 [aPath moveToPoint:CGPointMake(100.0, 0.0)]; // 绘制线条 [aPath addLineToPoint:CGPointMake(200.0, 40.0)]; [aPath addLineToPoint:CGPointMake(160, 140)]; [aPath addLineToPoint:CGPointMake(40.0, 140)]; [aPath addLineToPoint:CGPointMake(0.0, 40.0)]; [aPath closePath];//第五条线通过调用closePath方法得到的 //根据坐标点连线 [aPath stroke]; [aPath fill]; } UIBezierPath+CAShapeLayerCAShapeLayer 继承自 CALayer ，因此，可使用 CALayer 的所有属性。但是， CAShapeLayer 需要和贝塞尔曲线配合使用才有意义。查看官网说明: /* The shape layer draws a cubic Bezier spline in its coordinate space. The spline is described using a CGPath object and may have both fill and stroke components (in which case the stroke is composited over the fill). The shape as a whole is composited between the layer’s contents and its first sublayer.*/ 这里是说 CAShapeLayer 是在其坐标系统内绘制贝塞尔曲线的。因此，使用 CAShapeLayer 需要与 UIBezierPath 一起使用。它有一个 path 属性，而 UIBezierPath 就是对 CGPathRef 类型的封装，因此这两者要配合起来用。 CAShapeLayer与drawRect的关系 drawRect ：属于 CoreGraphics 框架，占用 CPU ，性能消耗大，不建议重写 CAShapeLayer ：属于 CoreAnimation 框架，通过 GPU 来渲染图形，节省性能。动画渲染直接提交给手机 GPU ，不消耗内存这两者各有各的用途，而不是说有了 CAShapeLayer 就不需要 drawRect。温馨提示：drawRect只是一个方法而已，是 UIView 的方法，重写此方法可以完成我们的绘制图形功能。 CAShapeLayer与UIBezierPath的关系 CAShapeLayer中shape代表形状的意思，所以需要形状才能生效 贝塞尔曲线可以创建基于矢量的路径，而UIBezierPath类是对CGPathRef的封装 贝塞尔曲线给CAShapeLayer提供路径,CAShapeLayer在提供的路径中进行渲染。路径会闭环,所以绘制出了Shape 用于CAShapeLayer的贝塞尔曲线作为path，其path是一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线 - (void)viewDidLoad { [super viewDidLoad]; _triangleView = [[UIView alloc] initWithFrame:CGRectMake(screenWidth / 4, 200, screenWidth / 2, screenHeight / 2)]; _triangleView.backgroundColor = [UIColor orangeColor]; [self.view addSubview:_triangleView]; _triangleView.layer.mask = [self createMaskLayerWithView]; } - (CALayer *)createMaskLayerWithView { CGFloat viewWidth = CGRectGetWidth(_triangleView.frame); CGFloat viewHeight = CGRectGetHeight(_triangleView.frame); CGFloat rightSpace = 10.; CGFloat topSpace = 15.; // 起点 CGPoint point1 = CGPointMake(0, 0); // 绘制线条 CGPoint point2 = CGPointMake(viewWidth-rightSpace, 0); CGPoint point3 = CGPointMake(viewWidth-rightSpace, topSpace); CGPoint point4 = CGPointMake(viewWidth, topSpace); CGPoint point5 = CGPointMake(viewWidth-rightSpace, topSpace+10.); CGPoint point6 = CGPointMake(viewWidth-rightSpace, viewHeight); CGPoint point7 = CGPointMake(0, viewHeight); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point1]; [path addLineToPoint:point2]; [path addLineToPoint:point3]; [path addLineToPoint:point4]; [path addLineToPoint:point5]; [path addLineToPoint:point6]; [path addLineToPoint:point7]; [path closePath]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = path.CGPath; return layer; } CoreGraphics这是一个绘图专用的API族，它经常被称为QuartZ或QuartZ 2D。Core Graphics是iOS上所有绘图功能的基石，包括UIKit，Core Graphics是高度集成于UIView和其他UIKit部分，Core Graphics数据结构和函数可以通过前缀CG来识别。 步骤: 1.先在drawRect方法中获得上下文context； 2.绘制图形（线，图形，图片等）； 3.设置一些修饰属性； 4.渲染到上下文，完成绘图。 - (void)drawRect:(CGRect)rect { CGContextRef c = UIGraphicsGetCurrentContext(); CGContextSetRGBStrokeColor(c, 0.0, 0.0, 0.0, 1.0); // black CGContextSetLineWidth(c, 1); CGMutablePathRef bubblePath = CGPathCreateMutable(); // 这里的点是三角形的尖尖 CGPathMoveToPoint(bubblePath, NULL, self.frame.origin.x / 2, self.frame.origin.y); // 其中的一条边的终点 CGPathAddLineToPoint(bubblePath, NULL, 0, self.frame.size.height / 3); // 另一条边的终点 CGPathAddLineToPoint(bubblePath, NULL, self.frame.size.width, self.frame.size.height / 3); CGPathCloseSubpath(bubblePath); CGContextSaveGState(c); CGContextAddPath(c, bubblePath); CGContextClip(c); CGContextSetFillColorWithColor(c, [[UIColor blueColor] CGColor]); CGContextFillRect(c, self.bounds); CGPathRelease(bubblePath); } 注意事项: 1.绘图需要 CGContextRef,CGContextRef即图形上下文。可以这么理解，我们绘图是需要一个载体或者说输出目标，它用来显示绘图信息，并且决定绘制的东西输出到哪个地方。可以形象的比喻context就像一个“画板”，我们得把图形绘制到这个画板上。所以，绘图必须要先有context; 2.并不是说一提到绘图，就一定得重写drawRect方法，只是因为通常情况下我们一般采用在drawRect方法里获取context这种方式。 drawRect方法什么时候触发?当view第一次显示到屏幕上时;当调用view的setNeedsDisplay或者setNeedsDisplayInRect:方法时。 CGContextAddArcToPoint &amp;&amp; CGPathAddArcToPointCGContextAddArcToPoint与CGPathAddArcToPoint这两函数是根据两切线及角度来画弧度,设置弧度CGFloat radius。 画一个四个角都是圆角的矩形, - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. [self drawArcToPoint2]; } - (void)drawArcToPoint2 { //创建CGContextRef UIGraphicsBeginImageContext(self.view.bounds.size); CGContextRef gc = UIGraphicsGetCurrentContext(); //===绘画逻辑 === //创建用于转移坐标的Transform,如许我们不消遵守实际显示做坐标策画 CGAffineTransform transform = CGAffineTransformMakeTranslation(200,200); //创建CGMutablePathRef CGMutablePathRef path = CGPathCreateMutable(); //半径为10 CGFloat radius = 10; //初始点为(10, 0),起点要从10开始，否则，在左上角会出现线条 CGPathMoveToPoint(path, &amp;transform, 10, 0); //右上角和右下角两个点,画出半个圆角 CGPathAddArcToPoint(path, &amp;transform,200, 0, 200, 200, radius); //右下角,画出别的半个圆角 CGPathAddArcToPoint(path, &amp;transform,200, 200, 0, 200, radius); //左下角 CGPathAddArcToPoint(path, &amp;transform,0, 200, 0,0, radius); //左上角 CGPathAddArcToPoint(path, &amp;transform,0, 0, 200, 0, radius); //将CGMutablePathRef添加到当前Context内 CGContextAddPath(gc, path); [[UIColor grayColor] setFill]; [[UIColor blueColor] setStroke]; CGContextSetLineWidth(gc,2); //履行绘画 CGContextDrawPath(gc,kCGPathFillStroke); //从Context中获取图像,并显示在界面上 UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); UIImageView *imgView = [[UIImageView alloc] initWithImage:img]; [self.view addSubview:imgView]; } CAShapedLayer处理理论上我们可以构造出任意想要的形状，但是有些形状如果你不熟悉几何知识的话是构造不出正确path的，从代码上我们可以看到我们可以通过设置CALayer的contents属性来设置显示的内容，那我们是不是可以通过设置CAShapedLayer的contents来设maskLayer呢？答案是肯定的，代码如下： - (void)setup4 { CAShapeLayer *maskLayer = [CAShapeLayer layer]; maskLayer.fillColor = [UIColor blackColor].CGColor; maskLayer.strokeColor = [UIColor clearColor].CGColor; maskLayer.frame = self.bounds; maskLayer.contentsCenter = CGRectMake(0.5, 0.5, 0.1, 0.1); maskLayer.contentsScale = [UIScreen mainScreen].scale; //非常关键设置自动拉伸的效果且不变形 maskLayer.contents = (id)[UIImage imageNamed:@&quot;gray_bubble_right@2x.png&quot;].CGImage; CALayer *contentLayer = [CALayer layer]; contentLayer.mask = _maskLayer; contentLayer.frame = self.bounds; [self.layer addSublayer:_contentLayer]; } 遗留问题使用CGPathAddArcToPoint绘制带有箭头的弹窗菜单,如图， 在绘制四个边的圆角时，无法对应到特定的四个角的位置，导致绘制不出该效果的图片。 demoGithub ：https://github.com/XibHe/DrawTriangle 参考资料 绘图 iOS CAShapeLayer精讲 iOS绘图—— UIBezierPath 和 Core Graphics CGPathAddArc vs CGPathAddArcToPoint CGContextAddArcToPoint与CGPathAddArcToPoint iOS 不规则的ImageView CGPathAddArc vs CGPathAddArcToPoint –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"图形绘制","slug":"图形绘制","permalink":"http://XibHe.github.io/tags/图形绘制/"},{"name":"UIBezierPath","slug":"UIBezierPath","permalink":"http://XibHe.github.io/tags/UIBezierPath/"},{"name":"CGPathAddLineToPoint","slug":"CGPathAddLineToPoint","permalink":"http://XibHe.github.io/tags/CGPathAddLineToPoint/"},{"name":"CGPathAddArcToPoint","slug":"CGPathAddArcToPoint","permalink":"http://XibHe.github.io/tags/CGPathAddArcToPoint/"}]},{"title":"Harden your mind","date":"2017-03-30T16:00:00.000Z","path":"2017/03/31/Harden-your-mind/","text":"前段时间看了casa的直播《闲话iOS架构》，收看直播时，很多人在聊天里发言询问迅速提高技术有什么捷径?而casa的回答是多想多练。casa直播背景是一个书架，书架上摆满了书，中途一直有人发消息询问大神背后的书架都有什么书？给我最直观的感觉是大家很浮躁，总是想通过一种事半功倍的方式快速摘取成功果实，却忽略了平时的积累，正是这些小的积累，造就大的爆发。 《闲话iOS架构》提到的内容如下: 1.《批判性思维》 2.高效烧脑，低效伤身. 3.protocol,categary 4.注释一般写在垃圾代码那里。剩下的都是代码自注释 5.极致了，怎么保证扩展性?并不矛盾 6.框架ctmater? 7.reactive cocoa 8.APImanager 9.组件化 10.class template 12.OCLink 可以部分review 13.有if就要有else,逻辑上的，思维考虑的对称，不是强制代码必须要这样做 14.以前一直用shell 现在用swift REPL 15.架构的限制是指规范 16.组件化和模块化到底怎么区分，一个东东的不同叫法，实际上应该叫模块化 17.《Cocoa设计模式》 18.如何看待新技术, mvvm，Reactive cocoa，rac 19.没有最全面的技术，只有最合适的技术。 20.CTMediator组件化方案 21.CTNetwokring和YTKNetworking，离散型，集约型 22.codeReview 23.继承的缺点，破坏了代码结构 24.RN,weex 25.复用的东西拆成组件 26.《The Art of Capacity Planning》 27.腾讯开源的Mars,引出大一统和多元化， 28.网易，无埋点打log，网易乐得无埋点数据收集sdk casa所讲的内容多是通过平时代码积累得来的方法论，如果没有一定的代码积累和长期的项目实践是很难彻底理解这些内容的。iOS应用架构看着很高大上，但需要在牢固的基础之上一层层堆砌成高楼。忽视这些必要的步骤，一味粉饰自己，到头来也只是黄粱一梦一场空。再回过头来看目前国内知识付费现象，觉得是一个泡沫。正如知乎上所说，知识付费，抓的不是人的求知欲，抓的是人的焦虑感。人们焦虑，希望有人告诉他们捷径，如何更快的获得成功。这里莫名的想到成功学，成功的永远是成功学的讲师。当代知识产品最大的痛点就是:不看书。 我们急切的接受别人输出的价值观，却选择性的忽略掉自己的内心真正的诉求。书上得来总觉浅，听人道出方觉深，互补的只是不愿意努力看书或是去实践的懒惰。知识经济本质上就是粉丝经济的另一种表现形式。最后，还是想强调一下，作为一名攻城狮通过解决日常遇到的问题，或由浅而深，或发散思维都可以一步步引导至问题的核心。切忌自以为是，舍本逐末。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"Harden your mind","slug":"Harden-your-mind","permalink":"http://XibHe.github.io/tags/Harden-your-mind/"},{"name":"知识付费","slug":"知识付费","permalink":"http://XibHe.github.io/tags/知识付费/"}]},{"title":"待办事项提醒功能开发(二)","date":"2017-03-15T09:01:00.000Z","path":"2017/03/15/待办事项提醒功能开发(二)/","text":"新建数据库入库操作界面绘制通知log表注意事项 时间转化的时区设置 最近的本地通知最多只能有64个(待测试) 过期通知的移除(不做移除，通过通知的自有机制去处理的可行性) 生产日期，到期日，保质期天数的交互 奇妙清单的到期提醒只与提醒时间和频率有关，与是否到期无关 iOS 10之后的推送 Demo地址点击下载 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"待办事项提醒","slug":"待办事项提醒","permalink":"http://XibHe.github.io/tags/待办事项提醒/"},{"name":"开源","slug":"开源","permalink":"http://XibHe.github.io/tags/开源/"}]},{"title":"待办事项提醒功能开发(一)","date":"2017-03-13T14:50:06.000Z","path":"2017/03/13/待办事项提醒功能开发(一)/","text":"业务需求根据用户所添加某件商品的生产日期和保质期天数计算商品的过期日期，在过期前的时间内，用户可以设置提醒的具体时间点和提醒频次，系统根据用户设置的提醒时间和提醒频次通知用户某某商品该使用了。具体操作步骤如下: 新增一个提醒事项的名称，这个名称将作为待完成事项显示在任务列表中，可以快速勾选完成； 在保质期限一栏，点击生产日期一栏，弹出年月日的日期选择器用于日期的选择； 点击保质期天数一栏，弹出用于输入保质期天数的输入控件，保质期单位可以是天，月，年； 如果保质期为30天以内，默认开启智能保质期提醒；如果超过30天，则关闭智能提醒，需要有手动设置结束提醒的具体时间及提醒频率； 在提醒设置一栏，根据生产日期和保质期天数自动计算出到期的具体日期，用户点击时间一栏，弹出时间的选择控件用于选择触发提醒的时间点，用户也可以设置提醒频次； 需要考虑的技术点结合需求需要考虑如下几个问题: 本地通知的运行机制是什么？ 如何自定义通知的频率？ 如何移除到期的通知提醒？ 当用户编辑一个已经存在的提醒任务时，如何根据用户修改后的日期，频率等参数，更新现有的通知提醒频次，触发时间，日期等属性？ 当切换用户或者用户退出登录后，如何操作之前已经添加的通知提醒？ 通知提醒数据的持久化？ 本地通知相关点使用本地通知提醒用户，而本地通知有些地方在使用时需要注意,如下: 1.本地通知是有操作系统统一调度的，只有在应用退出到后台或者关闭才能收到通知；2.本地通知的数量是有限制的，最近的本地通知最多只能有64个，超过这个数量将被系统忽略；3.如果想要移除本地通知可以调用UIApplication的cancelLocalNotification:或cancelAllLocalNotifications移除指定通知或所有通知；4.通知对应的NScalendarunit属性，可以通过该属性操作提醒的频率； NScalendarunit的具体属性如下： typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) { NSCalendarUnitEra = kCFCalendarUnitEra, NSCalendarUnitYear = kCFCalendarUnitYear, NSCalendarUnitMonth = kCFCalendarUnitMonth, NSCalendarUnitDay = kCFCalendarUnitDay, NSCalendarUnitHour = kCFCalendarUnitHour, NSCalendarUnitMinute = kCFCalendarUnitMinute, NSCalendarUnitSecond = kCFCalendarUnitSecond, NSCalendarUnitWeekday = kCFCalendarUnitWeekday, NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, NSCalendarUnitQuarter NS_ENUM_AVAILABLE(10_6, 4_0) = kCFCalendarUnitQuarter, NSCalendarUnitWeekOfMonth NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfMonth, NSCalendarUnitWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitWeekOfYear, NSCalendarUnitYearForWeekOfYear NS_ENUM_AVAILABLE(10_7, 5_0) = kCFCalendarUnitYearForWeekOfYear, NSCalendarUnitNanosecond NS_ENUM_AVAILABLE(10_7, 5_0) = (1 &lt;&lt; 15), NSCalendarUnitCalendar NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 20), NSCalendarUnitTimeZone NS_ENUM_AVAILABLE(10_7, 4_0) = (1 &lt;&lt; 21), NSEraCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitEra instead&quot;) = NSCalendarUnitEra, NSYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitYear instead&quot;) = NSCalendarUnitYear, NSMonthCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitMonth instead&quot;) = NSCalendarUnitMonth, NSDayCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitDay instead&quot;) = NSCalendarUnitDay, NSHourCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitHour instead&quot;) = NSCalendarUnitHour, NSMinuteCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitMinute instead&quot;) = NSCalendarUnitMinute, NSSecondCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitSecond instead&quot;) = NSCalendarUnitSecond, NSWeekCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekOfMonth or NSCalendarUnitWeekOfYear, depending on which you mean&quot;) = kCFCalendarUnitWeek, NSWeekdayCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekday instead&quot;) = NSCalendarUnitWeekday, NSWeekdayOrdinalCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_4, 10_10, 2_0, 8_0, &quot;Use NSCalendarUnitWeekdayOrdinal instead&quot;) = NSCalendarUnitWeekdayOrdinal, NSQuarterCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_6, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitQuarter instead&quot;) = NSCalendarUnitQuarter, NSWeekOfMonthCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitWeekOfMonth instead&quot;) = NSCalendarUnitWeekOfMonth, NSWeekOfYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitWeekOfYear instead&quot;) = NSCalendarUnitWeekOfYear, NSYearForWeekOfYearCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 5_0, 8_0, &quot;Use NSCalendarUnitYearForWeekOfYear instead&quot;) = NSCalendarUnitYearForWeekOfYear, NSCalendarCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitCalendar instead&quot;) = NSCalendarUnitCalendar, NSTimeZoneCalendarUnit NS_CALENDAR_ENUM_DEPRECATED(10_7, 10_10, 4_0, 8_0, &quot;Use NSCalendarUnitTimeZone instead&quot;) = NSCalendarUnitTimeZone, }; 步骤说明使用sqlite3进行通知提醒相关数据的持久化。大概的思路如下： 新增提醒任务: 1.插入保质期提醒任务表2.插入通知表3.插入通知log表4.上传服务器通知提醒数据 编辑提醒任务： 1.更新保质期提醒任务表2.更新通知表3.更新通知log表4.上传服务器编辑后的通知提醒数据 需要注意本地通知的官方文档是否有最近的跟新 ，待续…… –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"开源","slug":"开源","permalink":"http://XibHe.github.io/tags/开源/"},{"name":"待办事项","slug":"待办事项","permalink":"http://XibHe.github.io/tags/待办事项/"}]},{"title":"第一次面试别人是怎样的体会","date":"2017-02-25T16:00:00.000Z","path":"2017/02/26/第一次面试别人是怎样的体会/","text":"不安的开始自从去年后半年以来，iOS开发相关工作就被唱衰。很多人抱怨裸辞后找不到工作，可谓是哀鸿遍野。看到了太多这样的帖子，身边也有相识的人遭遇了公司解散，失业后迟迟找不到工作的窘境。这也直接导致了我内心的忐忑和不安，不禁要问，iOS从业者的未来在哪里？我又该何去何从呢？这样的疑问，这样的不安，一直伴随着我。在结合别人的现实的遭遇后，分析了一下造成现阶段初级，中级iOS从业者找工作难的原因: 市场过度饱和，培训机构追求自身利益，在iOS开发人员相对稀缺阶段，培训了大量的从业人员，扰乱了市场正常的供需关系，导致从业人员供大于需； 鱼龙混杂的从业者，很多开发者并不是科班出身，只是听说iOS开发者的薪资待遇高，才决定去培训机构学习，经过四五个月左右的强制灌输和培训机构的包装后，摇身一变成了具有两年开发经验的iOS开发者,其本身不具备计算机专业相关的基础知识； 资本市场资金的收紧，导致流向互联网领域的热钱迅速减少，相比前几年互联网行业的创业潮，很多创业者张口闭口我们是颠覆者，一定会替代某某某，只要嘴炮一番就能忽悠到投资人的钱，今年的资本市场回归了理性。那些没有清晰盈利模式的初创公司迅速倒闭，相关中小互联网公司的用人需求在萎缩； 市场需求的理性回归，很多培训班出身，或者工作年限不足三年，或者是一年工作经验用了三年的初中级开发者满足不了市场上很多公司对于中高级开发者相关的技术要求，于是，被市场无情的淘汰； 行业内薪资待遇的降低，iOS开发已经结束了早期因从业者稀少而造成的市场红利时期，进入到了一个稳步发展的相对稳定时期。因此，薪资待遇回归到了一个正常的水准。那些早期享受到这种红利的开发者，一时间接受不了薪资待遇的降低； 技术层面方面，iOS开发依托苹果提供的平台，该平台的封闭性决定了开发者所接触的技术面比较狭窄，脱离了苹果，不能完全胜任其他技术工作； 我所遇到的一个例子带着这些不安，对于已经结束的16年，我做了一份总结，也包括17年的一些计划。或许是心志不坚，或许是颓废太久，这种不安仍旧存在，直到上周面试了一个来公司应聘iOS开发的应聘者…… 周五下午，人事和我说能不能帮忙面试一下，本来是另一个项目组需要的人，但恰巧他们的负责人不在，就让我去面了。第一次面试别人还是有些紧张，好像自己第一次被别人面试一样紧张。但左等右等还是等不到人事通知我去面试，后来大概半小时后被人事告知那个来面试的人已经走了，据她说面试题只做了一半，人就走了，可能是被我们的面试题吓走了。但面试题我也看过，是四十道很基础的面试题呀！表示不解啊！本以为这次安排的面试就这样结束了，后来人事通知还有一个已经写完了面试题，在沙发区等着，于是我就开始了这次面试之旅。 短暂的两分钟的沉默，我简单看了一下他的简历，上面工作经验写着三年。心里便盘算着从哪些知识点入手可以探出对方是不是真的有三年工作经验。先是让对方做了一个简单的自我介绍，然后开始对着简历问一些问题，简历上写了四个项目，每个项目所用到的技术都是一些大众化的技术，比如，网络请求库AFNetworking，图片加载库SDWebImage，数据库FMDB，刷新库MJRefresh，适配库Masonry等各种三方库的使用。于是我便问了以下的问题: NSOperation与GCD的区别 GCD中如何避免死锁和数据竞争 Block的使用及如何避免循环引用 使用过哪些设计模式 单例，什么是单例，单例的作用 内存管理 网络请求库的使用 JS与原生应用是如何交互的 了解过RunTime吗 通知是异步还是同步 该如何对tableView进行优化，实现滑动的流畅性，以及如何避免tableView代理方法中冗长的代码 SDWebImage的运行机制 App中的多用户逻辑 如何实现一个可以循环滚动的轮播图(类似于京东，淘宝首页顶部效果) 给你一个新项目你会怎么做 是否能看一下你的技术博客或是GitHub上的开源项目 对方对上述问题的回答模棱两可，十分的模糊。其中涉及到GCD那块的问题，只说了用过，GCD的如何避免数据竞争和死锁，以及它与NSOperation的区别只是把什么是NSOperation用名词解释了一下，而对于Block的循环引用问题，支支吾吾想了半天回答的文不对题。设计模式是典型的MVC，倒是提到了MVVM，但这里也只是简单的提到，就没有什么下文了。单例的使用，边想边说，整了半天也没有将声明单例的具体方法说明白。内存管理这块，据他说，学iOS开发时MRC已经没人用了，他就直接用的ARC。JS与原生应用交互这块说没有用过。那么RunTime呢?说是底层的东西没有怎么了解过。tableView的优化方面，说是用的原生API的代理方法，这个还需要优化吗?SDWebImage的运行机制，把它的使用方法说了一遍。App中的多用户逻辑，说是服务器的事，客户端不需要考虑。轮播图功能的实现，说的是使用NSTimer。给你一个新项目你会怎么做，说的是先花一周进行需求分析，再新建工程，使用CocoaPods把那些要用到的三方库引入到工程中。问完了这些问题，我还是抱有一丝幻想的，心想也许是太过紧张了，再看看他做的项目吧！ 看了下对方手机上他参与开发的项目，是一些与美食推荐相关的项目，有一个已经停止维护，拉取不到任何数据了。剩下的都是一些数据使用tableView展示的普通项目，没有什么逻辑特别复杂或是需要使用很高明技术的功能。自此，我仍然没有放弃，心想或许对方还研究过其他的技术点，于是就问对方，是否能看一下你的技术博客或是GitHub上的开源项目。对方回答说，没有。此刻，我也只能道了两声谢谢，说有结果人事会通知你。心里想着，本来还想问有没有使用过Swift，可是现在看来，已经没有问的必要了。 结束 红利已经结束了，那个只要会使用tableView等常用控件就能找到工作的时代结束了。曾听一位前辈说过， “感觉每个做技术的一开始都是一粒沙子，不断修炼学习吸收营养变成大颗粒的沙子。 再学习其他东西把自己变成土块儿，时间是一把大筛子，每次过滤掉小沙粒，只留大块儿在上面，在你被筛掉之前要么变的比网眼大留下来，要么赶紧被筛掉转行吧!” 最后来个总结吧！猥琐发育，别浪！ –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"面试","slug":"面试","permalink":"http://XibHe.github.io/tags/面试/"},{"name":"心得体会","slug":"心得体会","permalink":"http://XibHe.github.io/tags/心得体会/"},{"name":"iOS开发没人要了","slug":"iOS开发没人要了","permalink":"http://XibHe.github.io/tags/iOS开发没人要了/"}]},{"title":"适配器模式初探","date":"2017-02-18T20:23:06.000Z","path":"2017/02/19/适配器模式初探/","text":"初衷解决ViewConctroller里冗余代码过多的问题，将公用模块抽离出来。这里将项目中用到的拍照，调用相册，录像，定位等功能单独抽离出来放在一起。 使用步骤 第一步: 定义一个delegate，用来返回一个遵守该协议的数据，不管传过来的数据是什么类型，只要服从这个协议，实现协议里的方法，就处理这个数据。 @protocol MediaHandleDelegate &lt;NSObject&gt; @optional - (void)returnMedidaData:(id)mediaData; @end 第二步: 创建继承于NSObject的根适配器类MediaHandleAct，该类遵守第一步中的协议，并实现该协议的方法，但只是空实现。 // MediaHandleAct.h #import &quot;MediaHandleDelegate.h&quot; @interface MediaHandleAct : NSObject { id &lt;MediaHandleDelegate&gt; _delegate; } // MediaHandleAct.m #import &quot;MediaHandleAct.h&quot; - (void)returnMedidaData:(NSString *)data{ } 第三步: 构建根适配器类MediaHandleAct中注册特定Action的方法，并获取注册的Action。 #import &lt;Foundation/Foundation.h&gt; #import &quot;MediaHandleDelegate.h&quot; @interface MediaHandleAct : NSObject { id &lt;MediaHandleDelegate&gt; _delegate; } // 动态注册新的Action + (void)registerMediaHandleAction:(MediaHandleAct *)mediaHandleAct andKey:(NSString *) actKey; // 获取注册的Action + (NSDictionary *)mediaHandleActions; // 传递Action的具体执行方法 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass; @end // MediaHandleAct.m #import &quot;MediaHandleAct.h&quot; static NSMutableDictionary * mediaHandleActs = nil; @implementation MediaHandleAct + (void)registerMediaHandleAction:(MediaHandleAct *)mediaHandleAct andKey:(NSString *)actKey { @synchronized(self){ if (!mediaHandleActs) { mediaHandleActs = [NSMutableDictionary dictionary]; [MediaHandleAct registerCommonAction]; } [mediaHandleActs setObject:mediaHandleAct forKey:actKey]; } } + (NSDictionary *)mediaHandleActions { NSDictionary * acts = nil; @synchronized(self){ if (!mediaHandleActs) { mediaHandleActs = [NSMutableDictionary dictionary]; [MediaHandleAct registerCommonAction]; } acts = mediaHandleActs; } return acts; } // 具体的执行方法 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass{ } @end synchronized 这个主要是考虑多线程的程序，这个指令可以将{ } 内的代码限制在一个线程执行，如果某个线程没有执行完，其他的线程如果需要执行就得等着。@synchronized 的作用是创建一个互斥锁，保证此时没有其它线程对self对象进行修改。这种机制确保了同一时刻对于每一个类，至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。一般在公用变量的时候使用，如单例模式或者操作类的static变量中使用。 第四步: 针对不同功能的类，创建继承于MediaHandleAct的类适配器。使用适配器的时候，分为类适配器和对象适配器。类适配器针对每一个数据类型或某个功能模块创建一个适配器，并继承于根适配器。 // 调用相册功能 #import &lt;Foundation/Foundation.h&gt; #import &quot;MediaHandleAct.h&quot; @interface MediaHandleAlbum : MediaHandleAct @property (nonatomic, assign) NSInteger maxCount; // 最多可添加照片数 // 注册Action + (void)load; @end // MediaHandleAlbum.m #import &quot;MediaHandleAlbum.h&quot; #import &quot;JKImagePickerController.h&quot; @interface MediaHandleAlbum ()&lt;JKImagePickerControllerDelegate&gt; { UIViewController * _parentController; } @end @implementation MediaHandleAlbum + (void)load { [MediaHandleAct registerMediaHandleAction:[[MediaHandleAlbum alloc] init] andKey:@&quot;album&quot;]; } #pragma mark - 拍照和调用相册功能 - (void)performActionWichController:(UIViewController *)controller callbackClass:(NSObject *)callbackClass { _parentController = controller; _delegate = (id)callbackClass; UIActionSheet *actionSheet = [[UIActionSheet alloc] initWithTitle:nil delegate:(id)self cancelButtonTitle:nil destructiveButtonTitle:nil otherButtonTitles:@&quot;拍照&quot;,@&quot;从相册选择&quot;,@&quot;取消&quot;,nil]; [actionSheet showInView:_parentController.view]; } #pragma mark - ActionSheetDelegate - (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex { switch (buttonIndex) { case 0: { // 拍照 UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.sourceType = UIImagePickerControllerSourceTypeCamera; picker.editing = YES; picker.allowsEditing = YES; picker.delegate = (id)self; [_parentController presentViewController:picker animated:YES completion:nil]; break; } case 1: { // 调用相册 JKImagePickerController *imagePickerController = [[JKImagePickerController alloc] init]; imagePickerController.delegate = (id)self; imagePickerController.showsCancelButton = YES; imagePickerController.allowsMultipleSelection = YES; imagePickerController.minimumNumberOfSelection = 1; imagePickerController.maximumNumberOfSelection = self.maxCount; //imagePickerController.selectedAssetArray = self.photosView.assetsArray; UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:imagePickerController]; [_parentController presentViewController:navigationController animated:YES completion:NULL]; break; } default: break; } } #pragma mark - UIImagePickerControllerDelegate - (void) imagePickerController: (UIImagePickerController*)picker didFinishPickingMediaWithInfo: (NSDictionary*) info { [picker dismissViewControllerAnimated:YES completion:nil]; UIImage *edit = [info objectForKey:@&quot;UIImagePickerControllerEditedImage&quot;]; UIImage *originalImage = [info objectForKey:@&quot;UIImagePickerControllerOriginalImage&quot;]; CLog(@&quot; EditedImage %@ &quot;,NSStringFromCGSize(edit.size)); CLog(@&quot; OriginalImage %@ &quot;,NSStringFromCGSize(originalImage.size)); UIImage *aImage = edit; NSData * imageData = UIImageJPEGRepresentation(aImage,0.5); if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(returnMedidaData:)]) { NSArray * photos = @[imageData]; [_delegate returnMedidaData:photos]; } } - (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker { [picker dismissViewControllerAnimated:YES completion:nil]; } #pragma mark - JKImagePickerControllerDelegate - (void)imagePickerController:(JKImagePickerController *)imagePicker didSelectAsset:(JKAssets *)asset isSource:(BOOL)source { [imagePicker dismissViewControllerAnimated:YES completion:nil]; } - (void)imagePickerController:(JKImagePickerController *)imagePicker didSelectAssets:(NSArray *)assets isSource:(BOOL)source { [imagePicker dismissViewControllerAnimated:YES completion:nil]; CLog(@&quot;assets == %@&quot;,assets); NSMutableArray * photos = [[NSMutableArray alloc] init]; for (JKAssets * jkAssets in assets) { NSData * photoData = UIImageJPEGRepresentation(jkAssets.photo, 0.5); [photos addObject:photoData]; CLog(@&quot;groupPropertyID = %@, groupPropertyURL = %@, assetPropertyURL = %@, photo = %@&quot;,jkAssets.groupPropertyID,jkAssets.groupPropertyURL,jkAssets.assetPropertyURL,jkAssets.photo); } if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(returnMedidaData:)]) { [_delegate returnMedidaData:photos]; } } 第五步: 调用适配器。 MediaHandleAlbum * album = [[MediaHandleAct mediaHandleActions] objectForKey:@&quot;album&quot;]; album.maxCount = imageCount; [album performActionWichController:self callbackClass:self]; 适配器模式的优缺点优点: 耦合度低，可以扩展多种不同功能的适配样式。缺点: 代码量相应增多，文件增多。 源码下载地址 注意该Demo中使用调用相机，相册，录制视频的功能，当系统为iOS 10以上访问权限的设置有所不同，需要在工程中的plist文件中添加对应的描述。Demo中的plist，如图， 其他功能访问权限设置， iOS 10 - Changes in asking permissions of Camera, microphone and Photo Library causing application to crash –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://XibHe.github.io/tags/设计模式/"},{"name":"适配器","slug":"适配器","permalink":"http://XibHe.github.io/tags/适配器/"}]},{"title":"再见! 2016!","date":"2017-01-15T13:25:10.000Z","path":"2017/01/15/再见！2016/","text":"结婚2016年注定是不平凡的一年，我和花花（我媳妇的外号）在2月14日领的结婚证，这天也是西方的情人节。从这天起我要履行法律赋予我作为一个丈夫的责任和义务。我和花花是大学同学，相识六年，经历了种种磨难和阻力，最终走到了一起。她是我的福星，我的天使，没有花花的鼓励和支持我不敢想象我会变成什么样子。谢谢你包容我的时不时的坏脾气，容忍我的懒散，不思进取，选择和我在一起。承担起本不该属于你的忧愁和压力。我的挚爱，我的血肉。谢谢你一路的陪伴。 生子16年，给了我太多的惊喜和感动。我又办成了人生的另外一件大事—孕育下一代。我们家小宝贝的出生好似给我注入了一剂强心剂，让我感到内心无比的强大。前期的彷徨无措，以及不知该如何适应父亲这个新角色的焦躁不安随着我们家小宝贝的降生，被一扫而空。又是一个给我带来好运的小天使，每每想到小家伙那粉嫩的面庞，心中就为之躁动起来。他的一举一动都牵动着我，同时，也感到肩上的责任越来越重了。我会更加努力为你打下一片大大的疆土。我的小宝贝。 新工作因为种种原因，之前的公司主营业务出现了问题，于是，树倒猢狲散，我又开始了漫长的面试生涯。经过近一个月数十家公司的面试，最终入职了现在的公司。面试时也遇到很多自己之前没有深入去考录的问题，被打了几次脸之后，让我认识到自己的基础并不牢固，很多问题只有肤浅的认知。关于面试这一块的具体内容，需要整理成具体的内容，再发布到博客上，就当给自己提个醒，告诫自己前方还有一段很长的路要走。 新的工作，给我最大的感受就是流程上的统一与协调。在开发新版本前，会走一个需求分析-&gt;原型设计-&gt;需求评审-&gt;UI设计评审-&gt;制定开发计划-&gt;开发计划评审的流程。虽然起初感到繁琐，但对流程的把控可以形成有效的开发计划，掌握开发过程中不同的产出环节，随着对流程的适应以及团队磨合，最终这个流程的时间也会缩短。最重要的是当项目延期或是需求出现问题，可以追溯到流程中那个环节出现了问题。 刚接手现在正在做的这个项目时，觉得很烫手。不仅要面对开发进度的滞后，还要提防项目中随时可能出现的一些无以名状的Bug。觉得自己一个人有些力不从心，但又不得不咬牙顶上去。最终，通过不断加班加点的赶进度，不断的理解产品需求，迈过了这个坎。反而很享受这样解决问题的畅快，为自己以后填更大的坑积累的初始的经验。经过这五个多月的不断历练，最大的收货是：自己慢慢能把控好一个项目了。由最初的慌张，苦闷，到现在可以坦然的面对这些问题。在项目中对自己的要求更加严格了，对产品性能方面，有了一个基本的认识，并开始着手做一些性能上的优化工作。 家庭这半年时间，加班比较多，这就导致了陪在家人身边的时间少了很多。起初，我觉得我是在履行我养家糊口的责任，从这一点出发是无可厚非的。但事实上，我的家人更需要我的陪伴，我不能陪伴小家伙一天天的成长，是我作为父亲最大的遗憾；我不能换位思考，体谅我妻子带孩子的艰辛，是我作为丈夫的不称职。曾听说过一句话：把家当做事业来经营，把事业当做家来爱。如果真正做到了这句话所说的那样，那么家庭与工作二者之间就会找到平衡点，一切的矛盾将会迎刃而解。同时，沟通的不及时也会加剧这种矛盾，所以，今年无论工作再忙也要抽出时间关心下我的妻子和儿子，让她们能感受到我对她们的爱。 读书16年初，1月份读了一刀推荐的 《把时间当做朋友》 ，尝试从心智层面上控制自己，告别拖延症。开始尝试制定每个月的工作学习计划。4月初读了一刀推荐的 《Effective Objective-C 2.0:编写高质量iOS与OS X代码的52个高效方法》和 《Objective-C高级编程:iOS与OS X多线程和内存管理》 对编写高质量的代码，提高代码质量有了初步的了解，对线程底层实现的原理有了一个大概的轮廓。但看这两本书时，太着急了些，未能将书中的精髓全部掌握，同时，也遗留了很多一知半解的问题。今年计划再拿出半个月的时间回顾一下这两本书中未搞懂的内容。五月中旬看了 《GitHub入门与实践》 一书，书的内容很简单，浅显的讲了一下GitHub的原理和流程，如果想进一步了解Git的详细使用及具体操作，可以看Pro Git，GitBook上已经有第二版简体中文的翻译了。六月份还看了 &lt;&gt; 一书，不过是跳着看的，跳过了那些自己已经掌握的内容，看后，对现有知识进行了一些拓展。双十一的时候，在网上买了几本书，如下： 《传习录》 《编程珠玑》 《人类简史》 《软技能:代码之外的生存指南》 《Head First设计模式(中文版)》 《啊哈!算法》 《图解HTTP》 《黑客与画家》 这几本书里有之前听别人说起过的，也有一刀推荐的。这几本书中 《软技能:代码之外的生存指南》， 《啊哈!算法》， 《图解HTTP》这三本书已经看了有些日子了。这些书有些是对现有知识的拓展和升华，打破我固有的思维，有的是个人喜好。读书的时间，开始时是早上在公交车上看，有时看某一本书看得厌烦了，就换另一本书看。个人觉得看纯技术书籍时，可以根据自己的口味搭配一本非技术的书籍来一起读，这样可以缓解因长期看一本书而造成的疲劳和厌烦。 以前认为读书的时间是千方百计的挤出来的，现在看来这样的想法有失偏颇。当我想偷懒，放松下来时，或是想玩手机时，就在心里告诫自己用这些时间来看书，反复这样几次后，竟然发现在这些时间内，比我千方百计挤出来的时间看的书还多。看来平时的时间都被浪费在了这些琐碎，无意义的事情上了。 博客关于博客，16年初开始写，一直到7月份才写了第二篇文章，全年只写了7篇文章。很多想写的东西，都只是被记录下来，并没有梳理成一篇文章，最后，都化作了尘埃，消失不见了。最开始时，想着什么都往博客上写，但那样纯粹是为了凑字数，可读性并不强。浪费了自己的时间，也对读这篇博客的人造成了困扰。到后来，太过于浅显东西没有写的必要，未经深入研究的东西，或是从别处直接复制粘贴别人的观点。这些都不是在写博客，而是在记流水账。因此，给自己定下了一个三不写的要求: 所描述的内容，逻辑不清，不写 没有经过自己验证过的内容，不写 对别人没有帮助，只是在记流水账的内容，不写 2017年会继续坚持写博客，写那些真正经过自己深入研究过的东西，写那些日常项目中真正遇到并最终解决的问题，写对自己对别人有用的东西。只有这样才能提高文章的质量，付出的时间才能得到最大化的利用。 新技术16年8月初，学习了最新的Swift 3.0，当然，现在最新的是Swift 3.01。从官网下了The Swift Programming Language(Swift 3.01)，通过官网下载时会跳转到iBooks，但由于一些众所周知的原因，iBooks中国区是无法下载的，需要使用美区账号登录iBooks。可以结合极客学院Wiki简体中文翻译看。目前，自己只看到了 Functions 这章，17年还需要继续学习剩下的部分，再使用Swift编写一个具体的项目。17年计划学习一些热更新的技术，并计划在自己做的项目中使用一种热更新技术，实现动态化的修改项目中的代码。17年，希望自己能在iOS之外，能入门一种新的技术，拓宽自己的视野，达到自己心中设定的新的高度，看到之前看不到风景。 挑战17年是公司发展历程中重要的一年，也是我所在项目组所开发的项目大范围推广的一年，我们将迎来更多的用户，更大的并发量，会根据市场反应快速迭代产品。我们渴望在项目中使用新的技术，不断的提高用户体验，同时，又能不影响项目上线时间。希望我们产品被更多的人使用，得到大家的认可。同时，希望我们团队 永远年轻，永远热泪盈眶。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"2016","slug":"2016","permalink":"http://XibHe.github.io/tags/2016/"},{"name":"年终总结","slug":"年终总结","permalink":"http://XibHe.github.io/tags/年终总结/"}]},{"title":"调试蓝牙扫码枪遇到的问题","date":"2016-12-06T10:31:54.000Z","path":"2016/12/06/iOS蓝牙开发简介  /","text":"iOS蓝牙开发简介蓝牙 4.0出现之前，蓝牙 2.0时只有iOS设备和苹果认证的MFI设备才可以被iOS设备检索到。蓝牙 4.0之后（硬件要4S，系统要iOS6以上才支持蓝牙 4.0），苹果开放了BLE(蓝牙4.0以低功耗著称，所以一般被称为BLE（bluetooth low energy））通道，没有MFI认证的蓝牙设备也可以连接非越狱的iOS设备了。 总结了一下，一共有五种方式可以实现蓝牙通信: 使用MFI认证的蓝牙模块的蓝牙产品 —— 开发使用ExternalAccessory框架，如果你的蓝牙模块还没设计，打算在AppStore上发布，打算使用蓝牙4.0以下（IOS设备都兼容），那你就抓紧找MFI认证的蓝牙模块吧。 使用苹果提供的CoreBluetooth framework框架 —— 只适用于支持蓝牙4.0的设备，无需越狱，无需使用MFI，可以发布在AppStore上。 GameKit framework —— 只能在iOS设备之间同一个应用内连接，从iOS7开始过期了，通过蓝牙可以实现文件的共享（仅限设备沙盒中的文件），此框架一般用于游戏开发（比如五子棋对战）。 Private API —— 使用私有API的应用程序不被允许在AppStore上发布。 Jailbreak 这里我使用的是第二种方式 —— CoreBluetooth。 核心概念CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类。 CBCentralManager：中心设备（用来连接到外部设备的管家） CBPeripheralManager：外部设备（第三方的蓝牙4.0设备） 这两组api分别对应不同的业务场景，左侧叫做中心模式，就是以你的app作为中心，连接其他的外设的场景，而右侧称为外设模式，使用手机作为外设别其他中心设备操作的场景。 服务和特征，特征的属性(service and characteristic):每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。 外设、服务、特征间的关系 连接测试检测蓝牙设备的连接强度，查询一定范围内的蓝牙设备列表。可以通过一款名为LightBlue的手机端软件来确定。在开启蓝牙的状态下，打开LightBlue搜索到当前范围内的设备列表，可以点击查看当前设备的UUID以及特征和服务的UUID，如图， 连接蓝牙扫码枪项目中需要连接蓝牙扫码枪，通过扫码枪扫描商品的条码，将得到的条码值传给终端设备。终端设备根据该条码值搜索该商品的全部信息。iPad开启蓝牙，通过设置蓝牙扫描枪，连接上iPad，但发现在调试状态下，并没有调用CBCentralManager的代理方法。使用LightBlue搜索当前范围内的蓝牙设备，无法找到当前连接到iPad上的蓝牙扫描枪。蓝牙扫描枪使用的是富立叶（cilico）ci6800这款。最后，看了产品说明，发现它的蓝牙模块是蓝牙2.0 + EDR。而不是最新的蓝牙4.0。在未做任何处理的情况下，iPad端任然可以所接收到扫码枪扫描条码后的到的码值。原来是扫码枪默认开启了HID模式，在该模式下iPad默认当前通过蓝牙连接的扫码枪为一个外接键盘，因此扫描后得到码值相当于通过敲击键盘输入。 这样也造成了一个问题，iPad上所有带有输入功能的操作，都无法通过点击输入框弹出软键盘。因为系统会将扫码枪当做键盘，所有软键盘的弹出或者隐藏都是通过扫码枪做操作。但事实上扫码枪并不能控制键盘的弹出。通过google找到了一种据说是可以解决该问题的方法点击查看。但该方法极不稳定，当扫码枪的连接状态在休眠/唤醒两种状态下来回切换时就会失效。偶尔会成功弹出键盘。 最后，在联系厂家需求帮助无果的情况下，不得不停止了该款扫码枪的适配。 连接蓝牙血压计为了验证自己的代码没有问题，是由于蓝牙扫码枪的蓝牙模块版本过低不支持CoreBluetooth。我又找来了一台据说支持蓝牙4.0的蓝牙血压计做测试。 代码实现的步骤 第一步，创建CBCentralManager。第二步，扫描可连接的蓝牙外设（必须在蓝牙模块打开的前提下）。第三步，连接目标蓝牙外设。第四步，查询目标蓝牙外设下的服务。第五步，遍历服务中的特性，获取特性中的数据或者保存某些可写的特性，或者设置某些特性值改变时，通知主动获取。第六步，在通知更新特性中值的方法中读取特性中的数据（再设置特性的通知为YES的情况下）。第七步，读取特性中的值。第八步，如果有可写特性，并且需要向蓝牙外设写入数据时，写入数据发送给蓝牙外设。 引入 CoreBluetooth头文件 #import &lt;CoreBluetooth/CoreBluetooth.h&gt; 声明属性 @property (nonatomic, strong) CBCentralManager *manager; @property (nonatomic, strong) CBPeripheral *peripheral; @property (strong ,nonatomic) CBCharacteristic *writeCharacteristic; @property (strong,nonatomic) NSMutableArray *nDevices; @property (strong,nonatomic) NSMutableArray *nServices; @property (strong,nonatomic) NSMutableArray *nCharacteristics; 遵守协议 @interface ViewController () &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt; 初始化数据 - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.manager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; _cbReady = false; _nDevices = [[NSMutableArray alloc]init]; _nServices = [[NSMutableArray alloc]init]; _nCharacteristics = [[NSMutableArray alloc]init]; count = 0; } 实现蓝牙的协议方法 (1)检查蓝牙状态 -(void)centralManagerDidUpdateState:(CBCentralManager *)central { switch (central.state) { case CBCentralManagerStatePoweredOn: { [self updateLog:@&quot;蓝牙已打开,请扫描外设&quot;]; [_activity startAnimating]; [_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@&quot;FFF0&quot;]] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }]; } break; case CBCentralManagerStatePoweredOff: [self updateLog:@&quot;蓝牙没有打开,请先打开蓝牙&quot;]; break; default: break; } } 注：[_manager scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:@”FF15”]] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }];中间的@[[CBUUID UUIDWithString:@”FFF0”]]是为了过滤掉其他设备，可以搜索特定标示的设备。 （2）检测到外设后，停止扫描，连接设备 //查到外设后，停止扫描，连接设备 -(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI { [self updateLog:[NSString stringWithFormat:@&quot;已发现 peripheral: %@ rssi: %@, UUID: %@ advertisementData: %@ &quot;, peripheral, RSSI, peripheral.identifier, advertisementData]]; _peripheral = peripheral; [_manager connectPeripheral:_peripheral options:nil]; [self.manager stopScan]; [_activity stopAnimating]; BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) { CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) { [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; } } if (!replace) { [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; } } （3）连接外设后的处理 //连接外设成功，开始发现服务 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]); [self updateLog:[NSString stringWithFormat:@&quot;成功连接 peripheral: %@ with UUID: %@&quot;,peripheral,peripheral.identifier]]; [self.peripheral setDelegate:self]; [self.peripheral discoverServices:nil]; [self updateLog:@&quot;扫描服务&quot;]; } //连接外设失败 -(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;%@&quot;,error); } -(void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(NSError *)error { NSLog(@&quot;%s,%@&quot;,__PRETTY_FUNCTION__,peripheral); int rssi = abs([peripheral.RSSI intValue]); CGFloat ci = (rssi - 49) / (10 * 4.); NSString *length = [NSString stringWithFormat:@&quot;发现BLT4.0热点:%@,距离:%.1fm&quot;,_peripheral,pow(10,ci)]; [self updateLog:[NSString stringWithFormat:@&quot;距离：%@&quot;, length]]; } （4）发现服务和搜索到的Characteristice //已发现服务 -(void) peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ [self updateLog:@&quot;发现服务.&quot;]; int i=0; for (CBService *s in peripheral.services) { [self.nServices addObject:s]; } for (CBService *s in peripheral.services) { [self updateLog:[NSString stringWithFormat:@&quot;%d :服务 UUID: %@(%@)&quot;,i,s.UUID.data,s.UUID]]; i++; [peripheral discoverCharacteristics:nil forService:s]; if ([s.UUID isEqual:[CBUUID UUIDWithString:@&quot;FFF0&quot;]]) { BOOL replace = NO; // Match if we have this device from before for (int i=0; i &lt; _nDevices.count; i++) { CBPeripheral *p = [_nDevices objectAtIndex:i]; if ([p isEqual:peripheral]) { [_nDevices replaceObjectAtIndex:i withObject:peripheral]; replace = YES; } } if (!replace) { [_nDevices addObject:peripheral]; [_bluetoothTable reloadData]; } } } } //已搜索到Characteristics -(void) peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error{ [self updateLog:[NSString stringWithFormat:@&quot;发现特征的服务:%@ (%@)&quot;,service.UUID.data ,service.UUID]]; for (CBCharacteristic *c in service.characteristics) { [self updateLog:[NSString stringWithFormat:@&quot;特征 UUID: %@ (%@)&quot;,c.UUID.data,c.UUID]]; if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF01&quot;]]) { _writeCharacteristic = c; } if ([c.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) { [_peripheral readValueForCharacteristic:c]; [_peripheral setNotifyValue:YES forCharacteristic:c]; } } } } - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error { [self updateLog:[NSString stringWithFormat:@&quot;已断开与设备:[%@]的连接&quot;, peripheral.name]]; } （5）获取外设发来的数据 //获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF02&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF02[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[1] == 0) { }else if (resultByte[1] == 1) { [self updateLog:@&quot;未知错误&quot;]; }else if (resultByte[1] == 2) { [self updateLog:@&quot;鉴权失败&quot;]; } } if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF04&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF04[%d] = %d\\n&quot;,i,resultByte[i]);} if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;FF05&quot;]]) { NSData * data = characteristic.value; Byte * resultByte = (Byte *)[data bytes]; for(int i=0;i&lt;[data length];i++) printf(&quot;testByteFF05[%d] = %d\\n&quot;,i,resultByte[i]); if (resultByte[0] == 0) { // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆撤防状态&quot;]; }else if (resultByte[0] == 1) { // 设备加解锁状态 0 撤防 1 设防 [self updateLog:@&quot;当前车辆设防状态&quot;]; } } } //中心读取外设实时数据 - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@&quot;Error changing notification state: %@&quot;, error.localizedDescription); } // Notification has started if (characteristic.isNotifying) { [peripheral readValueForCharacteristic:characteristic]; } else { // Notification has stopped // so disconnect from the peripheral NSLog(@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic); [self updateLog:[NSString stringWithFormat:@&quot;Notification stopped on %@. Disconnecting&quot;, characteristic]]; [self.manager cancelPeripheralConnection:self.peripheral]; } } //用于检测中心向外设写数据是否成功 -(void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { if (error) { NSLog(@&quot;=======%@&quot;,error.userInfo); [self updateLog:[error.userInfo JSONString]]; }else{ NSLog(@&quot;发送数据成功&quot;); [self updateLog:@&quot;发送数据成功&quot;]; } /* When a write occurs, need to set off a re-read of the local CBCharacteristic to update its value */ [peripheral readValueForCharacteristic:characteristic]; } 后记厂商一般会提供一份蓝牙血压计通信指令控制数据格式(通讯协议) 可根据该协议中定义的返回的十六进制数据，定义当前外设发送的不同数据的意义。最主要是用UUID来确定你要干的事情，特征和服务的UUID都是外设定义好的。我们只需要读取，确定你要读取什么的时候，就去判断UUID是否相符。 一般来说我们使用的iPhone都是做centralManager的，蓝牙模块是peripheral的，所以我们是want datas，需要接受数据。 判断状态为powerOn，然后执行扫描 停止扫描，连接外设 连接成功，寻找服务 在服务里寻找特征 为特征添加通知 通知添加成功，那么就可以实时的读取value[也就是说只要外设发送数据[一般外设的频率为10Hz]，代理就会调用此方法]。 处理接收到的value，[hex值，得转换] 之后就自由发挥了，在这期间都是通过代理来实现的，也就是说你只需要处理你想要做的事情，代理会帮你调用方法。[别忘了添加代理] 参考资料蓝牙相关基础知识 hacksugar: Bringing back the on-screen keyboard 蓝牙交互CoreBlueTooth iOS and bluetooth iOS蓝牙，CoreBluetooth框架简介及入门使用 想做iOS Bluetooth產品但又不想過MFI的討論 CoreBluetooth cannot find devices but iOS can 请教熟悉iOS的朋友一个问题 【译】iOS蓝牙编程指南 – 核心蓝牙概述 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"蓝牙开发","slug":"蓝牙开发","permalink":"http://XibHe.github.io/tags/蓝牙开发/"},{"name":"iOS BLE 开发","slug":"iOS-BLE-开发","permalink":"http://XibHe.github.io/tags/iOS-BLE-开发/"}]},{"title":"记一个在使用Masonry时遇到的问题","date":"2016-09-18T12:35:34.000Z","path":"2016/09/18/记一个在使用Masonry时遇到的问题/","text":"使用Masonry的场景在“我的”界面顶部区域用来展示用户的登录信息，顶部有两种样式的变换，即，由未登录—-&gt;已登录。如图所示， 其中头像区域是UIImageView，”登录/注册”是UILabel。登录成功后，头像区域会显示由服务器返回的头像地址生成的图片，并且其位置发生变化，不在居中显示，显示”登录/注册”的UILabel变为显示用户昵称，并且坐标位置发生改变。如图所示， 我的问题来了，在设置头像和标题位置时使用mas_remakeConstraints设置二者的约束，代码如图， 当从未登录切换到已登录时，已登录的头像位置会发生改变，变得特别大，不受约束控制。控制台会报如下错误， 刚开始没有意识到改变UIImageView的约束导致的新旧两种约束冲突造成的问题。在一个小时未解决该问题后，放弃了使用Masonry，改为使用代码做布局。今天，再回头看看这个问题，联想到忽略了什么东西，就打开Masonry文档从头开始仔细往下看，结果就看到了这句话， Sometimes you need modify existing constraints in order to animate or remove/replace constraints. In Masonry there are a few different approaches to updating constraints. 文档上列举了三种修改现有约束的方法， References你可以引用一个特定约束条件的约束，使表达式的结果分配给一个局部变量或一个类属性。 mas_updateConstraints作为一种选择，如果你只是去更新固有的约束值，你可以使用mas_updateConstraints这种便利的方法替换mas_makeConstraints。 mas_remakeConstraintsmas_updateConstraints用于更新一组约束，但要做那些费力的超出超出常量值的约束更新。这时就需要选择mas_remakeConstraints。mas_remakeConstraints类似于mas_updateConstraints，但它不是更新常量值，当再次为这些已经存在约束的视图设置约束前，它会移除掉该视图上的所有约束。这就让你可以为视图设置新的约束，而不用考虑移除之前已经存在的其他约束。 于是，我使用文档中提到的第三种方法，将所有的mas_makeConstraints换成了mas_remakeConstraints，就解决了约束错乱的问题。 参考文档Masonry使用 造成这个问题的主要原因是我没有认真看Masonry的文档，文档上说的已经很清楚了。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"Masonry","slug":"Masonry","permalink":"http://XibHe.github.io/tags/Masonry/"},{"name":"iOS适配","slug":"iOS适配","permalink":"http://XibHe.github.io/tags/iOS适配/"}]},{"title":"记一个关于线程的错误","date":"2016-09-11T15:23:34.000Z","path":"2016/09/11/记一个关于线程的错误/","text":"上周遇到一个问题，当前页面为一个UIWebView，当点该WebView上某个按钮进入下一个页面时，再通过该页面顶部返回按钮返回时，程序就会崩溃。（在开启了全局断点的情况下）控制台会输出如下提示： 程序崩溃在将要消失时，控制台给出 This application is modifying the autolayout engine from a background thread,whinch can lead to engine corruption and weird crashes.This will cause an exception in a future release. 的报错。 根据提示认为是后台线程在更新UI布局时，webView与JS的交互也在此时进行。交互操作会阻塞UI的显示及刷新。因此，又回到了一个老生常谈的准则上来了， 要在主线程刷新UI布局 。在调用本地应用于H5交互的方法时，要放到主线程中。 #pragma mark - 跳转购物车 - (void)goCart:(NSString *)shopNum { CLog(@&quot;jsString = %@&quot;,shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum]; dispatch_async(dispatch_get_main_queue(), ^{ [self.navigationController popToRootViewControllerAnimated:NO]; MallHomeViewController *mallHome = [LYSingle sharedSingle].mallVC; [mallHome setCurrentSelectIndex:3]; }); } #pragma mark - 商品上架(未开通店铺不能上架) - (void)cannotShelves { CLog(@&quot;cannotShelves&quot;); UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;要在主线程刷新UI&quot; delegate:self cancelButtonTitle:@&quot;我知道了&quot; otherButtonTitles:nil]; dispatch_async(dispatch_get_main_queue(), ^{ [alertView show]; }); } –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"线程","slug":"线程","permalink":"http://XibHe.github.io/tags/线程/"},{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://XibHe.github.io/tags/iOS多线程/"}]},{"title":"使用 cocoapods 时遇到的错误及错误的解决方案","date":"2016-08-21T07:58:00.000Z","path":"2016/08/21/关于cocoapod的二三事/","text":"1.The dependency AFNetworking (= 2.6.3) is not used in any concrete target.在cocoapods version 1.0 之后，默认生成的Podfile文件类似于 pod &#39;Alamofire&#39;, &#39;~&gt; 3.1.4&#39; pod &#39;SwiftyJSON&#39;, &#39;~&gt; 2.3.2&#39; 这样的默认设置。为了不发生如标题那样的错误，需要手动用 target “TargetName” do end 把需要 pod 的库包括进来。 target &quot;TargetName&quot; do pod &#39;Alamofire&#39;, &#39;~&gt; 3.1.4&#39; pod &#39;SwiftyJSON&#39;, &#39;~&gt; 2.3.2&#39; end 2.ios None of your spec sources contain a spec satisfying the dependency: IQKeyboardManager (~&gt; 4.0.0).报这个错误，可能是由于Cocoapods的配置库有损坏，Cocoapods建议删除本地副本重新clone。根据cocoapods官方博客的方案，在终端做出如下操作 (依照次序) 第一步: sudo rm -fr ~/Library/Caches/CocoaPods &amp;&amp; \\ 第二步: $ sudo rm -fr ~/.cocoapods/repos/master gem update --system &amp;&amp; \\ gem update &amp;&amp; \\ gem cleanup &amp;&amp; \\ pod setup 参考资料Pod install displaying error in cocoapods version 1.0.0.beta.1 intergating New Firebase.. error cocoapods pod repo update does not happen error in cocoapods Repairing Our Broken Specs Repository –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"cocoapod","slug":"cocoapod","permalink":"http://XibHe.github.io/tags/cocoapod/"}]},{"title":"关于iOS 7 Background Remote Notification(推送唤醒)","date":"2016-08-09T15:30:48.000Z","path":"2016/08/09/iOS 7 Background Remote Notification/","text":"更新说明更新记录: 2016 年 8 月，第一版 2017 年 8 月，增加配置极光推送的注意事项 Background Remote Notification简介Remote Notifications是 iOS7 在推送方面最大的变化，它允许应用收到通知后在后台（background）状态下运行一段代码，可用于从服务器获取内容更新。功能使用场景：（多媒体）聊天，Email更新，基于通知的订阅内容同步等功能，提升了终端用户的体验。 如何设置Remote notifications客户端设置需要在Xcode 中修改应用的 Capabilities 开启Remote notifications，如图： 当注册了Backgroud Modes -&gt; Remote notifications 后，notification 处理函数一律切换到下面函数，后台推送代码也在此函数中调用。 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler 这个函数也是iOS8之后获取远程推送调用的方法。 服务端设置 这个很重要，推送消息携带 content-available: 1 是Background 运行的必须参数，如果不携带此字段则与iOS7 之前版本的普通推送一样。服务端payload格式:aps增加content-available字段，类似于： payload example: {&quot;aps&quot;:{&quot;alert&quot;:&quot;example&quot;, &quot;sound&quot;:&quot;default&quot;, &quot;badge&quot;: 1, &quot;category&quot;:&quot;reply&quot;,&quot;content-available&quot;:&quot;1&quot; }} 这里集成的是极光推送，参考极光推送 Push API v3 的文档，发现了iOS 平台上发送 APNS 通知的规范。其中支持的字段中关键字 content-available 的类型为 boolean 。如果该字段为 true 说明是 Background Remote Notification ，如果不携带此字段则是普通的 Remote Notification 。这里需要特别注意的是服务器在配置 content-available: ture 时的正确性。如图，后台以java为例。 尚未传图 最后，当应用在后台挂起时，发起一个 Background Remote Notification(推送唤醒) 。客户端获取的数据，如下: userInfo = { &quot;_j_msgid&quot; = 2632357907; aps = { alert = &quot;\\U6717\\U81f4\\U96c6\\U56e2\\U9738\\U5dde\\U5e02(\\U53bf\\U7ea7)\\U603b\\U4ee3\\U7406\\U5546\\U5bb6\\U60a8\\U597d\\Uff01\\U60a8\\U7684\\U5e97\\U94fa\\U53c8\\U6709\\U65b0\\U8ba2\\U5355\\U4e86\\Uff0c\\U8ba2\\U5355\\U53f73cef6682b73ca,\\U8bf7\\U53ca\\U65f6\\U767b\\U5f55\\U5546\\U57ce\\U8fdb\\U884c\\U8ba2\\U5355\\U5ba1\\U6838\\U3002&quot;; badge = 1; category = identifier; sound = default; content-available = 1; }; } 参考资料极光客户端SDk教程 极光服务器端Push API v3 三种方式使得iOS应用能够在后台进行数据更新和下载 配置极光推送的注意事项使用极光测试生产环境下的推送时，发现无论通过我们自己的后台还是极光的后台使用Register ID发送通知，手机都无法收到通知。而在开发环境下是可以收到的。后来查了下极光文档中使用JPush iOS SDK注意事项: 如果你是直接运行安装到测试设备（运行调试状态），那你的安装的应用的证书环境只有可能是开发环境或者通配的。 而我恰恰是通过Xcode装的程序。 生产环境的正确测试姿势 常见问题-JPush合集 后记关于 Background Remote Notification(推送唤醒) 早在一年前就使用过，当时调研调试花费了大量时间。没想到现在又遇到了这个问题。结果，我又在阴沟里翻了船。可见做笔记，写博客总结的重要性。希望第三次闭着眼睛就能跳过这个坑。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"}]},{"title":"Objective-C与JS交互","date":"2016-07-12T16:00:00.000Z","path":"2016/07/13/JavaScriptCoreMutualH5/","text":"更新说明更新记录: 2016 年 7 月，第一版。 2017 年 8 月，增加OC调用JS方法相关介绍。 JavaScriptCore简介JavaScriptCore是iOS7引入的新功能，使用JavaScriptCore后可以实现js代码与本地native代码进行相互调用。 要使用JavaScriptCore，首先我们需要引入它的头文件 #import &lt;JavaScriptCore/JavaScriptCore.h&gt; 这个头里面引入了几个重要的对象 #import &quot;JSContext.h&quot; #import &quot;JSValue.h&quot; #import &quot;JSManagedValue.h&quot; #import &quot;JSVirtualMachine.h&quot; #import &quot;JSExport.h&quot; JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口 JSValue是JSContext执行后的返回结果，他可以是任何js类型（比如基本数据类型和函数类型，对象类型等），并且都有对象的方法转换为native对象。 JSManagedValue是JSValue的封装，用它可以解决js和原声代码之间循环引用的问题 JSVirtualMachine 管理JS运行时和管理js暴露的native对象的内存 JSExport是一个协议，通过实现它可以完成把一个native对象暴漏给js 具体的交互过程可以参见这篇博客https://imciel.com/2016/06/18/oc-js-communication/ OC与JS交互的方式OC与js交互，主要涉及到两方面: OC调用JS方法，将本地JS需要的值传递过去，供JS函数调用； JS调用OC的native方法，将JS函数中的返回值传递给本地方法，执行相应操作；下面将针对以上两条交互方式，展开来说。OC调用JS方法通过UIWebView展示JS页面，在UIWebView的代理方法中通过执行stringByEvaluatingJavaScriptFromString方法将JS代码执行结果以字符串方式返回， - (void)webViewDidFinishLoad:(UIWebView *)webView { NSString *text = aControl.titleLabel.text; NSString *jsMethod = [NSString stringWithFormat:@&quot;ocScrollToElementByName(&#39;%@&#39;)&quot;, text]; [self.contentView stringByEvaluatingJavaScriptFromString:jsMethod]; } 也可以在当前加载webView页面类的 - (void)viewWillAppear:(BOOL)animated 方法中调用JS方法，执行相关操作，如: 传递参数 // JS交互，传gid,刷新JS页面商品数量 NSString *gid = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;GoodInfoH5Gid&quot;]; if (gid &amp;&amp; gid.length &gt; 0) { NSString *jsMethod = [NSString stringWithFormat:@&quot;updateGoodNum(&#39;%@&#39;)&quot;,gid]; [_webView stringByEvaluatingJavaScriptFromString:jsMethod]; } 局部刷新列表 // 局部刷新 [_webView stringByEvaluatingJavaScriptFromString:@&quot;updatecartnumAndTotalPay()&quot;]; JS调用OC的native方法通过JavaScriptCore进行交互，需要在webView的加载完成的代理方法中设置交互上下文-JSContext,并将JS中的交互对象赋给当前类。下面将叙述如何使用JSExport设置引用名称来进行交互，使用JSExport引用名称空间后，对于调用了哪些JS方法就一目了然了。 JSExport引用名称空间交互设置js那边统一使用一个名为jsObject的对象来调用js的方法进行传值或触发某一特定的事件。在 js 中定义一个方法: &lt;html&gt; &lt;head&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function setContent(){ jsObject.shopCartNumChanged(totalNum); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;javascript:setContent(&#39;ios is: &#39; + typeof ios)&quot;&gt; &lt;/body&gt; &lt;/html&gt; 当点击 js 界面上的一个 “+” 号时，js 那边会查找 OC 代码通过JSContext注册的名为jsObject.shopCartNumChanged的调用方法。现在问题来了，在 OC 中该如何注册该方法呢?答案是使用语言穿梭机—JSExport协议。比如，我有一个 ShopCarViewController 的类。在.h中声明一个名为 MallJSExports 的协议。 // ShopCarViewController.h #import &lt;JavaScriptCore/JavaScriptCore.h&gt; @protocol MallJSExports &lt;JSExport&gt; - (void)shopCartNumChanged:(NSString*)shopNum; //购物车数量变化 - (void)orderGoBackToNative; //订单返回按钮 @end @interface ShopCarViewController : MallViewController @end 在.m中当然要声明并实现该协议的方法。 @interface ShopCarViewController()&lt;UIWebViewDelegate,MallJSExports&gt;{ } @property (nonatomic, strong) UIWebView *webView; @property (nonatomic, copy) NSString *shopNum; //商品数量 @end @implementation ShopCarViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. self.navigationItem.title = @&quot;购物车&quot;; _webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, screenWidth, self.view.height-49)]; [_webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:_webUrl]]]; _webView.delegate = self; _webView.detectsPhoneNumbers = NO; [self.view addSubview:_webView]; } #pragma mark - 在webView加载完成的代理方法里设置JSContext - (void)webViewDidFinishLoad:(UIWebView *)webView { //JS上下文对象 JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; context[@&quot;jsObject&quot;] = self; } #pragma mark - 购物车数量变化 - (void)shopCartNumChanged:(NSString *)shopNum { CLog(@&quot;jsString shopNum = %@&quot;,shopNum); [[NSNotificationCenter defaultCenter] postNotificationName:ShopCartNumIsChanged object:shopNum]; } #pragma mark - 订单返回按钮 - (void)orderGoBackToNative { [self.navigationController popViewControllerAnimated:YES]; } 这里要注意的是 context[@ “jsObject” ] = self 中的的key值是和服务器商量好的, 即， js 中定义的回调方法 jsObject.shopCartNumChanged( )相一致。 在这里对 JSExport 的使用只是简单的设置了一下命名空间，将下标方法暴露给js对象方便服务器调用。其实， JSExport 协议主要用途是把objc复杂对象转换成JSValue并暴露给js对象。 JSExport 作为两种语言的互通协议。 JSExport 中没有约定任何的方法，连可选的(@optional)都没有，但是所有继承了该协议(@protocol)的协议（注意不是Objective-C的类(@interface)）中定义的方法，都可以在JSContext中被使用。 补充关于使用WKWebView进行交互。调用JS函数: [self.wkwebView evaluateJavaScript:@&quot;refreshList()&quot; completionHandler:^(id _Nullable rr, NSError * _Nullable error) { }]; 参考资料使用 JavaScriptCore 实现 JS和OC间的通信 JavaScriptCore框架在iOS7中的对象交互和管理 iOS JavaScriptCore使用 示例代码下载Demo –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"JavaScriptCore","slug":"JavaScriptCore","permalink":"http://XibHe.github.io/tags/JavaScriptCore/"},{"name":"iOS","slug":"iOS","permalink":"http://XibHe.github.io/tags/iOS/"},{"name":"iOS与JS交互","slug":"iOS与JS交互","permalink":"http://XibHe.github.io/tags/iOS与JS交互/"}]},{"title":"路开始的地方","date":"2016-01-16T04:04:48.000Z","path":"2016/01/16/summary/","text":"特别鸣谢老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！老郭，对本博客所提供的技术支持！并附上他的博客地址 前言博客页面的搭建是在2015年6月15日，在老郭的指导下完成的。搭建博客的初衷完全是因为看到别人都有博客，而且界面很炫，为了自己的虚荣心才觉得自己也要整一个这样的博客。可是等到自己动手的时候，完全无从下手。什么是Hexo，Homebrew，MarkDown等等。这些都没有听说过。还好有老郭，他手把手的教我如何去配置这些东东。那时候觉得自己好2B。最后，倒是整出来了，看到了久违的Hello World，还是当年的配方，还是熟悉的味道。好吧，我承认我只是一时的冲动和虚荣心在作怪，我的博客在2015年6月15日止步于Hello World，从此，再也没有爬起来过。 自己思考原来就是件很快乐的事情，而教别人思考则是学习思考，锻炼思维的最好办法。 为什么写博客或许我并不是一个喜欢记录，总结的人。但还是因为工作的原因(每个周五都要发一份周报给老大)，还是养成了一个记录的习惯。我把周一到周五每天都做了什么事情，记录在一个黑色的笔记本上。 把那些未经整理的，杂乱无章的，解决的问题的过程和代码复制到了印象笔记上。以备以后查阅方便。遇到类似的问题就打开笔记，复制出一份代码。也未深究这段代码的意义何在，为什么可以解决问题。久而久之，便不会思考，真的就成为了代码的搬运工了。没有了思考，发现不了自己的短板，便陷在了这样一种自我满足的境地当中了。每天看似在前进，实际上是在原地绕弯。日复一日，剩下的只有惶恐和迷茫。变得越来越不自信。杂乱无章的笔记和随处存放的代码片段并不能引导我去思考制造这些Bug的原因。我要思考，要分享我的思考过程，希望得到别人认可的同时也能指出我的不足和错误。 解决问题的核心思想只有一个———一切都靠积累。 博客的开始回顾过去的2015年，我已经在新公司待了快一年了，虽然，不知道自己究竟都有哪些提升。但是，冥冥中又觉得自己还是有些收获的。当然这些收获都来自于师傅他老人家的谆谆教导。我不想忘记那些和师傅一起加班的日日夜夜里所带来的收获，我要把这些冥冥中的收获写下来，记录我在这些项目中的收获，以及那些尚未解决的问题所留下的遗憾。 期望以后能弥补这些遗憾。留住这些青春的记忆。 –EOF– 若无特别说明，本站文章均为原创，转载请保留链接，谢谢","tags":[{"name":"路的开始","slug":"路的开始","permalink":"http://XibHe.github.io/tags/路的开始/"}]}]