<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XibHe&#39;s Blog</title>
  <subtitle>It is never too late，Just do it better.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://XibHe.github.io/"/>
  <updated>2021-07-16T15:39:13.417Z</updated>
  <id>http://XibHe.github.io/</id>
  
  <author>
    <name>XibHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>直播业务集成及再开发</title>
    <link href="http://XibHe.github.io/2021/06/12/%E7%9B%B4%E6%92%AD%E4%B8%9A%E5%8A%A1%E9%9B%86%E6%88%90%E5%8F%8A%E5%86%8D%E5%BC%80%E5%8F%91/"/>
    <id>http://XibHe.github.io/2021/06/12/直播业务集成及再开发/</id>
    <published>2021-06-11T16:00:00.000Z</published>
    <updated>2021-07-16T15:39:13.417Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中集成推拉流直播业务……</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中集成推拉流直播业务……&lt;/p&gt;
&lt;p&gt;–EOF–&lt;/p&gt;
&lt;p&gt;若无特别说明，本站文章均为原创，转载请保留链接，谢谢！&lt;/p&gt;

    
    </summary>
    
      <category term="日常" scheme="http://XibHe.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="直播" scheme="http://XibHe.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="推拉流" scheme="http://XibHe.github.io/tags/%E6%8E%A8%E6%8B%89%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Swift 与 OC 混编注意事项</title>
    <link href="http://XibHe.github.io/2020/08/31/Swift_OC_mix/"/>
    <id>http://XibHe.github.io/2020/08/31/Swift_OC_mix/</id>
    <published>2020-08-30T16:00:00.000Z</published>
    <updated>2020-09-15T16:33:20.038Z</updated>
    
    <content type="html"><![CDATA[<p>为了使 Objective-C 代码更好的符合 Swift 的使用习惯，主要有以下几种处理方式：</p>
<ul>
<li>遵循编译器的某些规则</li>
<li>在头文件里进行特殊标注</li>
<li>用 Swift 做中间层，重新封装原有代码</li>
<li>根据自己的喜好进一步优化</li>
</ul>
<h3 id="快速查看-Xcode-基于-OC-代码生成的-Swift-接口"><a href="#快速查看-Xcode-基于-OC-代码生成的-Swift-接口" class="headerlink" title="快速查看 Xcode 基于 OC 代码生成的 Swift 接口"></a>快速查看 Xcode 基于 OC 代码生成的 Swift 接口</h3><p>在需要转换的 OC 类的 .h 头文件中，点击左上角的 Related Items 按钮，选择 Generated Interface 后，就会出现几种不同 Swift 版本的接口文件选择其中某个版本的 Swift 接口文件，如下图所示：</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/OCForSwift/20200909185036.jpg" alt=""></p>
<p>选择其中某个版本的 Swift 接口文件，最终自动生成对应版本的 Swift 接口 API</p>
<h3 id="Objective-C-与-Swift-混编的一些问题："><a href="#Objective-C-与-Swift-混编的一些问题：" class="headerlink" title="Objective-C 与 Swift 混编的一些问题："></a>Objective-C 与 Swift 混编的一些问题：</h3><h4 id="1-过多的隐式解析可选类型"><a href="#1-过多的隐式解析可选类型" class="headerlink" title="1. 过多的隐式解析可选类型"></a>1. 过多的隐式解析可选类型</h4><p>默认情况下 Swift 会把 Objective-C 里的指针当做隐式解析可选类型，因为它认为这个值大部分情况下不会是 nil，但它也不完全确定。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/OCForSwift/20200910142407.jpg" alt=""></p>
<p>这样做会导致两个问题：</p>
<ul>
<li>大量的隐式解析可选类型让代码变得意图模糊</li>
<li>隐式解析的存在，导致了容错能力的下降。只要服务端回传的参数中有一个空字段或者类型错误，就有可能引发 Crash</li>
</ul>
<p>解决以上问题的方式：在 OC 代码中使用 nonnull (不可为空)和 nullable (可为空)关键字，根据这两个关键字决定转换后的 Swift 是否使用隐式解析。除了 nonnull 和 nullable 以外，还有一对配合使用的宏 NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END 可以让我们的代码更清爽。(新建类会自带这一对宏)</p>
<h4 id="2-某些转换后的属性里-Any-定义过于模糊"><a href="#2-某些转换后的属性里-Any-定义过于模糊" class="headerlink" title="2. 某些转换后的属性里 Any 定义过于模糊"></a>2. 某些转换后的属性里 Any 定义过于模糊</h4><p>可以通过在 OC 里添加 NSArray，NSDictionary 中存储的固定类来改善这个问题。例如，</p>
<pre><code class="objectivec">-(void)setRecommendArray:(nullable NSArray&lt;MCHomeGoodModel *&gt; *)recommendArray andSpace:(CGFloat)space andsectionInset:(UIEdgeInsets)sectionInse;
</code></pre>
<p>转换为：</p>
<pre><code class="swift">open func setRecommendArray(_ recommendArray: [MCHomeGoodModel]?, andSpace space: CGFloat, andsectionInset sectionInse: UIEdgeInsets)
</code></pre>
<h4 id="3-一些初始化构造器或者方法命名不够优雅"><a href="#3-一些初始化构造器或者方法命名不够优雅" class="headerlink" title="3. 一些初始化构造器或者方法命名不够优雅"></a>3. 一些初始化构造器或者方法命名不够优雅</h4><p>Swift 和 Objective—C 的命名风格是有所不同，例如 Swift 的 API 是由基名（previousMissionsFlown）和参数标签（by）组成的，⽽ Objective—C 基本上只有参数标签(previousMissionsFlownByAstronaut)，没有单独的基名，所以基名的信息会包含在第⼀个参数标签⾥，这也导致了 Objective—C 的方法名会显得略长一些。</p>
<h4 id="4-对于数字处理统一使用-Int-重要！！！"><a href="#4-对于数字处理统一使用-Int-重要！！！" class="headerlink" title="4. 对于数字处理统一使用 Int (重要！！！)"></a>4. 对于数字处理统一使用 Int (重要！！！)</h4><p>NSUInteger 是无符号的，即没有负数。在 OC 中多以 NSUInteger 返回 index 或者设置枚举类型</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/OCForSwift/20200910144826.jpg" alt=""></p>
<p>由于 NSUInteger 的大小会因架构不同而产生一些变化，Swift 采取的策略是在进⾏有符号运算时，要求开发者必须将⽆符号类型转换为有符号类型，如果 Swift 在处理⽆符号运算时，产⽣了负值，就会直接停⽌运算。</p>
<p>对于 Apple 自己的框架，他们设置了一个白名单用于将 NSUInteger 转换为 Int。对于开发者而言，决定权在我们自己手里，我们可以⾃⾏选择是否使⽤ NSInteger，但 Apple 的工程强烈推荐你这么做。或许在 Objective-C ⾥⾯差距不是很⼤，但在 Swift ⾥⾯很重要！</p>
<h4 id="5-将字符串类型的常量变得更有条理"><a href="#5-将字符串类型的常量变得更有条理" class="headerlink" title="5. 将字符串类型的常量变得更有条理"></a>5. 将字符串类型的常量变得更有条理</h4><p>在 Swift ⾥通常会把这些常量变成⼀个具有字符串原始值的枚举或者结构体，然后改变函数的入参类型，使其接受相应的枚举或者结构体类型。不加任何处理的 OC 代码无法将设置的多个常量聚拢在一起，无法生成 Swift 中的结构体。</p>
<p>在 typedef 后⾯加上 NS_STRING_ENUM 即可, 此时，原有的字符串常量将以结构体的⽅式导⼊到 Swift 中. (这条验证后没有效果)</p>
<h4 id="6-关于构造器的相关约定"><a href="#6-关于构造器的相关约定" class="headerlink" title="6. 关于构造器的相关约定"></a>6. 关于构造器的相关约定</h4><p>这个约定的大体内容是这样的，将初始化器分为两类，designated 和 convenience。你需要覆盖所有 designated 初始化器，以便安全地继承 convenience 的初始化器。</p>
<p>这个约定和 Swift 里面的构造器约定十分相似，但它们有个本质的区别！OC 的这种构造器约定不是语⾔级别的强制规则，更多的是⼀个开发者之间的约定，例如 convenience 必须选择⼀个 designated 的接口，但实际上很多 OC 的类并没这么做，这也意味着如果有⼦类的话，如何正确构造它会成为⼀个头⼤的问题！</p>
<p>通常 designated 构造器会调⽤ [super init] 这个方法，而 convenience 构造器会调⽤⾃⾝的某个 designated 构造器。我们需要在 designated 构造器后面添加 NS_DESIGNATED_INITIALIZER, 对于 convenience 类型的构造器，你不需要做任何事情</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/OCForSwift/20200910160144.jpg" alt=""></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-nonull-和-nullable-只能在方法和属性上使用，如果想拓展其使用场景，就需要直接调用这两关键字底层的内容，也就是-Nonnull-和-Nullable。"><a href="#1-nonull-和-nullable-只能在方法和属性上使用，如果想拓展其使用场景，就需要直接调用这两关键字底层的内容，也就是-Nonnull-和-Nullable。" class="headerlink" title="1. nonull 和 nullable 只能在方法和属性上使用，如果想拓展其使用场景，就需要直接调用这两关键字底层的内容，也就是 _Nonnull 和 _Nullable。"></a>1. nonull 和 nullable 只能在方法和属性上使用，如果想拓展其使用场景，就需要直接调用这两关键字底层的内容，也就是 _Nonnull 和 _Nullable。</h4><h4 id="2-对于数字处理统一使用-Int，工程中混编-MCRollingNoticeView-中-index-转化后为-UInt-类型，因其-OC-中使用了-NSUInteger-类型。转化后可能导致的越界问题。-注意"><a href="#2-对于数字处理统一使用-Int，工程中混编-MCRollingNoticeView-中-index-转化后为-UInt-类型，因其-OC-中使用了-NSUInteger-类型。转化后可能导致的越界问题。-注意" class="headerlink" title="2. 对于数字处理统一使用 Int，工程中混编 MCRollingNoticeView 中 index 转化后为 UInt  类型，因其 OC 中使用了 NSUInteger 类型。转化后可能导致的越界问题。(注意!!!)"></a>2. 对于数字处理统一使用 Int，工程中混编 MCRollingNoticeView 中 index 转化后为 UInt  类型，因其 OC 中使用了 NSUInteger 类型。转化后可能导致的越界问题。(注意!!!)</h4><h4 id="3-除了关注父类的-designated-构造器，开发者也需要关注-convenience-类型的构造器。"><a href="#3-除了关注父类的-designated-构造器，开发者也需要关注-convenience-类型的构造器。" class="headerlink" title="3. 除了关注父类的 designated 构造器，开发者也需要关注 convenience 类型的构造器。"></a>3. 除了关注父类的 designated 构造器，开发者也需要关注 convenience 类型的构造器。</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然查看编译器生成的 Swift 头文件是一个好的方法。但⽣ 成的接口并不是全部，真正重要的是使用者在实际使⽤过程中写出的调⽤代码。所以当我们在思考如何打造一个更适合 Swift 使用的接口时，不光要看看⽣成的接口。也应该考虑实际的使用场景。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://mp.weixin.qq.com/s/hPmL2fsAfQ-moeM5TjsliQ" target="_blank" rel="external">让 Objective-C 框架与 Swift 友好共存的秘籍</a></p>
<p><a href="https://developer.apple.com/documentation/swift/objective-c_and_c_code_customization" target="_blank" rel="external">通过在 Objective-C 中设置 api 的特定宏来定制 Objective-C 代码并将其导入 Swift</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2020/10680/?time=863" target="_blank" rel="external">WWDC2020 Refine Objective-C frameworks for Swift</a></p>
<p>–EOF–</p>
<p>本篇文章主要参照了 <a href="https://mp.weixin.qq.com/s/hPmL2fsAfQ-moeM5TjsliQ" target="_blank" rel="external">让 Objective-C 框架与 Swift 友好共存的秘籍</a> 转载请保留原作者文章链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了使 Objective-C 代码更好的符合 Swift 的使用习惯，主要有以下几种处理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵循编译器的某些规则&lt;/li&gt;
&lt;li&gt;在头文件里进行特殊标注&lt;/li&gt;
&lt;li&gt;用 Swift 做中间层，重新封装原有代码&lt;/li&gt;
&lt;li&gt;根据自
    
    </summary>
    
      <category term="探索" scheme="http://XibHe.github.io/categories/%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Swift" scheme="http://XibHe.github.io/tags/Swift/"/>
    
      <category term="混编" scheme="http://XibHe.github.io/tags/%E6%B7%B7%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>AFN弱网环境下接口请求超时或被 cancel 问题分析</title>
    <link href="http://XibHe.github.io/2020/05/08/AFN_error_cancel/"/>
    <id>http://XibHe.github.io/2020/05/08/AFN_error_cancel/</id>
    <published>2020-05-07T16:00:00.000Z</published>
    <updated>2020-05-08T16:18:53.612Z</updated>
    
    <content type="html"><![CDATA[<p>在弱网络环境下启动 App 进入首页，网络请求超时或者被 cancel 后，不会走网络请求失败的 failure 回调，导致该回调中隐藏假首页 (模态首页) 的代码不会执行，最终无法进入真正首页的问题。</p>
<h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><ol>
<li>弱网环境 （可以使用 iPhone 的开发者模式或者通过 Charles 模拟弱网环境）</li>
<li>建议使用真机测试</li>
<li>建议使用生产环境数据进行测试</li>
</ol>
<h3 id="模拟弱网环境测试"><a href="#模拟弱网环境测试" class="headerlink" title="模拟弱网环境测试"></a>模拟弱网环境测试</h3><p>项目中网络请求框架对超时时间和重连次数的设置：<br>当前 AFNetworking 的超时时间 MCNetworkRequestTimeoutInterval = 20.f，<br>重连次数 MCNetworkRetryTimes = 3</p>
<ol>
<li>开发者 —&gt; Network Link Conditioner —&gt; Very Bad Network<br>失败接口，error.code == -999，Error Domain=NSURLErrorDomain Code=-999 “已取消”。对应接口以下 6 个接口：</li>
</ol>
<ul>
<li>UserInfo={NSErrorFailingURLStringKey=<a href="https://test.com/api/ad/get}" target="_blank" rel="external">https://test.com/api/ad/get}</a></li>
<li>UserInfo={NSErrorFailingURLStringKey=<a href="https://test.com.com/mall_trade/api/cart/list}" target="_blank" rel="external">https://test.com.com/mall_trade/api/cart/list}</a></li>
<li>UserInfo={NSErrorFailingURLStringKey=<a href="https://test.com/api/account/salesinfo}" target="_blank" rel="external">https://test.com/api/account/salesinfo}</a></li>
<li>UserInfo={NSErrorFailingURLStringKey=<a href="https://test.com/api/cms/getmodulesbyroute}" target="_blank" rel="external">https://test.com/api/cms/getmodulesbyroute}</a></li>
<li>UserInfo={NSErrorFailingURLStringKey=<a href="https://test.com/api/cms/gettabbar}" target="_blank" rel="external">https://test.com/api/cms/gettabbar}</a></li>
<li>UserInfo={NSErrorFailingURLStringKey=<a href="https://test.com/api/im/getgroupinfo}" target="_blank" rel="external">https://test.com/api/im/getgroupinfo}</a></li>
</ul>
<p>需要注意的是：在该 Very Bad Network 环境下，所有进入失败的接口请求都为 -999，即，已被取消的接口请求。具体代码如下：</p>
<pre><code class="objectivec"> } failure:^(NSError *error) {        
        if (error.code == -999) {
            //request cancel. nothing todo
        } else {
            //网络不通
            if (failure) {
                failure(error);
            }
        }
    } repeatCancel:repeatCancel];
</code></pre>
<p>此网络状态下，超时重连后会正常回调 failure 的的方法。</p>
<ol>
<li>开发者 —&gt; Network Link Conditioner —&gt;90% Loss (自定义 In Packet Loss 90，Out Packet Loss 0)<br>触发网络框架的重连机制，通过网络框架中的扩展方法 AFHTTPSessionManager+MCRetryPolicy.h 进行重连，</li>
</ol>
<pre><code class="objectivec">// #import &quot;AFHTTPSessionManager+MCRetryPolicy.h&quot;
- (NSURLSessionDataTask *)requestUrlWithRetryRemaining:(NSInteger)retryRemaining maxRetry:(NSInteger)maxRetry retryInterval:(NSTimeInterval)retryInterval progressive:(bool)progressive fatalStatusCodes:(NSArray&lt;NSNumber *&gt; *)fatalStatusCodes originalRequestCreator:(NSURLSessionDataTask *(^)(void (^)(NSURLSessionDataTask *, NSError *)))taskCreator originalFailure:(void(^)(NSURLSessionDataTask *task, NSError *))failure {
   if (retryRemaining &gt; 0) {
            void (^addRetryOperation)(void) = ^{
                [self requestUrlWithRetryRemaining:retryRemaining - 1 maxRetry:maxRetry retryInterval:retryInterval progressive:progressive fatalStatusCodes:fatalStatusCodes originalRequestCreator:taskCreator originalFailure:failure];
            };
            if (retryInterval &gt; 0.0) {
                dispatch_time_t delay;
                if (progressive) {
                    delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(retryInterval * pow(2, maxRetry - retryRemaining) * NSEC_PER_SEC));
                    [self logMessage:@&quot;Delaying the next attempt by %.0f seconds …&quot;, retryInterval * pow(2, maxRetry - retryRemaining)];
                } else {
                    delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(retryInterval * NSEC_PER_SEC));
                    [self logMessage:@&quot;Delaying the next attempt by %.0f seconds …&quot;, retryInterval];
                }

                // Not accurate because of &quot;Timer Coalescing and App Nap&quot; - which helps to reduce power consumption.
                dispatch_after(delay, dispatch_get_main_queue(), ^(void){
                    addRetryOperation();
                });

            } else {
                addRetryOperation();
            }

        } else {
            [self logMessage:@&quot;No more attempts left! Will execute the failure block.&quot;];
            failure(task, error);
        }
}
</code></pre>
<h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>埋点库 MCStatisticsManager 由于传递 protobuf 格式的数据，在上报埋点请求时其序列化的类型被设置为：MCRequestSerializerTypeProtobuf，响应序列化 serializer = [AFProtobufResponseSerializer serializer]; 而正常的非上报埋点请求的序列化为 MCRequestSerializerTypeJSON。所以当遇到弱网和非弱网访问时，会造成两种截然不同的处理结果：</p>
<ul>
<li>弱网情况下：</li>
</ul>
<p>因网络原因导致请求超时，会触发重连机制，在重新连接网络时，会 resume 重启之前被 suspend 暂停的网络请求 task，再次调用单例 MCNetworkManager 序列化方法，此时，由于是异步执行网络请求，在此之前，埋点上报 MCStatisticsManager已经将网络请求序列方式修改为MCRequestSerializerTypeProtobuf。  在调用非上报埋点的网络接口时，因其请求需要被序列化为 MCRequestSerializerTypeJSON，序列化类型与现有MCNetworkManager序列化类型不匹配，导致报错：</p>
<pre><code>序列化失败 = Error Domain=com.alamofire.error.serialization.request Code=-1016 &quot;The `parameters` argument is not valid Protobuf.&quot; UserInfo={NSLocalizedFailureReason=The `parameters` argument is not valid Protobuf.}
url = https://mallapi-stage.yunshanmeicai.com/api/auth/loginbytickets
时间 = 2020-05-08 09:27:22 +0000
</code></pre><p>此时，序列化错误 serializationError 会造成 task 请求返回 nil 的 NSURLSessionDataTask，</p>
<pre><code class="objective-c">// #import &quot;AFHTTPSessionManager.h&quot;
- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method
                                       URLString:(NSString *)URLString
                                      parameters:(id)parameters
                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress
                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress
                                         success:(void (^)(NSURLSessionDataTask *, id))success
                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure
{
    NSError *serializationError = nil;
    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];

    NSLog(@&quot;\n序列化失败 = %@\nurl = %@\n时间 = %@\n&quot;, serializationError, URLString, [NSDate date]);
    if (serializationError) {
        if (failure) {
            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
                failure(nil, serializationError);
            });
        }

        return nil;
    }

    __block NSURLSessionDataTask *dataTask = nil;
    dataTask = [self dataTaskWithRequest:request
                          uploadProgress:uploadProgress
                        downloadProgress:downloadProgress
                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
        NSLog(@&quot;\n网络回来了 = %@\n失败是什么 = %@\ndataTask = %@&quot;, URLString, error, dataTask);
        if (error) {
            if (failure) {
                failure(dataTask, error);
            }
        } else {
            if (success) {
                success(dataTask, responseObject);
            }
        }
    }];

    return dataTask;
}
</code></pre>
<p>当因序列化失败触发 failure 的 block 回调返回空的 NSURLSessionDataTask，</p>
<pre><code class="objective-c">dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
      failure(nil, serializationError);
});
</code></pre>
<p>该失败回调会触发最后一步 MCNetworkManager 中对应 post 请求的 failure 中的回调方法，</p>
<pre><code class="objective-c">// #import &quot;MCNetworkManager.h&quot;
- (void)executeDataTaskWithURL:(NSString *)url
                    parameters:(id)parameters
               timeoutInterval:(NSTimeInterval)timeoutInterval
                   requestType:(MCRequestType)requestType
         requestSerializerType:(MCRequestSerializerType)requestSerializerType
                 requestHeader:(NSDictionary *)requestHeader
        responseSerializerType:(MCResponseSerializerType)responseSerializerType
                      progress:(NetworkProgressBlock)progress
                       success:(NetworkSuccessBlock)success
                       failure:(NetworkErrorBlock)failure
                  repeatCancel:(BOOL)repeatCancel {


case MCRequestTypePost: {
            if (requestHeader.allKeys.count &gt; 0) {
                for (NSString *key in requestHeader.allKeys) {
                    id value = [requestHeader objectForKey:key];
                    [self.manager.requestSerializer setValue:value forHTTPHeaderField:key];
                }
            }
            task = [self.manager POST:url parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) {

            } success:^(NSURLSessionDataTask *task, id responseObject) {
                [weakSelf removeExecutingTaskWithKey:url];
                if (success) {
                    success(responseObject);
                }
            } failure:^(NSURLSessionDataTask *task, NSError *error) {

//  NSLog(@&quot;task是 = %@ 错误原因 = %@ url是 = %@&quot;, task, error, url);
                if (task.state == NSURLSessionTaskStateCompleted) {
                    [weakSelf removeExecutingTaskWithKey:url];
                    if (failure) {
                        failure(error);
                    }
                }
            } retryCount:MCNetworkRetryTimes retryInterval:0 progressive:false fatalStatusCodes:nil];
        }
            break;
}
</code></pre>
<p>需要注意⚠️的是：该方法判断了传递过来的 task 的 state 是否为 NSURLSessionTaskStateCompleted才会返回最终的网络请求失败的 failure 回调，但是此时传递过来的 task 因为序列化失败而为 nil，这样就不会触发 failure 回调。因此，在弱网情况下，因接口请求超时，导致接口请求失败的 failure 回调方法中对失败处理的代码就不会执行了。造成弱网络启动时，因超时接口请求失败，模态首页无法在失败回调中移除。</p>
<p>通过输出重连时，请求序列化不同类型的时间，对比同一接口在重连前后序列化成功或者失败的情况。</p>
<pre><code class="objective-c">// #import &quot;MCNetworkManager.h&quot;
- (AFHTTPRequestSerializer *)requestSerializerWithType:(MCRequestSerializerType)type timeoutInterval:(NSTimeInterval)timeoutInterval {
    NSLog(@&quot;request 序列化 = %@, 类型为 = %@&quot;, [NSDate date], @(type));
    AFHTTPRequestSerializer *serializer = [AFHTTPRequestSerializer serializer];
    if (type == MCRequestSerializerTypeJSON) {
        serializer = [AFJSONRequestSerializer serializer];
    }
    else if (type == MCRequestSerializerTypePropertyList) {
        serializer = [AFPropertyListRequestSerializer serializer];
    } else if (type == MCRequestSerializerTypeProtobuf) {
        serializer = [AFProtobufRequestSerializer serializer];
    }
    serializer.timeoutInterval = timeoutInterval;
    return serializer;
}
</code></pre>
<h3 id="对比重连机制序列化改变时间"><a href="#对比重连机制序列化改变时间" class="headerlink" title="对比重连机制序列化改变时间"></a>对比重连机制序列化改变时间</h3><p>输出 log 日志如下：</p>
<pre><code>2020-05-08 17:25:35.770423+0800 MeicaiStore[69492:1057810] request 序列化 = 2020-05-08 09:25:35 +0000, 类型为 = 1
</code></pre><pre><code>request 序列化 = 2020-05-08 09:25:35 +0000, 类型为 = 3
request 序列化 = 2020-05-08 09:25:41 +0000, 类型为 = 3
request 序列化 = 2020-05-08 09:25:49 +0000, 类型为 = 3
</code></pre><pre><code>序列化失败 = (null)
url = https://mallapi-stage.yunshanmeicai.com/api/auth/loginbytickets
时间 = 2020-05-08 09:25:35 +0000
</code></pre><pre><code>序列化失败 = Error Domain=com.alamofire.error.serialization.request Code=-1016 &quot;The `parameters` argument is not valid Protobuf.&quot; UserInfo={NSLocalizedFailureReason=The `parameters` argument is not valid Protobuf.}
url = https://mallapi-stage.yunshanmeicai.com/api/auth/loginbytickets
时间 = 2020-05-08 09:27:22 +0000
</code></pre><ul>
<li>在 09:25:35 时接口 auth/loginbytickets 的序列化类型为 1 即，MCRequestSerializerTypeJSON，此时，序列化成功未报错。</li>
<li>在 09:25 时，序列化类型已经变为3，即，MCRequestSerializerTypeProtobuf</li>
<li><p>在网络重连后的 09:27:22 时，序列化失败，此时  MCNetworkManager 序列化类型已经被改变，报parameters` argument is not valid Protobuf 序列化不匹配的错误。最终导致接口请求的 failure 回调不被执行。</p>
</li>
<li><p>非弱网情况下：<br>非弱网情况下，不会触发网络连接超时的重连机制。每个网络请求都对应当前设置的序列化类型</p>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在埋点库 — MCStatisticsManager 中重新初始化一个新的用于网络上报埋点的 MCNetworkManager，而不是之前的单例 [MCNetworkManager sharedInstance]，去执行上报埋点数据的网络请求。</p>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>超时时间设置为 20 秒，重连次数为 3 次。导致在弱网情况下，网络请求failure 回调处理等待时间过长的问题。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在弱网络环境下启动 App 进入首页，网络请求超时或者被 cancel 后，不会走网络请求失败的 failure 回调，导致该回调中隐藏假首页 (模态首页) 的代码不会执行，最终无法进入真正首页的问题。&lt;/p&gt;
&lt;h3 id=&quot;测试流程&quot;&gt;&lt;a href=&quot;#测试流程&quot; c
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="AFNetworking" scheme="http://XibHe.github.io/tags/AFNetworking/"/>
    
      <category term="弱网" scheme="http://XibHe.github.io/tags/%E5%BC%B1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>React Native 父子组件间通信</title>
    <link href="http://XibHe.github.io/2019/06/20/RN%20%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://XibHe.github.io/2019/06/20/RN 父子组件通信/</id>
    <published>2019-06-19T16:00:00.000Z</published>
    <updated>2021-04-27T00:19:42.992Z</updated>
    
    <content type="html"><![CDATA[<p>props</p>
<p>父组件-&gt;子组件，父组件调用并传值给子组件</p>
<p>父组件通过 props 把数据传给子组件，子组件通过 this.props 去使用相应的数据。例如，在父组件标签中定义 props 及对应的值，</p>
<p><dishesleftlist ref="{this.leftListRef}" saleclasstwodata="{saleClassTwoData}" setsaleclasstwoid="{this.selectClassTwoClick.bind(this)}"><br>在子组件中解构获取 props 传递过来的值并赋给对应的组件</dishesleftlist></p>
<p>render () {<br>   const { saleClassTwoData } = this.props<br>    return (<br>        <view style="{styles.container}"><br>            <flatlist data="{saleClassTwoData}" renderitem="{({" item,="" index="" })=""> this.renderItem(item, index)}<br>             keyExtractor={(item) =&gt; item.id}<br>            /&gt;<br>        </flatlist></view><br>    )<br>}<br>ref</p>
<p>父组件可以通过使用 ref 来直接调用子组件实例的方法，</p>
<p>在 constructor 定义一个全局变量，并创建 ref<br>this.leftListRef = React.createRef()<br>将 1 中定义的 this.leftListRef 以属性形式传递给子组件，</p>
<p><dishesleftlist ref="{this.leftListRef}"><br>在父组件中通过 this.leftListRef 调用子组件中的函数并传递参数<br>refreshSKUListForSwitch = (position) =&gt; {<br>    const { saleClassOneData, saleClassTwoData } = this.state<br>     // 切换二级分类<br>    this.leftListRef.current.setSelectItem(this._classTwoIndex - 1)<br>}<br>其中，setSelectItem 为子组件 DishesLeftList 中定义的函数</dishesleftlist></p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;props&lt;/p&gt;
&lt;p&gt;父组件-&amp;gt;子组件，父组件调用并传值给子组件&lt;/p&gt;
&lt;p&gt;父组件通过 props 把数据传给子组件，子组件通过 this.props 去使用相应的数据。例如，在父组件标签中定义 props 及对应的值，&lt;/p&gt;
&lt;p&gt;&lt;dishesleftl
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="ReactNative" scheme="http://XibHe.github.io/tags/ReactNative/"/>
    
      <category term="RN 组件" scheme="http://XibHe.github.io/tags/RN-%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存泄漏检测</title>
    <link href="http://XibHe.github.io/2019/05/27/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/"/>
    <id>http://XibHe.github.io/2019/05/27/iOS内存泄漏检测/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2019-06-02T09:52:59.845Z</updated>
    
    <content type="html"><![CDATA[<p>最近对项目中存在的内存泄露问题的检测做了一些总结，一些检测工具的使用及简单内存泄露问题的处理。</p>
<p>内存泄漏排查，三步走：</p>
<ol>
<li><em>Analyzer</em>（静态分析） </li>
<li><em>MLeaksFinder</em> (第三方工具) </li>
<li><em>Instruments Leaks</em> (动态检测)</li>
</ol>
<h3 id="Analyaer"><a href="#Analyaer" class="headerlink" title="Analyaer"></a>Analyaer</h3><p>不需要运行程序，通过 <em>Product-&gt;Analyze</em> 或快捷键 <em>command+shift+B</em> 进行代码分析。</p>
<p>分析代码上下文的语法结构和内存情况，找出代码中潜在错误 <em>Analyzer</em>主要分析四种问题：</p>
<ol>
<li>逻辑错误：访问空指针或未初始化的变量等；</li>
<li>内存管理错误：如内存泄漏等；</li>
<li>声明错误：从未使用过的变量；</li>
<li><em>API</em> 调用错误：未包含使用的库和框架。</li>
</ol>
<p>后面提到的 <em>CoreLocation</em> 框架的需要手动释放问题，就是通过 <em>Analyzer</em> 检测出来的。</p>
<p>说明： Analyzer由于是编译器根据代码进行的判断, 做出的判断不一定会准确, 因此如果遇到提示, 应该去结合代码上文检查一下；还有某些造成内存泄漏的循环引用通过Analyzer分析不出来。</p>
<h3 id="MLeaksFinder"><a href="#MLeaksFinder" class="headerlink" title="MLeaksFinder"></a>MLeaksFinder</h3><p>通过 </p>
<p><code>pod &#39;MLeaksFinder&#39;</code></p>
<p>或将下载的 <em>MLeaksFinder</em>  文件导入工程中，</p>
<p>在 <em>MLeaksFinder.h</em> 中 设置是否开启内存泄漏检测，以及是在模拟器中开始还是在真机中开启。</p>
<pre><code class="objectivec">//***内存泄漏控制开关，注释该行代码打开内存泄漏工具，打开该行代码关闭内存泄漏****
//#define MEMORY_LEAKS_FINDER_ENABLED 0

#ifdef MEMORY_LEAKS_FINDER_ENABLED

#define _INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED

#else

//仅在模拟器打开内存泄漏检测
#if TARGET_IPHONE_SIMULATOR  //模拟器
    #define _INTERNAL_MLF_ENABLED DEBUG
#elif TARGET_OS_IPHONE      //真机

#endif//TARGET_IPHONE_SIMULATOR

#endif//_INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED
</code></pre>
<p>具体操作步骤：<br>不断重复 <em>push</em> 和 <em>pop</em> 同一个 <em>UIViewController</em>，一旦有疑似内存泄漏的地方，就会弹出提示框，控制台也会输出调用栈的层级信息：</p>
<pre><code class="objectivec">[文件:MLeaksMessenger.m   行数:36] Memory Leak: (
    MCLocateAddressViewController,
    UIView,
    BMKMapView,
    BMKInternalMapView,
    BMKTapDetectingView,
    BMKAnnotationContainer
)

[文件:NSObject+MemoryLeak.m   行数:54] Possibly Memory Leak.
In case that BMKAnnotationContainer should not be dealloced, override -willDealloc in BMKAnnotationContainer by returning NO.
View-ViewController stack: (
    MCLocateAddressViewController,
    UIView,
    BMKMapView,
    BMKInternalMapView,
    BMKTapDetectingView,
    BMKAnnotationContainer
)
</code></pre>
<p>展示视图自上而下的调用层级，这里需要注意一些三方 <em>SDK</em> 控件导致的疑似泄漏，可能会因其内部的 <em>cache</em> 机制或者释放不及时而被误判为内存泄漏。</p>
<h3 id="Instruments-Leaks"><a href="#Instruments-Leaks" class="headerlink" title="Instruments Leaks"></a>Instruments Leaks</h3><p>这里使用最新版 Xcode 10.3 进行 leaks 检测。</p>
<h4 id="1-Xcode-中-按住-command-I-或者菜单栏-Product-–-Profile"><a href="#1-Xcode-中-按住-command-I-或者菜单栏-Product-–-Profile" class="headerlink" title="1. Xcode 中 按住 command + I 或者菜单栏 Product – Profile"></a>1. <em>Xcode</em> 中 按住 <em>command + I</em> 或者菜单栏 <em>Product – Profile</em></h4><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_01.jpg" alt=""></p>
<h4 id="2-双击-Leaks-或者按-choose，打开-Leaks-面板"><a href="#2-双击-Leaks-或者按-choose，打开-Leaks-面板" class="headerlink" title="2. 双击 Leaks 或者按 choose，打开 Leaks 面板"></a>2. 双击 <em>Leaks</em> 或者按 <em>choose</em>，打开 <em>Leaks</em> 面板</h4><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_02.jpg" alt=""></p>
<h4 id="3-在显示的-Leaks-面板中，点击左上角红色点，即可运行内存检测"><a href="#3-在显示的-Leaks-面板中，点击左上角红色点，即可运行内存检测" class="headerlink" title="3. 在显示的 Leaks 面板中，点击左上角红色点，即可运行内存检测"></a>3. 在显示的 <em>Leaks</em> 面板中，点击左上角红色点，即可运行内存检测</h4><h4 id="4-在运行过程中如果发现Leak-Checks（如图）出现红色X说明检测到内存泄露-将鼠标点击Leak-Checks，在下方即可看到内存泄漏的相关信息"><a href="#4-在运行过程中如果发现Leak-Checks（如图）出现红色X说明检测到内存泄露-将鼠标点击Leak-Checks，在下方即可看到内存泄漏的相关信息" class="headerlink" title="4. 在运行过程中如果发现Leak Checks（如图）出现红色X说明检测到内存泄露,将鼠标点击Leak Checks，在下方即可看到内存泄漏的相关信息"></a>4. 在运行过程中如果发现Leak Checks（如图）出现红色X说明检测到内存泄露,将鼠标点击Leak Checks，在下方即可看到内存泄漏的相关信息</h4><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_03.jpg" alt=""></p>
<h4 id="5-定位内存泄漏代码位置"><a href="#5-定位内存泄漏代码位置" class="headerlink" title="5. 定位内存泄漏代码位置"></a>5. 定位内存泄漏代码位置</h4><h5 id="1-选择-Leaks-有时候默认是-Run-lssues，这时需要将其切换为-Leaks"><a href="#1-选择-Leaks-有时候默认是-Run-lssues，这时需要将其切换为-Leaks" class="headerlink" title="1. 选择 Leaks 有时候默认是 Run lssues，这时需要将其切换为 Leaks"></a>1. 选择 <em>Leaks</em> 有时候默认是 <em>Run lssues</em>，这时需要将其切换为 <em>Leaks</em></h5><h5 id="2-选择-call-Three"><a href="#2-选择-call-Three" class="headerlink" title="2. 选择 call Three"></a>2. 选择 <em>call Three</em></h5><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_04.jpg" alt=""></p>
<h5 id="3-此时，仍然看不到具体的代码位置，需要选择底部的-Call-Tree，在弹窗中选择-Invert-Call-Tree-和-Hide-System-Libraries，即可显示出具体内存泄漏的代码"><a href="#3-此时，仍然看不到具体的代码位置，需要选择底部的-Call-Tree，在弹窗中选择-Invert-Call-Tree-和-Hide-System-Libraries，即可显示出具体内存泄漏的代码" class="headerlink" title="3. 此时，仍然看不到具体的代码位置，需要选择底部的 Call Tree，在弹窗中选择 Invert Call Tree 和 Hide System Libraries，即可显示出具体内存泄漏的代码"></a>3. 此时，仍然看不到具体的代码位置，需要选择底部的 <em>Call Tree</em>，在弹窗中选择 <em>Invert Call Tree</em> 和 <em>Hide System Libraries</em>，即可显示出具体内存泄漏的代码</h5><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_05.jpg" alt=""></p>
<p><em>Call Tree</em> 四种选项具体含义：</p>
<p><font color="#DC143C">Separate by Thread：</font>按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。</p>
<p><font color="#DC143C">Invert Call Tree：</font>反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。</p>
<p><font color="#DC143C">Hide System Libraries：</font>隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。</p>
<p><font color="#DC143C">Flattern Recursion：</font>拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。</p>
<h5 id="4-双击选中行，即可跳转-Instrument-中具体的代码"><a href="#4-双击选中行，即可跳转-Instrument-中具体的代码" class="headerlink" title="4. 双击选中行，即可跳转 Instrument 中具体的代码"></a>4. 双击选中行，即可跳转 <em>Instrument</em> 中具体的代码</h5><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_06.jpg" alt=""></p>
<h5 id="5-点击右侧-Xcode-图标跳转至-Xcode-中定位的内存未回收的代码"><a href="#5-点击右侧-Xcode-图标跳转至-Xcode-中定位的内存未回收的代码" class="headerlink" title="5. 点击右侧 Xcode 图标跳转至 Xcode 中定位的内存未回收的代码"></a>5. 点击右侧 <em>Xcode</em> 图标跳转至 <em>Xcode</em> 中定位的内存未回收的代码</h5><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_07.jpg" alt=""></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="1-注意-Core-Foundation-等底层操作它们不支持-ARC，还需要手动内存管理对象的创建和释放。例如，美菜到家中绘制地图覆盖物的方法："><a href="#1-注意-Core-Foundation-等底层操作它们不支持-ARC，还需要手动内存管理对象的创建和释放。例如，美菜到家中绘制地图覆盖物的方法：" class="headerlink" title="1. 注意 Core Foundation 等底层操作它们不支持 ARC，还需要手动内存管理对象的创建和释放。例如，美菜到家中绘制地图覆盖物的方法："></a>1. 注意 <em>Core Foundation</em> 等底层操作它们不支持 <em>ARC</em>，还需要手动内存管理对象的创建和释放。例如，美菜到家中绘制地图覆盖物的方法：</h4><pre><code class="objectivec">// 根据范围数组 border 的个数初始化定位坐标
CLLocationCoordinate2D *coords = (CLLocationCoordinate2D *)malloc(sizeof(CLLocationCoordinate2D) * borderCount);
BMKPolygon  *polygon = [BMKPolygon polygonWithCoordinates:coords count:borderCount];
free(coords);
</code></pre>
<p><em>CLLocationCoordinate2D</em> 是 系统框架 <em>CoreLocation</em> 中 一个 <em>C</em> 的 结构体，包含经度和纬度两个值 (<em>CLLocation</em> 是一个 objc 的 对象)，需要通过 <em>free</em> 手动释放。这里需要注意以 <em>Core</em> 开头的系统框架的内存管理。</p>
<h4 id="2-如果第五步不出现定位箭头，无法定位到具体代码，则"><a href="#2-如果第五步不出现定位箭头，无法定位到具体代码，则" class="headerlink" title="2. 如果第五步不出现定位箭头，无法定位到具体代码，则"></a>2. 如果第五步不出现定位箭头，无法定位到具体代码，则</h4><p>点击项目工程文件-Buidl Setting-All-搜索Debug Information Format-Debug里选择DWARF with dSYM File（如图）</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/Instrument/Instrument_08.jpg" alt=""></p>
<p>默认情况下，只有 <em>release</em> 环境下为 <em>DWARF with dSYM File</em>，其他环境均为 <em>DWARF</em>。当 <em>Debug Information Format</em> 为 <em>DWARF with dSYM File</em> 的时候，构建过程中多了一步 <em>Generate dSYM File</em>，最终产出的文件也多了一个 <em>dSYM</em> 文件。然后，重新编译启动 <em>Instruments Leaks</em>，重复以上步骤即可定位到具体代码。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="external">MLeaksFinder：精准 iOS 内存泄露检测工具</a></p>
<p><a href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/" target="_blank" rel="external">MLeaksFinder 新特性</a></p>
<p><a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="external">Tencent/MLeaksFinder</a></p>
<p><a href="https://juejin.im/entry/5965f8856fb9a06bad654502" target="_blank" rel="external">浅谈 iOS Crash</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对项目中存在的内存泄露问题的检测做了一些总结，一些检测工具的使用及简单内存泄露问题的处理。&lt;/p&gt;
&lt;p&gt;内存泄漏排查，三步走：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Analyzer&lt;/em&gt;（静态分析） &lt;/li&gt;
&lt;li&gt;&lt;em&gt;MLeaksFinder&lt;/em&gt; (
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="Instruments" scheme="http://XibHe.github.io/tags/Instruments/"/>
    
      <category term="内存泄露" scheme="http://XibHe.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>React Native 原生模块与 JS 模块交互</title>
    <link href="http://XibHe.github.io/2019/03/17/RN_Module/"/>
    <id>http://XibHe.github.io/2019/03/17/RN_Module/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2019-03-17T13:52:26.078Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用 RN 时，需要在 RN 端实现调用系统相册上传选中照片的功能。需要原生模块与 RN 模块进行交互，主要步骤：</p>
<ol>
<li>调用原生系统相；</li>
<li>将选取的照片存到本地沙盒；</li>
<li>再将沙盒路径传给 RN。</li>
</ol>
<p><font color="#DC143C">注意：</font> 这里之所以需要将获取的照片存到沙盒下，再将沙盒路径传递给 RN 是因为 RN 端不支持 iOS 中 NSData 二进制流的数据传输格式。而是通过 multipart/form-data 这种表单方式上传文件。</p>
<blockquote>
<p>FormData 对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。</p>
</blockquote>
<p>在原生与 RN 交互的过程中尝试了几种传递数据的不同方式，这里记录一下，其本质上都是通过实现 RCTBridgeModule 的协议来进行数据交互的。</p>
<p>为了实现 RCTBridgeModule 协议，你的类需要包含 RCT_EXPORT_MODULE() 宏。这个宏也可以添加一个参数用来指定在 Javascript 中访问这个模块的名字。你必须明确的声明要给 Javascript 导出的方法，否则 RN 不会导出任何方法。</p>
<p>按传递数据的不同方式，分为以下三种：</p>
<ol>
<li>Callbacks 回调函数；</li>
<li>原生模块使用 promise 简化代码；</li>
<li>RCTEventEmitter — 向 JS 模块发送事件。</li>
</ol>
<h3 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h3><p>提供一个函数把返回值传回给 JavaScript</p>
<p>在原生模块中，</p>
<pre><code class="objectivec">RCT_EXPORT_METHOD(testCallback:(RCTResponseSenderBlock)callback)
{
    NSArray *items = @[@&quot;callback &quot;, @&quot;test &quot;, @&quot;array&quot;];
    callback(@events);
}
</code></pre>
<p>RCTResponseSenderBlock 只接受一个参数 — 传递给 JavaScript 回调函数的参数数组。</p>
<p>在 RN 中调用，</p>
<pre><code class="js">testBack.testCallback((items) =&gt; {
   this.setState({items: items});
})
</code></pre>
<p>原生模块通常只应调用回调函数一次。但是，它可以保存 callback 并在将来调用。如果你想传递一个 Error 类型的对象给 Javascript，可以用 RCTUtils.h提供的 RCTMakeError 函数。</p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>promise 涉及 ES6 的语法，搭配 ES2016(ES7) 标准的async/await语法则效果更佳。具体使用，桥接原生方法的最后两个参数是 RCTPromiseResolveBlock 和RCTPromiseRejectBlock，则对应的 JS 方法就会返回一个 Promise 对象。</p>
<pre><code class="objectivec">RCT_EXPORT_METHOD(getState:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject){
    SEPrinterManager *manager = [SEPrinterManager sharedInstance];
    CBCentralManager *central = [manager valueForKey:@&quot;centralManager&quot;];
    resolve([self successMessage:@{ @&quot;state&quot;: @(central.state == CBCentralManagerStatePoweredOn)}]);
}

- (NSDictionary *)successMessage:(id)data{
    NSMutableDictionary *response = [NSMutableDictionary dictionary];
    response[@&quot;code&quot;] = @(kBluetoohSuccessCode);
    response[@&quot;data&quot;] = data;
    return response;
}
</code></pre>
<p>现在 JavaScript 端的方法会返回一个 Promise。</p>
<pre><code class="js">import { NativeModules } from &#39;react-native&#39;;

class ConnectBLEPrinter extends Component {

 NativeModules.MCRNBlueTooth.getState.then(res =&gt; {
     console.log(&#39;BLE state:&#39; + res. state);
 }).catch((error) =&gt; {

 });
}
</code></pre>
<p>通过 Callbacks 和通过 Promises 的方式，都可以向 JS 模块传递数据，但都是只能传递一次。如果需要多次向 JS 模块传递数据，可以尝试 RCTEventEmitter 的方式。</p>
<h3 id="RCTEventEmitter"><a href="#RCTEventEmitter" class="headerlink" title="RCTEventEmitter"></a>RCTEventEmitter</h3><p>发送事件的方法 sendEvent 定义在 原生 module 类中，在需要发送事件的地方调用 sendEvent 方法就可以将事件通知发给 RN 端。类似于 iOS 中的通知方法的是实现。 iOS 端与 Android 不同，不使用 DeviceEventEmitter 做监听，而是用 NativeEventEmitter。具体实现方案如下：</p>
<p>自定义的模块类头文件要继承自 RCTEventEmitter，</p>
<pre><code class="objectivec">#import &lt;React/RCTEventEmitter.h&gt;
#import &lt;React/RCTBridgeModule.h&gt;

NS_ASSUME_NONNULL_BEGIN

@interface MJTBlueToothManager : RCTEventEmitter &lt;RCTBridgeModule&gt;

@end

NS_ASSUME_NONNULL_END
</code></pre>
<p>声明事件，</p>
<pre><code class="objectivec">RCT_EXPORT_METHOD(scanBLEList){

    SEPrinterManager *manager = [SEPrinterManager sharedInstance];
    [manager startScanPerpheralTimeout:10 Success:^(NSArray&lt;CBPeripheral *&gt; *perpherals,BOOL isTimeout) {
        NSLog(@&quot;Test-----------&quot;);
        self.deviceArray = perpherals;
    } failure:^(SEScanError error) {
        NSLog(@&quot;请检查蓝牙状态&quot;, nil);
    }];

    // 触发事件（不断将扫描到的外设列表传递给 RN 页面）
    [self sendEventWithName:@&quot;scanBLEList&quot; body:self.deviceArray];
}
</code></pre>
<p>RN 端监听事件，</p>
<pre><code class="js">import { NativeModules, NativeEventEmitter } from &#39;react-native&#39;;
const NativeModule = new NativeEventEmitter(NativeModules.MCRNBlueTooth);

class ConnectBLEPrinter extends Component {

componentDidMount () {
        // 获取当前设备列表
        MCRNBlueTooth.scanBLEList();

       this.listener = NativeModule.addListener(&#39;scanBLEList&#39;,(data) =&gt; {
            console.log(&#39;输出 test&#39; + data.list);
            this.setState({ perpheralList: data.list });
        });

       // 检测蓝牙是否开启
       NativeModules.MCRNBlueTooth.getState.then(res =&gt; {
        console.log(&#39;BLE state:&#39; + res. state);
       }).catch((error) =&gt; {

       });
    }
}

// 移除监听
componentWillUnmount() {
    NativeEventEmitter.removeListener(&#39;scanBLEList&#39;,this.listener);
}
</code></pre>
<p>为避免原生模块发出事件后，RN 中多次收到该事件。需要在 RN 页面声明周期结束后移除对事件的监听。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>最开始与原生交互使用的是 promise 的方式，但在扫描蓝牙外设的场景下通过 promise 不断将扫描（设置 10 秒的扫描超时时间）出的设备列表传递给 RN 时，RN 页面报错：</p>
<pre><code class="js">Illegal callback invocation from native module. This callback type only permits a single invocation from native code.
</code></pre>
<p>正如上文所说，Callbacks 和 Promises 只能传递一次数据。调用一次后就会被立即释放掉。使用 RCTEventEmitter 固然可以实现扫描外设，多次调用方法回传数据。但为了统一项目中数据的调用方式为 Promises，需要修改 Promises 调用方法中的逻辑。 可以在扫描完成后，先停止扫描，再将当前扫描结果返回给 RN 。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://reactnative.cn/docs/native-modules-ios/" target="_blank" rel="external">docs/native-modules-ios</a></p>
<p><a href="https://github.com/crazycodeboy/RNStudyNotes/blob/master/React%20Native%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%E5%90%91JS%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/React%20Native%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%E5%90%91JS%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.md" target="_blank" rel="external">React Native原生模块向JS传递数据的几种方式</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects" target="_blank" rel="external">FormData 对象的使用
</a></p>
<p><a href="https://www.jianshu.com/p/4245b4844a49" target="_blank" rel="external">在React Native Module数据多次回调</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用 RN 时，需要在 RN 端实现调用系统相册上传选中照片的功能。需要原生模块与 RN 模块进行交互，主要步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用原生系统相；&lt;/li&gt;
&lt;li&gt;将选取的照片存到本地沙盒；&lt;/li&gt;
&lt;li&gt;再将沙盒路径传给 RN。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="ReactNative" scheme="http://XibHe.github.io/tags/ReactNative/"/>
    
      <category term="Module" scheme="http://XibHe.github.io/tags/Module/"/>
    
  </entry>
  
  <entry>
    <title>TextInput 二三事</title>
    <link href="http://XibHe.github.io/2019/01/04/RN_TextInput/"/>
    <id>http://XibHe.github.io/2019/01/04/RN_TextInput/</id>
    <published>2019-01-03T16:00:00.000Z</published>
    <updated>2019-03-03T12:24:46.431Z</updated>
    
    <content type="html"><![CDATA[<p>记录下这两天使用 <strong>TextInput</strong> 时遇到的问题及一些注意事项。</p>
<h3 id="TextInput-键盘遮挡视图"><a href="#TextInput-键盘遮挡视图" class="headerlink" title="TextInput 键盘遮挡视图"></a>TextInput 键盘遮挡视图</h3><ol>
<li>KeyboardAvoidingView</li>
</ol>
<pre><code class="js">import { KeyboardAvoidingView, ScrollView } from &#39;react-native&#39;;

&lt;View style={[styles.container]}&gt;
  &lt;KeyboardAvoidingView behavior=&quot;padding&quot; style={{ flex: 1 }}&gt;
    &lt;ScrollView
        style={[styles.scrollViewStyle]}
        keyboardShouldPersistTaps=&quot;handled&quot;
    &gt;
    // 视图布局
   &lt;/ScrollView&gt;
  &lt;/KeyboardAvoidingView&gt;
&lt;/View&gt;
</code></pre>
<p>这里单纯的添加 <strong>KeyboardAvoidingView</strong> 只会移动 <strong>TextInput</strong> 的坐标，但输入框下面还有其他视图，为了不遮挡其他视图，在将整个布局放到<br><strong>ScrollView</strong> 中。</p>
<ol>
<li><a href="https://github.com/APSL/react-native-keyboard-aware-scroll-view" target="_blank" rel="external">react-native-keyboard-aware-scroll-view</a></li>
</ol>
<h3 id="TextInput-中一些需要注意的属性"><a href="#TextInput-中一些需要注意的属性" class="headerlink" title="TextInput 中一些需要注意的属性"></a>TextInput 中一些需要注意的属性</h3><ol>
<li><p>某些属性 iOS 与 Android 的取值或展示样式的差异</p>
<p><strong>TextInput</strong> 在安卓上默认有一个底边框，同时会有一些 padding。如果要想使其看起来和iOS上尽量一致，则需要设置padding: 0，同时设置</p>
<pre><code class="js">underlineColorAndroid=&quot;transparent&quot;
</code></pre>
<p>来去掉底边框。</p>
</li>
<li><p>keyboardShouldPersistTaps 操作键盘</p>
<p>如果当前界面有软键盘，那么点击 <strong>scrollview</strong> 后是否收起键盘，取决于本属性的设置。（<font color="#DC143C">注意：</font>很多人反应 <strong>TextInput</strong> 无法自动失去焦点/需要点击多次切换到其他组件等等问题，其关键都是需要将 <strong>TextInput</strong> 放到<strong>ScrollView</strong>中再设置本属性）</p>
</li>
<li><p>keyboardType 的不同取值，iOS 和 Android 不同之处    </p>
</li>
</ol>
<h3 id="无法通过在-TextInput-标签中定义-ref-调用-clear"><a href="#无法通过在-TextInput-标签中定义-ref-调用-clear" class="headerlink" title="无法通过在 TextInput 标签中定义 ref 调用 clear( )"></a>无法通过在 TextInput 标签中定义 ref 调用 clear( )</h3><p>通过 <strong>ref</strong> 在 <strong>TextInput</strong> 标签中定义不同的引用类型，然后发现无法根据 定义的 <strong>ref</strong> 调用 <strong>TextInput</strong> 的 <strong>clear( )</strong> 方法。</p>
<p>react-native info 为：</p>
<pre><code class="js">Environment:
  OS: macOS High Sierra 10.13.6
  Node: 8.6.0
  Yarn: 1.12.3
  npm: 5.3.0
  Watchman: 4.9.0
  Xcode: Xcode 10.1 Build version 10B61
  Android Studio: 3.2 AI-181.5540.7.32.5014246

Packages: (wanted =&gt; installed)
  react: 16.3.1
  react-native: 0.55.3
</code></pre>
<p>代码如下：</p>
<pre><code class="js"> export class LoginSceneComponent extends Component {
  constructor(props) {
      super(props)
      this.codeTextInputRef = React.createRef()
  }

  changeLoginType = () =&gt; {
   this.codeTextInputRef.current.clear()
  }

  render () {
    return (
       &lt;ScrollView
        style={[styles.scrollViewStyle]}
        keyboardShouldPersistTaps=&quot;handled&quot;
       &gt;
          &lt;TextInput
            ref={this.codeTextInputRef}
            style={[styles.inputStyle]}
            secureTextEntry={this.state.loginTypeFlag}
            value={this.state.passWord}
            onChangeText={text =&gt; this.setState({ passWord: text })}
           /&gt;
       &lt;/ScrollView&gt;
    )  
  }
 }
</code></pre>
<p>最终通过在 </p>
<pre><code class="js">onChangeText={txt =&gt; this.setState({ passWord: txt })}
</code></pre>
<p>方法中重新 setState 参数清除了输入框中内容。</p>
<p><font color="#DC143C">注意：</font> React 16.3 更新了 创建 <strong>Ref</strong> 的方法。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://reactnative.cn/docs/textinput/" target="_blank" rel="external">textinput</a></p>
<p><a href="https://reactnative.cn/docs/keyboardavoidingview/" target="_blank" rel="external">keyboardavoidingview</a></p>
<p><a href="https://github.com/facebook/react-native/issues/18843" target="_blank" rel="external">facebook/react-native/issues/18843</a></p>
<p><a href="https://github.com/facebook/react-native/issues/18272" target="_blank" rel="external">facebook/react-native/issues/18272</a></p>
<p><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="external">refs-and-the-dom</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下这两天使用 &lt;strong&gt;TextInput&lt;/strong&gt; 时遇到的问题及一些注意事项。&lt;/p&gt;
&lt;h3 id=&quot;TextInput-键盘遮挡视图&quot;&gt;&lt;a href=&quot;#TextInput-键盘遮挡视图&quot; class=&quot;headerlink&quot; title=&quot;Te
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="ReactNative" scheme="http://XibHe.github.io/tags/ReactNative/"/>
    
      <category term="TextInput" scheme="http://XibHe.github.io/tags/TextInput/"/>
    
  </entry>
  
  <entry>
    <title>回望2018</title>
    <link href="http://XibHe.github.io/2018/12/31/2018year-endsummary/"/>
    <id>http://XibHe.github.io/2018/12/31/2018year-endsummary/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2019-01-05T08:51:58.640Z</updated>
    
    <content type="html"><![CDATA[<p>2018转眼间就要过去，回首这一年的经历，在这里做个总结，让自己审视（Review、复盘）自己的表现，以决定下一步要怎么做。曾经，好好安放；未来，一步步来! </p>
<h2 id="新工作"><a href="#新工作" class="headerlink" title="新工作"></a>新工作</h2><p>10月份从干了两年多的公司离职，月底入职新公司。从提出离职到入职新公司中间不超过一周，也就是休息了一个周末后就到新公司上班了。这是我代码生涯中第一次以这样一种方式转变。想来没有什么比 <a href="https://zh.wikipedia.org/wiki/熱插拔" target="_blank" rel="external">热插拔</a> 这个计算机用语更合适的词来形容了。</p>
<p>入职新公司，终于有机会学习自己一直想深入理解的 <code class="highlighter-rouge">React Native</code> 跨平台开发技术。可以学习团队最近几年在混合开发领域不断积累的技术沉淀，不用再自己摸石头过河，是一件多么幸运的事情啊！顺便推广一波我们团队在掘金的技术博客 —  <a href="https://juejin.im/user/5b3f46c2e51d451925626977" target="_blank" rel="external">WirelessSprucetec</a> </p>
<p>原生客户端开发的关注点应该放在移动设备 <code class="highlighter-rouge">Web</code> 应用程序上（例如使用 <code class="highlighter-rouge">PWA</code>）和 <code class="highlighter-rouge">React Native</code>，<code class="highlighter-rouge">Flutter</code> 等引领的混合开发领域。</p>
<blockquote>
<p>种一棵树最好的时间是十年前。其次是现在。</p>
</blockquote>
<p>学习新技术总是要亲手敲一敲，多踩踩坑才能有自己的一番理解，也只有将遇到的坑填平才能有所收获，自己这两年的技术提升也正是建立在解决问题之上的。</p>
<h2 id="总结与收获"><a href="#总结与收获" class="headerlink" title="总结与收获"></a>总结与收获</h2><p>回想最近这两年的经历，心中百感交集。再次审视自己之前写的代码，其中不乏有闪光的地方，这些代码多少为解决某些棘手的问题而做的优化或者特殊处理。比如：</p>
<ul>
<li><a href="https://xibhe.com/2018/02/03/WKWebView-disabuse/" target="_blank" rel="external">使用WKWebView进行性能调优</a></li>
<li><a href="https://xibhe.com/2018/04/18/SQLOptimize/" target="_blank" rel="external">从一个数据量过多的优化说起</a></li>
<li><a href="https://xibhe.com/2018/05/28/Compiling/" target="_blank" rel="external">https://xibhe.com/2018/05/28/Compiling/</a></li>
</ul>
<p>技术上的提升也是建立在解决某些疑难问题上的，有时觉得这些需要花费很多时间才能解决的问题，甚至根本不算是问题。因为产生这些疑难 <code class="highlighter-rouge">bug</code> 的根本原因是：自己没有将知识点掌握通透。</p>
<blockquote>
<p>学习的第一步是知道自己学习的这个知识问题是什么，答案是什么，然后找到这些问题和答案之间的关系，这个关系是我们需要学习的东西，最后能把这个关系通过通俗易懂的语言输出出来，那么这个知识你就学会了。</p>
</blockquote>
<p>2019年将继续总结自己在开发中遇到的问题，将心得体会写成博客分享出来。同时，也发现以往博客的一些问题，要么是在某一方面将操作步骤写的特别细致，但又没有触及到问题的本质；要么在某一点上一笔带过，没有罗列出具体流程。同时，研究的技术点比较分散，没有形成一个前后呼应的体系。今年，一定要尝试将不同的技术点分析清楚，形成一个完整的技术体系。</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>认识到目前的不足之处：<code class="highlighter-rouge"> HTML </code>、<code class="highlighter-rouge">CSS</code> 和 <code class="highlighter-rouge">JavaScript</code> 是必须掌握的，需要补足前端基础的短板。既然选择了前端开发相关的技术栈就需要制定一个学习周期和学习计划。</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>技能 — 深入学习前端 <code class="highlighter-rouge"> HTML </code>、<code class="highlighter-rouge">CSS</code> 和 <code class="highlighter-rouge">JavaScript</code> 等前端基础技术。</p>
<p>心态 — 放松 + 自我激励。</p>
<p>工具 — 前端开发工具（<code class="highlighter-rouge">IDE</code>）的熟练使用。</p>
<h2 id="共勉"><a href="#共勉" class="headerlink" title="共勉"></a>共勉</h2><p>不怕路长，就怕心老！</p>
<p>保持好奇，继续热爱！</p>
<p>自己重新定位，选择真正适合自己的方向，重新出发，发现更好的自己。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018转眼间就要过去，回首这一年的经历，在这里做个总结，让自己审视（Review、复盘）自己的表现，以决定下一步要怎么做。曾经，好好安放；未来，一步步来! &lt;/p&gt;
&lt;h2 id=&quot;新工作&quot;&gt;&lt;a href=&quot;#新工作&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="随笔" scheme="http://XibHe.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="年终总结" scheme="http://XibHe.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>离线与同步</title>
    <link href="http://XibHe.github.io/2018/10/25/OffLineWithSync/"/>
    <id>http://XibHe.github.io/2018/10/25/OffLineWithSync/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-11-05T06:13:35.697Z</updated>
    
    <content type="html"><![CDATA[<p>在弱网环境下，将要面对一些问题：频繁请求网络造成请求超时；完全没有网络导致请求失败。那么，针对这种特殊而又普遍的现象，需要做一些额外的功能去弥补弱网环境<br>下的操作体验。于是，针对某些重要功能的离线模式就诞生了！</p>
<p>离线功能是为了满足用户在较短时间断网<font color="55ff">（离线时间最长支持15天）</font>或无法访问服务器的情况下，可以正常的进行部分业务开展；从而保证对核心业务不会造成较大影响。</p>
<h3 id="支持离线模式的模块"><a href="#支持离线模式的模块" class="headerlink" title="支持离线模式的模块"></a>支持离线模式的模块</h3><ol>
<li>登录</li>
<li>看病开方<ul>
<li>新增处方支持离线</li>
<li>处方列表支持离线</li>
</ul>
</li>
<li>零售卖药<ul>
<li>新增售药单支持离线</li>
<li>售药列表支持离线</li>
</ul>
</li>
<li>患者管理<ul>
<li>新增患者支持离线</li>
<li>患者管理支持离线</li>
</ul>
</li>
<li>药房管理<ul>
<li>新增药品支持离线</li>
<li>药品管理支持离线</li>
</ul>
</li>
<li>我的<ul>
<li>诊所管理支持离线</li>
<li>系统设置支持离线</li>
<li>账号设置支持离线</li>
</ul>
</li>
</ol>
<h3 id="离线业务的具体步骤"><a href="#离线业务的具体步骤" class="headerlink" title="离线业务的具体步骤"></a>离线业务的具体步骤</h3><h4 id="1-监听当前设备所处的网络状态？"><a href="#1-监听当前设备所处的网络状态？" class="headerlink" title="1. 监听当前设备所处的网络状态？"></a>1. 监听当前设备所处的网络状态？</h4><p>离线模式切换所经历的三个过程：</p>
<ol>
<li>提示用户 “失去网络连接，3秒后重试”，之后进入 “网络连接中…” 状态；</li>
<li>如果重试3次均失败，提示用户 “重新连接失败，进入离线状态”；</li>
<li>1秒后，提示信息变更为 “因当前网络不可用，您已进入离线状态；离线状态只可使用部分功能！”。</li>
</ol>
<p>离线状态切换的三种状态，</p>
<pre><code class="objectivec">typedef NS_ENUM(NSInteger,offlineNetType) {
    Off_line,//离线
    In_the_Internet,//联网中
    Network_retry//联网重试
};
</code></pre>
<p>监听当前网络的连接状态，若此时未发现可靠网络连接或网络连接失败，则需要经历以上三个阶段，进行离线模式的转换。具体监听步骤如下：</p>
<ol>
<li>增加一个单利，并在单利中声明一个 BOOL 值的属性；</li>
</ol>
<pre><code class="objectivec">@interface Singleton : NSObject

@property(nonatomic,assign)BOOL hasNet;//是否有网络

@end
</code></pre>
<p>初始化时设置该属性默认值为 YES,</p>
<pre><code class="objectivec">
static Singleton *share = nil;

@interface Singleton()

@end

@implementation Singleton

- (instancetype)init
{
    self = [super init];
    if (self) {
        self.hasNet = YES;
    }
    return self;
}

+ (instancetype)shareInstance 
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
         share = [[Singleton alloc] init];
    });
    return share;
}

@end
</code></pre>
<ol>
<li>在工具类中增加判断网络</li>
</ol>
<p><em>SimplePing</em> 是苹果封装好的关于 <a href="https://zh.wikipedia.org/wiki/Ping" target="_blank" rel="external">ping</a> 的类，用于检测网络的连接状态。<em>SimplePing</em> 是一个封装低层级的 <em>BSD Sockets ping</em> 函数的类。使用这个类创建实例，设置委托然后调用 <em>-start</em> 方法开始在当前的 <em>run loop</em> (运行循环)中。如果顺利的话你很快就会得到 <em>-simplePing:didStartWithAddress:</em> 这个委托的回调。之后在这个回调里你就可以调用 <em>-sendPingWithData:</em> 来发送一个 <em>ping</em>，然后等待接收回调 <em>-simplePing:didReceivePingResponsePacket:sequenceNumber:</em> 和 <em>-simplePing:didReceiveUnexpectedPacket:</em></p>
<p>首先新建单利类 <em>LZNetworkAvailability</em>，在初始化方法中指定要 <em>ping</em> 的主机名称，</p>
<pre><code class="objectivec">static LZNetworkAvailability *share = nil;
@interface LZNetworkAvailability()&lt;SimplePingDelegate&gt;
@end

+ (void)shareInstanceNetworkAvailability{
    share = [[LZNetworkAvailability alloc] init];
}

-(instancetype)init{
    if (self = [super init]) {
            NSString *host = @&quot;usersystem.test.com&quot;;
            SimplePing *pinger = [[SimplePing alloc] initWithHostName:host];
            pinger.delegate = self;
            pinger.addressStyle = SimplePingAddressStyleAny;
            self.pinger = pinger;
            [self.pinger start];
    }
    return self;
}

@end
</code></pre>
<p>接下来实现 <em>SimplePing</em> 的代理方法，<em>SimplePingDelegate</em> 一共有6个方法，分别对应 <em>ping</em> 的不同状态：</p>
<pre><code class="objectivec">//开始进行网络检测
- (void)simplePing:(SimplePing *)pinger didStartWithAddress:(NSData *)address;
//网络检测失败
- (void)simplePing:(SimplePing *)pinger didFailWithError:(NSError *)error;
//发送网络包成功
- (void)simplePing:(SimplePing *)pinger didSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber;
//发送网络包失败
- (void)simplePing:(SimplePing *)pinger didFailToSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber error:(NSError *)error;
//收到网络包回应
- (void)simplePing:(SimplePing *)pinger didReceivePingResponsePacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber;
//收到错误的网络包
- (void)simplePing:(SimplePing *)pinger didReceiveUnexpectedPacket:(NSData *)packet;
</code></pre>
<p>然后分别在开始进行网络检测和网络检测失败的代理方法中设置单利类 <em>Singleton</em> 中 <em>hasNet</em> 属性的值，</p>
<pre><code class="objectivec">/**
 *  start成功，也就是准备工作做完后的回调
 */
- (void)simplePing:(SimplePing *)pinger didStartWithAddress:(NSData *)address
{
    // 发送测试报文数据
    [self.pinger sendPingWithData:nil];

    Singleton *sin = [Singleton shareInstance];
    if (!sin.hasNet) {
        sin.hasNet = YES;
        [[NSNotificationCenter defaultCenter] postNotificationName:networkCanBeUsedNotification object:nil];
    }
}
</code></pre>
<p>网络检测失败,</p>
<pre><code>//网络检测失败
- (void)simplePing:(SimplePing *)pinger didFailWithError:(NSError *)error
{
    NSLog(@&quot;didFailWithError&quot;);
    [self.pinger stop];
    Singleton *sin = [Singleton shareInstance];
    sin.hasNet = YES;
    if (sin.isOverdue) {
        if ([[UIViewController getCurrentVC] isKindOfClass:[[LZMediator sharedInstance] LZLoginComponents_loginViewController].class] || [[UIViewController getCurrentVC] isKindOfClass:[[LZMediator sharedInstance] LZLoginComponents_forgetPwdViewController].class]) {
            if (sin.hasNet) {
                sin.hasNet = NO;
                [[NSNotificationCenter defaultCenter] postNotificationName:networkCanNotUsedNotification object:nil];
            }
            return;
        }
        LZCustomAlertView *alertView = [[LZCustomAlertView alloc] initWithTitle:@&quot;温馨提示&quot; content:@&quot;很抱歉，过期诊所不可进入离线模式&quot; close:nil certain:@&quot;我知道了&quot; closeButtonBlock:nil certainButtonBlock:^(LZCustomAlertView *alertView) {
            [LZMainHandler loginOutInitRemovePwd:NO backToLogin:YES];
            if (sin.hasNet) {
                sin.hasNet = NO;
                [[NSNotificationCenter defaultCenter] postNotificationName:networkCanNotUsedNotification object:nil];
            }
        }];
        [alertView show];
    }else{
        if (sin.hasNet) {
            sin.hasNet = NO;
            [[NSNotificationCenter defaultCenter] postNotificationName:networkCanNotUsedNotification object:nil];
        }
    }

}
</code></pre><h4 id="2-使用LZNetworkAvailability测试网络连接状态"><a href="#2-使用LZNetworkAvailability测试网络连接状态" class="headerlink" title="2. 使用LZNetworkAvailability测试网络连接状态"></a>2. 使用LZNetworkAvailability测试网络连接状态</h4><p>基于 <em>SimplePing</em> 的 <em>LZNetworkAvailability</em> 类可以在任何线程上使用，但是用作单例必须限制在指定的开启运行循环的线程。由于在应用程序启动时，就需要实现网络的检测，所有，在 <em>AppDelegate</em> 里进行初始化，</p>
<pre><code class="objectivec">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    //开始网络检测
    [LZNetworkAvailability shareInstanceNetworkAvailability];
}
</code></pre>
<p><strong><font color="55ff">注意：</font></strong><br>这里需要特别注意的一点，网络请求会存在失败的情况，而网络连接问题同样会导致请求失败。这里就需要对这种情况失败情况进行检测，在封装的网络请求方法中，调用 <em>shareInstanceNetworkAvailability</em> 进行检测，</p>
<pre><code class="objectivec">//基本请求接口，是否发送token失效通知
+ (void)baseRequestWithParam:(NSDictionary *)param
                        path:(NSString *)path
                      method:(LZHttpRequestType)method
                loseEfficacy:(BOOL)loseEfficacy
                     success:(void(^)(LZHttpResponseModel *responseModel))success
                     failure:(void(^)(NSError *error))failure{
    [[LZHttpClient defaultClient] requestWithPath:path method:method parameters:[self getDetailDicWithParam:param] prepareExecute:^{

    } success:^(AFHTTPRequestOperation *operation, id responseObject) {
        LZHttpResponseModel *model = [LZHttpResponseModel mj_objectWithKeyValues:responseObject];
        NSLog(@&quot;\n****************response***********:\n%@\n *******************url************:\n%@ \n*****************param**********\n%@&quot;,responseObject,operation.request.URL,param);

        if ([model.body.code isKindOfClass:[NSString class]] &amp;&amp; ![model.body.code isEqualToString:SUCCESS_CODE] &amp;&amp; ![model.body.code isEqualToString:SUCCESS_CODE_NEW] &amp;&amp; ![model.body.code isEqualToString:@&quot;0330&quot;] &amp;&amp; ![model.body.code isEqualToString:@&quot;0336&quot;] &amp;&amp; ![model.body.code isEqualToString:@&quot;0798&quot;]) {
        }
        if (success) {
            success(model);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        Class class = NSClassFromString(@&quot;LZNetworkAvailability&quot;);
        BeginUndeclaredSelectorWarning
        [class performSelector:@selector(shareInstanceNetworkAvailability) withObject:nil];
        EndUndeclaredSelectorWarning
        if (failure) {
            failure(error);
        }
    }];
}
</code></pre>
<p>这里通过 <em>NSClassFromString</em> 找到动态加载的类，直接调用类中的方法。</p>
<h4 id="3-为确保您数据的准确性，请尽快恢复设备的网络连接"><a href="#3-为确保您数据的准确性，请尽快恢复设备的网络连接" class="headerlink" title="3. 为确保您数据的准确性，请尽快恢复设备的网络连接!"></a>3. 为确保您数据的准确性，请尽快恢复设备的网络连接!</h4><p>离线数据的保存最长时间是多少？</p>
<p>离线登录需要判断离线时间，并给出提示？</p>
<h3 id="离线数据在有网环境下的同步"><a href="#离线数据在有网环境下的同步" class="headerlink" title="离线数据在有网环境下的同步"></a>离线数据在有网环境下的同步</h3><p>利用 <em>GCD</em> 中的 <em>dispatch_semaphore</em> 即，信号量来实现不同模块数据的同步。</p>
<p><em>GCD</em> 中的信号量是指 <em>Dispatch Semaphore</em>，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 <em>Dispatch Semaphore</em> 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。<em>Dispatch Semaphore</em> 提供了三个函数。</p>
<p>离线数据上传，</p>
<pre><code class="objectivec">#pragma mark - 离线数据上传
- (void)offLineAllDataUploadWithSync:(BOOL)sync {

    //每次上传都需要新创建一个数组来保存成功返回的流水号
    NSMutableArray *serialNumberMuArr = [[NSMutableArray alloc]init];
    [LZUserDefaults setObject:serialNumberMuArr forKey:PreferenceKey_OffLine_SerialNumberMuArr];

    //保存一个开关
    [LZUserDefaults setObject:@&quot;0&quot; forKey:PreferenceKey_OffLine_OfflineUploadComplete];

    //顺序执行 信号量
    dispatch_semaphore_t sem = dispatch_semaphore_create(1);
    dispatch_queue_t queue = dispatch_queue_create(&quot;OfflineDrugReductionInventoryoffLineAllDataUpload&quot;, NULL);
    dispatch_async(queue, ^{
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
        NSLog(@&quot;WX患者模块&quot;);
        [self offLineNetWorkWithType:@&quot;CP&quot; withSem:sem];
//        dispatch_semaphore_signal(sem);
    });
    if (sync) {
        dispatch_async(queue, ^{
            dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
            NSLog(@&quot;WX设置模块&quot;);
            [self offLineNetWorkWithType:@&quot;CE&quot; withSem:sem];
            //        dispatch_semaphore_signal(sem);
        });
    }
    dispatch_async(queue, ^{
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
        NSLog(@&quot;WX处方模块&quot;);
        [self offLineNetWorkWithType:@&quot;RP&quot; withSem:sem];
//        dispatch_semaphore_signal(sem);
    });
    dispatch_async(queue, ^{
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
        NSLog(@&quot;WX零售模块&quot;);
        [self offLineNetWorkWithType:@&quot;RS&quot; withSem:sem];
//        dispatch_semaphore_signal(sem);
    });
    dispatch_async(queue, ^{
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
        NSLog(@&quot;WX预约挂号&quot;);
        [self offLineNetWorkWithType:@&quot;RE&quot; withSem:sem];
        //        dispatch_semaphore_signal(sem);
    });
    dispatch_async(queue, ^{
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
        NSLog(@&quot;WX数据上传完毕&quot;);
        [LZUserDefaults setObject:@&quot;1&quot; forKey:PreferenceKey_OffLine_OfflineUploadComplete];

        if (sync) {
            [self queryResultFromBackStage];
        }else {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.actionBlock();
            });
        }

        dispatch_semaphore_signal(sem);
    });

}
</code></pre>
<h3 id="数据同步遇到的一些问题"><a href="#数据同步遇到的一些问题" class="headerlink" title="数据同步遇到的一些问题"></a>数据同步遇到的一些问题</h3><p>成功请求一些编辑信息的接口后，会调用相应模块的同步接口。（这样做的利与弊？是否适用于每个数据同步操作？）</p>
<h3 id="后续的优化"><a href="#后续的优化" class="headerlink" title="后续的优化"></a>后续的优化</h3><p>现在生产上一半的问题是数据同步引起的，新的方案是引入第三方IM，诊所所有账户加入到聊天室，当数据产生并上传服务器成功后，发消息到聊天室，其他账户收到消息数据并处理。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><font color="55ff">未完，待续……</font>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/Ping" target="_blank" rel="external">ping</a></p>
<p><a href="https://juejin.im/entry/5873407ea22b9d005898bd9b" target="_blank" rel="external">iOS-ping 网络小工具</a></p>
<p><a href="https://developer.apple.com/library/archive/samplecode/SimplePing/Introduction/Intro.html" target="_blank" rel="external">SimplePing</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在弱网环境下，将要面对一些问题：频繁请求网络造成请求超时；完全没有网络导致请求失败。那么，针对这种特殊而又普遍的现象，需要做一些额外的功能去弥补弱网环境&lt;br&gt;下的操作体验。于是，针对某些重要功能的离线模式就诞生了！&lt;/p&gt;
&lt;p&gt;离线功能是为了满足用户在较短时间断网&lt;fo
    
    </summary>
    
      <category term="功能" scheme="http://XibHe.github.io/categories/%E5%8A%9F%E8%83%BD/"/>
    
    
      <category term="数据同步" scheme="http://XibHe.github.io/tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>(译)重写代码会失败的几个征兆</title>
    <link href="http://XibHe.github.io/2018/08/10/RebuildFlagsSignaling/"/>
    <id>http://XibHe.github.io/2018/08/10/RebuildFlagsSignaling/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2018-11-18T14:16:30.277Z</updated>
    
    <content type="html"><![CDATA[<p>总有一个理由去重构项目。也许你是一个的取得了一些成功，而你的工程师们吵着平台需要改进，要从头开始进行项目重构的CEO。也许你是主管或IT领导，在反复权衡重写老旧项目需要付出多大的成本。也许你是一个已经开始重写老项目的主程(我是疯了吗?)。无论如何，你可能已经知道重构老项目，像关于税收改革或无政府状态的讨论一样，只是稍微有点危险，你永远不知道自己在重构时实际遇到的难题和之前想象中会遇到的根本不是那么回事。</p>
<p>但是，尽管一些德高望重的人（当然，其实只是 <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="external">Joel Spolsky</a> ），对项目进行重构，即使在某些时候，这是正确的选择。但重建仍是一场危险的旅程，你的重构工作很可能由于一些无法预知的难题而失败。</p>
<p>因此，我们提出 “为达到目的，该如何去做”，以下五个标志决定了重构最终的成功与否，你究竟是不是疯了，要看你最终重构的结果如何。</p>
<h2 id="1-没有清晰的重构目标，为重构而重构。"><a href="#1-没有清晰的重构目标，为重构而重构。" class="headerlink" title="1. 没有清晰的重构目标，为重构而重构。"></a>1. 没有清晰的重构目标，为重构而重构。</h2><p>重构必须增加新的价值。事实上，如果在重构的前6个月仍看不到项目重构所带来的价值，你就应该思考项目重构的意义是什么？需要慎之又慎，因为进行大规模的重构工作会耗费大量的资源，老项目30个人花费一年多的时间写的，而现在却只花费6个月的时间进行重构。除非你的部门是 <strong>Google X</strong> 能够负担起长时间开发的费用。你最好能考虑一下。</p>
<p>如果你是一名经理，你自己不知道项目重构能带来的价值是什么，也许是时候结束重构了，或者如果你已经确定你想得到什么，做设计的冲刺与实际用户清楚地捕捉这一愿景和然后重新评估，如果重建的轨道上与您的用户想要什么。 进行 <a href="https://www.gv.com/sprint/" target="_blank" rel="external">design sprint</a> 与实际应用场景结合重新进行项目评估。</p>
<h2 id="2-你将面对大范围的转换式重写"><a href="#2-你将面对大范围的转换式重写" class="headerlink" title="2. 你将面对大范围的转换式重写"></a>2. 你将面对大范围的转换式重写</h2><p>项目功能的转变很容易。只需要切换DNS记录和BOOM就能看到，应用程序在每个方面的全面变化是美学上令人愉快的。项目整体功能转换的重构是所有重构中最需要警惕的。它仅适用于非常简单的系统。有<a href="https://paulhammant.com/2013/07/14/legacy-application-strangulation-case-studies/" target="_blank" rel="external">它仅适用于非常简单的系统</a>的<a href="https://martinfowler.com/bliki/StranglerApplication.html" target="_blank" rel="external">前期准备工作</a>要做，这就是为什么渐进式的重构方式更好，因为：<a href="http://cdn.pols.co.uk/papers/agile-approach-to-legacy-systems.pdf" target="_blank" rel="external">一个大的功能性重构等效于瀑布式方法</a>。</p>
<p>如果你是一名经理，你需要让你的开发人员认识这一点，因为他们很可能正在努力推动一个大的功能性重构。当然，他们从来没有使用这些词，而是选择像“干净的石板”或“重新构架”的词语，但询问他们，我们还要多久可以将这些代码部署到生产环境？如果答案是3个多月了……那么他们很可能在做一个大范围的功能性重构。</p>
<h2 id="3-重构后的新系统速度比老系统慢"><a href="#3-重构后的新系统速度比老系统慢" class="headerlink" title="3. 重构后的新系统速度比老系统慢"></a>3. 重构后的新系统速度比老系统慢</h2><p>这很简单：如果你在进行重构的同时，也在改进现有的老项目，以对冲重构风险并保持竞争优势(这是一个好主意)，但重建您现有的传统产品是不是能以更快的速度添加相同的特性，重构将永远也无法完成。</p>
<p>您的重建团队需要由技术优秀的开发人员组成，他们了解最新的技术，并有足够的脑力去理解遗留系统的复杂性(有趣的是，这似乎是由 **Kernighan 定路和 Peter Principle 混合而成的)。</p>
<p>此外，请确保你的重构小组（一个或多个）能够持续进步更快！不要基于第2-3个月的重建速度来判断。一个项目在初期总是进行的很快，因为复杂的问题尚未考虑，但在进行一段时间后速度就会减缓：</p>
<p><img src="https://www.pkc.io/assets/images/blog/rebuildfail.png" alt=""></p>
<h2 id="4-你是不是和那些旧系统中的专家合作。"><a href="#4-你是不是和那些旧系统中的专家合作。" class="headerlink" title="4. 你是不是和那些旧系统中的专家合作。"></a>4. 你是不是和那些旧系统中的专家合作。</h2><p>任何专家都可以提供帮助 —— 旧系统的前开发人员，财务部的Marge，甚至是高级用户。这些人对重建至关重要，因为他们一开始就知道应用程序的所有问题。没有这些人，你会成为<a href="https://lawsofux.com/teslers-law.html" target="_blank" rel="external">特斯勒定律</a>的受害者。最终生成新系统的价值低于老版本。</p>
<p>可以将它们看作人类测试套件。他们会在几分钟内发现在重新构建中可能永远不会发现的细微实现错误。</p>
<p>涉及到的人。让他们觉得他们对重建是有帮助的(因为他们是参与者)。尽早得到他们的反馈。</p>
<h2 id="5-你打算删除那些很难用的功能"><a href="#5-你打算删除那些很难用的功能" class="headerlink" title="5. 你打算删除那些很难用的功能"></a>5. 你打算删除那些很难用的功能</h2><p>假设您正在重建一个系统，该系统已经取得了一些成功，并且正在积极地为用户提供价值。在“精简化”构建的名义下，很容易陷入使用更少特性进行重构的陷阱。但是，这是否有意义？是的，传统的应用程序可能是缓慢的和丑陋的。但仔细想想，你的用户愿意忍受缓慢的和丑陋的使用这个系统！如果删除，他们使用的功能，你的用户会恨你。</p>
<p>这是否意味着你应该盲目地复制遗留系统的特性？当然不是！遗留技术所必需的一些特性已经变得僵化。现在有一些类似OCR的东西，可以取代表单字段的页面。这意味着你可以自由地重新想象这些特性或创建一个新的流程，该流程允许你删除操作，但是你不能删除需要完成的任务/整个流程，无论多么诱人。</p>
<h2 id="让我们做个总结"><a href="#让我们做个总结" class="headerlink" title="让我们做个总结"></a>让我们做个总结</h2><p>我希望你能注意到，在重构过程中，我们关注的是真实的、当前的价值交付。这就是为什么每次重新构建都要从彻底的设计冲刺开始，挖掘所有的增值特性。这次<strong>sprint</strong> 的核心方法是通过访谈获得最终用户和涉众的反馈，并通过原型确认你的发现。这确保了产品仍然以你所期望的方式满足市场需求，并在基于真实用户反馈的重构过程中留下了创新的空间。</p>
<p>如果你觉得必须在通过重新构建复制一个特别繁重的旧特性和添加新特性之间进行选择，那么你有一些选择。一种选择是使用 <a href="https://www.martinfowler.com/bliki/StranglerApplication.html" target="_blank" rel="external">Martin Fowler’s strangler pattern</a> 模式，通过这种模式，你可以在重新构建中创建新的功能，这些新功能可以同时且相对无缝地与旧功能集成，从而保留了那些功能，而无需重新创建它们。</p>
<p>有什么问题或意见吗？有什么问题吗？请随时联系我们!</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://www.pkc.io/blog/five-red-flags-signaling-your-rebuild-will-fail/?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios" target="_blank" rel="external">5 Red Flags Signaling Your Rebuild Will Fail</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><strong>Google X</strong> </p>
<p>Google X，是谷歌公司最神秘的一个部门，位于美国旧金山的一处秘密地点，该实验室的机密程度堪比CIA，仅少数几位谷歌高层掌握情况，在其中工作的人，都是谷歌从其他高科技公司、各大高校和科研院所挖过来的顶级专家。Google的X实验室在联合创始人布林的带领下开发过谷歌眼镜和无人驾驶汽车等项目。</p>
<p><strong>Design Sprint</strong></p>
<p>设计冲刺（Design Sprint）是近些年从敏捷开发（Agile）延展出来的一种产品创新方法。由于谷歌创业部门（Google Venture）和用户体验设计部门（Google UX）、研发部门的充分运用和大力推广，因此在业界它也常常被称为Google Design Sprint。 与更早一些诞生的设计思维（Design Thinking）对照，我们注意到二者都是面向产品和服务的快速创新、解决棘手问题的体系，它们拥有高度相似的运作流程，分享完全一致的、以用户为中心的创意理念。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总有一个理由去重构项目。也许你是一个的取得了一些成功，而你的工程师们吵着平台需要改进，要从头开始进行项目重构的CEO。也许你是主管或IT领导，在反复权衡重写老旧项目需要付出多大的成本。也许你是一个已经开始重写老项目的主程(我是疯了吗?)。无论如何，你可能已经知道重构老项目，
    
    </summary>
    
      <category term="译文" scheme="http://XibHe.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="译文" scheme="http://XibHe.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="重构" scheme="http://XibHe.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>组件化初探</title>
    <link href="http://XibHe.github.io/2018/07/18/ModuleFirstExplore/"/>
    <id>http://XibHe.github.io/2018/07/18/ModuleFirstExplore/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2019-11-23T15:42:20.064Z</updated>
    
    <content type="html"><![CDATA[<p>项目经过三年多的迭代，总共有三拨人接手，代码整体风格各异，迭代后的旧代码与新代码揉在一起，难解难分。各功能模块间相互依赖，头文件多次重复引用，编译一次大概花费5分钟。不得不进行代码组件化后重构。关于应用架构以及组件化的方案 <a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">casatwy</a> 已经说得很透彻了，在这里我就没有必要再班门弄斧了。这篇文章主要是记录自己项目组件化时如何拆分各个功能模块？抽离组件遇到了哪些问题？阶段性测试时遇到了哪些棘手的问题？因此，这篇文章的实践性较强，希望可以解决各位在组件化过程中遇到大部分问题。</p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>更新记录:</p>
<ul>
<li>2018 年 07 月，第一版。</li>
<li>2018 年 08 月，补充组件化架构图及一些说明。</li>
</ul>
<h2 id="现在项目中存在的问题"><a href="#现在项目中存在的问题" class="headerlink" title="现在项目中存在的问题"></a>现在项目中存在的问题</h2><p>代码不够整齐，目录结构混乱，分类不够明确，随着一次次的版本迭代，增加了不同的业务线，开发人员变动比较频繁，工程越来越臃肿。莫名其妙的继承关系，Base类，Expand类，Category混乱，三者之间存在重复的功能，这也为后面提到的在组件化过程中遇到一个棘手问题埋下了炸弹。</p>
<h2 id="期望达到的效果"><a href="#期望达到的效果" class="headerlink" title="期望达到的效果"></a>期望达到的效果</h2><ol>
<li>解除各个功能模块间的依赖；</li>
<li>可以单独引入并测试某一个功能组件；</li>
<li>功能与功能之间不再相互引用重复的未使用到的类；</li>
<li>将一个单一的工程项目，分解成各个独立的组件，然后按照某种方式，任意组合成一个拥有完整业务逻辑的工程。</li>
</ol>
<h2 id="组件划分粒度及其相互间的依赖"><a href="#组件划分粒度及其相互间的依赖" class="headerlink" title="组件划分粒度及其相互间的依赖"></a>组件划分粒度及其相互间的依赖</h2><p>组件化是为了解决项目中遇到的问题，不是为了组件化而组件化。模块的划分，以及模块的扩展性，可以增加新的模块，为将来业务的拓展留有余地。基础模块的划分很重要，其他的模块都是建立在基础模块之上的。</p>
<blockquote>
<p>兵马未动，基础组件先行。</p>
</blockquote>
<ul>
<li>基础组件(<strong>LZBasisComponents</strong>)：基本配置(常量，宏)，分类(各类系统类的拓展)，网络(AFN的封装)，工具类(loading，字符串操作，日期格式处理，文件操作等)</li>
<li>数据库组件(<strong>LZDataBaseComponents</strong>)：封装了各个功能模块的数据库增，删，改，查的基本操作，基于 <strong>FMDB</strong> 封装了基本的 <strong>SQLite</strong> 数据库操作；</li>
<li>功能组件(<strong>LZFunctionComponents</strong>)：主要用来存放一些自定义控件，eg.自定义弹出窗，错误信息提示View，自定义<strong>KeyBoardView</strong>，一些按钮和label；</li>
<li>登录组件(<strong>LZLoginComponents</strong>)：项目中通过登录操作初始化一些基本配置，配置账号体系下用户所能使用的权限。基于登录功能业务上衍生了广告页，热门活动宣传页，某个版本需要强制升级的弹出窗，以及用户协议等功能。</li>
<li>工具箱组件(<strong>LZToolsComponents</strong>)：项目中处理不同设备间数据同步的功能，页面展示的权限控制功能。</li>
</ul>
<blockquote>
<p>自顶向下设计，自底向上实现，先测量，后优化。— casatwy</p>
</blockquote>
<p>以上所列的 <em>6</em> 个组件可以统称为项目基础组件，自基础向上延伸到其他功能模块，为其他模块提供底层支持，同时，在生成私有库时，其他功能模块也要与之建立起依赖关系。</p>
<p>这里数据的持久化基于数据库组件，其中公共类的维护 (以数据库组件为例，每个人维护自己模块下的数据库操作类。eg.LZDatabaseHelper+PatientModel 即为，患者组件下对应的所有患者的数据库操作，处理后的数据以 PatientModel 为存储形式。)</p>
<blockquote>
<p>找到所有需要的模块， 把模块放在该放的地方。 — casatwy</p>
</blockquote>
<p>一个公共模块，如果多个模块都会用到，那么最好是将它抽成一个组件。eg. <strong>LZToolsComponents</strong> 组件中，就存放了一些工具类，这些工具类无法下沉到基础组件中。但其它模块却会用到。</p>
<blockquote>
<p>高内聚，低耦合。</p>
</blockquote>
<p>接下来按功能模块划分组件就比较直观了，比较典型的就是根据 <strong>TableBar</strong> 来划分，这里适用于大部分 App 的功能模块。以下这些功能组件的划分才是组件化划分的核心所在，也只有将功能组件独立出来，才能达到高内聚，低耦合的目的。</p>
<ul>
<li>工作台组件(<strong>LZWorkTableComponents</strong>)：主要处理项目中核心功能 — 开方，该模块下由三个小模块组成；</li>
<li>药房管理组件(<strong>LZPharmacyComponents</strong>)：涉及到药品库存管理的模块；</li>
<li>患者管理组件(<strong>LZPatientManageComponent</strong>)：管理患者个人就诊信息；</li>
<li>个人中心组件(<strong>LZMineComponents</strong>)：配置用户的个人信息，设置处方模板，管理诊所子账号，增值服务，账号设置，配置外接硬件(蓝牙打印机，激光打印机，扫码枪)等</li>
<li>所有H5功能组件(<strong>LZWebViewComponents</strong>)：该组件统一管理统计报表，专家咨询，知识课堂，活动商城等功能模块的 <strong>web</strong> 页面。</li>
</ul>
<p>以上各功能组件都分别对应各自的中间件，用来同其他功能组件进行通讯。如下，</p>
<ul>
<li>登录中间件(<strong>LZLoginComponents_Category</strong>)：主要用来处理登录组件(<strong>LZLoginComponents</strong>)与主工程之间的数据通讯；</li>
<li>工作台中间件(<strong>LZWebViewComponents_category</strong>)</li>
<li>药房管理中间件(<strong>LZPharmacyComponents_Category</strong>)</li>
<li>患者管理中间件(<strong>LZPatientManageComponent_Category</strong>)</li>
<li>个人中心中间件(<strong>LZMineComponents_Category</strong>)</li>
<li>H5交互中间件(<strong>LZWebViewComponents_category</strong>)</li>
</ul>
<p>项目最终的架构图如下，</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/moduleArchitecture.png" alt=""></p>
<p>其中，webView组件处理了三个H5功能模块的页面展示及数据交互，这里把它归为业务组件的范畴。</p>
<p>以上是基础组件和功能组件的划分，正是有了这些泾渭分明的区分，才能为组件化之间解耦提供基础的支持。</p>
<h2 id="MVC-VS-MVVM"><a href="#MVC-VS-MVVM" class="headerlink" title="MVC VS MVVM"></a>MVC VS MVVM</h2><p>对于组件化后继续使用 <strong>MVC</strong> 架构还是替换为 <strong>MVVM</strong>架构。这二者只是代码层次划分，主要是针对数据流动的方向而言。这里以解决问题为主，而不是生搬硬套架构。本片文章主要用来介绍组件化的实现流程，这里就不对架构做详细叙述了。但随着组件化的深入，这二者间终会有一个抉择，后续计划单独整理出二者之间关系的文章。</p>
<h2 id="CoCoaPods-私有库"><a href="#CoCoaPods-私有库" class="headerlink" title="CoCoaPods 私有库"></a>CoCoaPods 私有库</h2><p>通过 <strong>cocopods</strong> 把组件打包成单独的 <strong>私有pod</strong> 库来进行管理，这样就可以通过 <strong>podfile</strong> 文件，进行动态的增删和版本管理了。</p>
<h3 id="1-使用模板快速创建测试工程（组件所在的工程）"><a href="#1-使用模板快速创建测试工程（组件所在的工程）" class="headerlink" title="1.使用模板快速创建测试工程（组件所在的工程）"></a>1.使用模板快速创建测试工程（组件所在的工程）</h3><blockquote>
<p>$ pod lib create LZBasisComponents</p>
</blockquote>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/ModuleFirstExplore_cocoaPods01.jpeg" alt="创建模板工程"></p>
<p>按照提示，填写完以上信息后， Xcode 会自动打开创建的测试工程，在测试工程的文件夹下，可以看到的路径如下，</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/ModuleFirstExplore_cocoaPods02.png.jpeg" alt="模板工程文件路径"></p>
<p>其中，将抽离出的基础组件 <strong>LZBasisComponents</strong> 托至 <strong>Classes</strong> 文件夹下，此时，<strong>cd</strong> 到模板工程 <strong>Example</strong> 所在目录，执行</p>
<blockquote>
<p>$ pod install</p>
</blockquote>
<p>我们就可以在测试组件的模板工程中修改文件了。</p>
<h3 id="2-在-GitLab-上创建一个用来存放基础组件的仓库LZBasisComponents"><a href="#2-在-GitLab-上创建一个用来存放基础组件的仓库LZBasisComponents" class="headerlink" title="2.在 GitLab 上创建一个用来存放基础组件的仓库LZBasisComponents"></a>2.在 GitLab 上创建一个用来存放基础组件的仓库LZBasisComponents</h3><p>这里使用开源的 <strong>GitLab</strong> 作为代码托管的 <strong>git</strong> 服务器，安装完成后可以在上面新建组件。当然也可以付费使用基于 <strong>GitHub</strong> 托管，免费的有 <em><a href="https://gitee.com" target="_blank" rel="external">码云</a></em> 和 <em><a href="https://coding.net" target="_blank" rel="external">码市</a></em>。</p>
<h3 id="3-配置私有库的-podspec-文件"><a href="#3-配置私有库的-podspec-文件" class="headerlink" title="3.配置私有库的 .podspec 文件"></a>3.配置私有库的 .podspec 文件</h3><p>在上文中生成模板工程的同时，也会生成一个 <strong>. podspec</strong> 的文件。我们需要单独设置该文件，之所以配置 <strong>.podspec</strong> 文件，是为了将本地私有库与 <strong>GitLab</strong> 上远程私有库进行关联，多人开发时通过远程私有组件库进行代码的同步。远程索引库 <strong>. podspec</strong> 即，组件描述文件，里面描述了组件文件的源码地址，框架简介，私有库作者，版本号，资源文件路径等信息。我们使用 <strong>$ pod search</strong> 检索索引文件，找到 <strong>. podspec</strong> 中的源码地址，然后将项目down到本地。其主要配置如下，</p>
<pre><code class="js">s.name         = &quot;LZBasisComponents&quot;
s.version      = &quot;1.2.2.1&quot;
s.summary      = &quot;LZBasisComponents.&quot;

s.homepage     = &quot;http://192.168.11.11/CloudOfficeModulization/LZBasisComponents&quot;
s.license      = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; }
s.author       = &quot;xibHe&quot;
s.platform     = :ios, &quot;8.4&quot;

s.source       = { :git =&gt; &quot;http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git&quot;, :tag =&gt; s.version.to_s }
s.source_files  = &quot;LZBasisComponents/LZBasisComponents/Classes/**/*.{h,m}&quot;

s.resource_bundles = {
&#39;LZBasisComponents&#39; =&gt; [&#39;LZBasisComponents/LZBasisComponents/Assets/*.{png,plist}&#39;]
}

s.requires_arc = true

s.dependency &quot;Masonry&quot;, &#39;~&gt; 1.1.0&#39;
s.dependency &quot;YYKit&quot;, &#39;~&gt; 1.0.9&#39;
s.dependency &quot;ReactiveObjC&quot;
</code></pre>
<p>具体的配置如下：</p>
<ul>
<li><strong>s.homepage</strong> 组件在 <strong>GitLab</strong> 的主页面</li>
<li><strong>s.source</strong> 真实组件的地址，在 <strong>GitLab</strong> 中新建库时会生成该地址</li>
<li><strong>s.source_files</strong> 组件中对应目录下的文件夹</li>
<li><strong>s.resource_bundles</strong> 存放资源文件的类型</li>
<li><strong>s.dependency</strong> 依赖其他的框架或组件</li>
</ul>
<p>这里是组件中用到的主要的配置，还有其它的与私有 <strong>pod</strong> 相关的配置。</p>
<p>注意: 组件的依赖关系，各个组件中的 <strong>.podspec</strong> 文件中通过 <strong>s.dependency</strong> 设置了该组件与其他三方框架或者其他业务组件的依赖关系，这里各个组件前期可以暂时依赖其他业务组件，但后期当所有组件抽出后，需要解除与其他业务组件的依赖关系。即，将 <strong>s.dependency</strong> 下的依赖注释掉。</p>
<h3 id="4-将上面创建的模板工程，提交到-GitLab-上创建的远程代码仓库中"><a href="#4-将上面创建的模板工程，提交到-GitLab-上创建的远程代码仓库中" class="headerlink" title="4.将上面创建的模板工程，提交到 GitLab 上创建的远程代码仓库中"></a>4.将上面创建的模板工程，提交到 GitLab 上创建的远程代码仓库中</h3><p>主要是通过 <strong>git</strong> 命令上传，如下</p>
<h4 id="1-cd-到-模板工程所在的-Example-对应的私有库目录"><a href="#1-cd-到-模板工程所在的-Example-对应的私有库目录" class="headerlink" title="1. cd 到 模板工程所在的 Example 对应的私有库目录"></a>1. cd 到 模板工程所在的 <strong>Example</strong> 对应的私有库目录</h4><h4 id="2-可以先查看当前工程文件的状态，红色为未提交"><a href="#2-可以先查看当前工程文件的状态，红色为未提交" class="headerlink" title="2. 可以先查看当前工程文件的状态，红色为未提交"></a>2. 可以先查看当前工程文件的状态，红色为未提交</h4><blockquote>
<p>git status </p>
</blockquote>
<h4 id="3-提交到暂缓区"><a href="#3-提交到暂缓区" class="headerlink" title="3. 提交到暂缓区"></a>3. 提交到暂缓区</h4><blockquote>
<p>git add .</p>
</blockquote>
<h4 id="4-将本地库与远程代码仓库进行关联"><a href="#4-将本地库与远程代码仓库进行关联" class="headerlink" title="4. 将本地库与远程代码仓库进行关联"></a>4. 将本地库与远程代码仓库进行关联</h4><blockquote>
<p>git remote add origin <a href="http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git" target="_blank" rel="external">http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git</a></p>
</blockquote>
<h4 id="5-初始化提交"><a href="#5-初始化提交" class="headerlink" title="5. 初始化提交"></a>5. 初始化提交</h4><blockquote>
<p>git commit -m “Initial commit”</p>
</blockquote>
<h4 id="6-将本地分支的更新，推送到远程主机"><a href="#6-将本地分支的更新，推送到远程主机" class="headerlink" title="6. 将本地分支的更新，推送到远程主机"></a>6. 将本地分支的更新，推送到远程主机</h4><blockquote>
<p>git push -u origin master</p>
</blockquote>
<h4 id="7-给远程组件库打-tag"><a href="#7-给远程组件库打-tag" class="headerlink" title="7. 给远程组件库打 tag"></a>7. 给远程组件库打 tag</h4><blockquote>
<p>git tag -a 1.2.2.1 -m ‘v1.2.2.1’</p>
<p>git push origin master</p>
</blockquote>
<p>保持 <strong>s.version</strong> = “1.2.2.1” 的版本与远程私有库的 <strong>tag</strong> 一致。</p>
<h3 id="5-主工程中使用-CoCoaPods-导入私有组件库"><a href="#5-主工程中使用-CoCoaPods-导入私有组件库" class="headerlink" title="5.主工程中使用 CoCoaPods 导入私有组件库"></a>5.主工程中使用 CoCoaPods 导入私有组件库</h3><p>打开并编辑主工程中的 <strong>Podfile</strong> 文件，如下，</p>
<pre><code class="js">platform :ios, &#39;8.4&#39;

source &#39;http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git&#39;
source &#39;https://github.com/CocoaPods/Specs.git&#39;

workspace &#39;CloudOffice.xcworkspace&#39;
#use_frameworks!
inhibit_all_warnings!

def common_pods
    pod &#39;LZBasisComponents&#39;, :path =&gt; &#39;/Users/huahua/Documents/Module/LZBasisComponents&#39;

end

target  ‘CloudOffice’ do

    common_pods

end

target  ‘CloudOfficeTest’ do

    common_pods

end

target  ‘CloudOfficeTrial’ do

    common_pods

end
</code></pre>
<p>通过命令 <strong>pod repo</strong> 查看本地已存在的索引库，</p>
<pre><code class="js">14-cloudofficemodulization-cloudofficespec
- Type: git (master)
- URL:  http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git
- Path: /Users/huahua/.cocoapods/repos/14-cloudofficemodulization-cloudofficespec

master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/huahua/.cocoapods/repos/master
</code></pre>
<p><strong>GitLab</strong> 中远程私有库的地址：</p>
<pre><code class="js">source &#39;http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git&#39;
</code></pre>
<p>公有库的地址：</p>
<pre><code class="js">source &#39;https://github.com/CocoaPods/Specs.git&#39;
</code></pre>
<p>cd 到主工程 <strong>Podfile</strong> 文件所在目录，执行 <strong>pod install</strong> 命令，再次打开项目就可以在 <strong>Pods</strong> 文件夹下的 <strong>Development Pods</strong> 文件夹中找到 <strong>LZBasisComponents</strong> 组件。</p>
<p>注意：pod ‘LZBasisComponents’, :path =&gt;’/Users/huahua/Documents/Module/LZBasisComponents’ 对应的路径可以是存放本地私有库(已update远程私有库)的路径，也可以是 <strong>步骤4</strong> 中对应的远程私有库，可以通过通过 tag 来导入不同的私有组件库的版本，如下：</p>
<pre><code class="js">pod &#39;LZBasisComponents&#39;, &#39;~&gt; 1.2.2.1&#39;
</code></pre>
<p>也可以通过 <strong>SourceTree</strong> 或者 <strong>GitHub Desktop</strong> 等拥有可视化界面的项目版本控制软件，进行 <strong>git</strong> 项目私有库的管理。</p>
<h2 id="组件之间及各组件与主工程间通讯-中间件"><a href="#组件之间及各组件与主工程间通讯-中间件" class="headerlink" title="组件之间及各组件与主工程间通讯(中间件)"></a>组件之间及各组件与主工程间通讯(中间件)</h2><p>目前市面上有两种组件间的通讯方式：</p>
<ol>
<li>利用 <strong>url-scheme</strong> 方案</li>
<li>利用 <strong>runtime</strong> 实现的 <strong>target-action</strong> 方法</li>
</ol>
<p>两种方式都对应一些开源库，如下</p>
<p><strong>URL-Scheme库：</strong></p>
<ol>
<li><a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="external">JLRoutes</a></li>
<li><a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="external">routable-ios</a></li>
<li><a href="https://github.com/lightory/HHRouter" target="_blank" rel="external">HHRouter</a></li>
<li><a href="https://github.com/mogujie/MGJRouter" target="_blank" rel="external">MGJRouter</a></li>
</ol>
<p><strong>Target-Action库：</strong></p>
<ol>
<li><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a></li>
</ol>
<p>采用 <strong>url-scheme</strong> 方案，要本地调用和远程调用之间如何相互调用？提供给 <strong>url</strong> 什么样的参数？如何处理非常规对象与本地组件间的调度？</p>
<blockquote>
<p>在iOS领域里，一定是组件化的中间件为openUrl提供服务，而不是openUrl方式为组件化提供服务。 — casatwy</p>
<p>URL注册对于实施组件化方案是完全不必要的，且通过URL注册的方式形成的组件化方案，拓展性和可维护性都会被打折。 — casatwy</p>
</blockquote>
<p>采用 <strong>runtime</strong> 实现的 <strong>target-action</strong> 方法</p>
<blockquote>
<p>注册 <strong>URL</strong> 的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用 <strong>runtime</strong> 就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。<strong>runtime</strong> 由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。</p>
<p>由于通过 <strong>runtime</strong> 做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。— casatwy</p>
</blockquote>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/ModuleFirstExplore_target-action.png" alt="target-action"></p>
<p>如图，<strong>target-action</strong> 模式，即，目标-行为，行为即要调用的方法，目标即消息的接收对象（Objective-C 语言使用消息机制，类似但不同于方法调用）。整个过程为：用户点击按钮，触发某事件发生，该消息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对象，但通常为控制器（<strong>Controller</strong>）。</p>
<p><strong>target-action</strong> 的代码实现逻辑：</p>
<blockquote>
<ol>
<li>运行时，runtime是一套底层的C语言api，可以通过runtime获取类的私有变量；动态增加类、成员变量和方法；动态修改类、成员变量和方法；对换两个方法的实现（<strong>Swizzle</strong>）</li>
<li>NSInvocation 和 performSelector：withObject：，直接调用某个对象的消息</li>
<li>调用methodSignatureForSelector：方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取到，则返回非nil，创建一个NSInvocation并传给forwardInvocation:</li>
<li>调用编译器指令，返回一个给定类型编码为一种内部表示的字符串</li>
<li>提供外部模块调用的方法。</li>
</ol>
</blockquote>
<p>组件之间的交互，通过 <strong>Action</strong> 暴露可调用接口，所有组件都通过组件自带的<strong>Target-Action</strong> 来响应，也就是说，模块与模块之间的接口被固化在了 <strong>Target-Action</strong> 这一层，避免了实施组件化的改造过程中，对业务层的侵入，同时也提高了组件化接口的可维护性。 </p>
<p>基于以上原因，这里我推荐 <strong>Target-Action</strong> 方案。具体操作流程如下，</p>
<h3 id="新增基于-CTMediator-的组件-LZMediator"><a href="#新增基于-CTMediator-的组件-LZMediator" class="headerlink" title="新增基于 CTMediator 的组件 LZMediator"></a>新增基于 CTMediator 的组件 LZMediator</h3><p>基于 <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a> 新建用于传递组件讯息的组件 <strong>LZMediator</strong>，该组件参考 <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a> 中的 <strong>CTMediator</strong> 类，做了一些简化处理。具体创建操作参照上文中使用 <strong>CoCoaPods</strong> 建立私有库，这里就不再赘述了。</p>
<h3 id="新建与其它组件通讯的中间件"><a href="#新建与其它组件通讯的中间件" class="headerlink" title="新建与其它组件通讯的中间件"></a>新建与其它组件通讯的中间件</h3><p>这里的所说的中间件也是以 <strong>pod</strong> 私有库的形式存在于项目中，其仍是代表不同功能模块的组件。以工作台组件（<strong>LZWorkTableComponents</strong>）为例，其它组件若想调用工作台组件中的某个控制器时，不能直接调用，而是需要通过工作台中间件（<strong>LZWorkTableComponents_Category</strong>）暴露的接口调用。同上文中使用<strong>CoCoaPods</strong> 建立私有库一样，先生成模板工程，然后上传到 <strong>GitLab</strong> 远程代码厂库中。唯一需要注意的是：需要在工作台中间件的 <strong>.podspec</strong> 文件中，增加对 <strong>LZMediator</strong> 组件的依赖，如下：</p>
<pre><code class="js">s.dependency &quot;LZMediator&quot;
</code></pre>
<p>通过这种依赖关系，将 <strong>LZMediator</strong> 引入到工程中。</p>
<h3 id="在中间件中新增用于通讯的-LZMediator-类别"><a href="#在中间件中新增用于通讯的-LZMediator-类别" class="headerlink" title="在中间件中新增用于通讯的 LZMediator 类别"></a>在中间件中新增用于通讯的 LZMediator 类别</h3><p>在上面新建的工作台中间件（<strong>LZWorkTableComponents_Category</strong>）中新建基于 <strong>LZMediator</strong> 的类别，注意统一类别的名称，以工作台中间件为例，最终生成的类名为：<strong>LZMediator+LZWorkTableComponents.h</strong> 和 <strong>LZMediator+LZWorkTableComponents.m</strong> 接下来就是按照基于 <strong>Mediator</strong> 的一套逻辑，通过实现 <strong>target-action</strong> 的方法来进行不同组件间的通讯。例如，某个组件需要调用工作台组件中的某个控制器时，</p>
<p><strong>LZMediator+LZWorkTableComponents.h</strong> 中声明中间件调用的返回工作台组件中某个控制器的实例方法：</p>
<pre><code class="objectivec">#pragma mark - 患者管理组件调用
/**
 看病开方详情页面
 @return 返回实例
 */
- (UIViewController *)LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic:(NSDictionary *)params;
</code></pre>
<p><strong>LZMediator+LZWorkTableComponents.m</strong> 中实现该方法：</p>
<pre><code class="objectivec">#pragma mark - 统一前缀
NSString *const kLZMediatorTarget_LZWorkTableComponents = @&quot;LZWorkTableComponents&quot;;

#pragma mark - 方法名称
NSString *const kLZMediatorAction_newDoctorPrescribingViewController = @&quot;newDoctorPrescribingViewController&quot;;  // 看病开方详情页面

- (UIViewController *)LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic:(NSDictionary *)params
{
    UIViewController *viewController = [self performTarget:kLZMediatorTarget_LZWorkTableComponents action:kLZMediatorAction_newDoctorPrescribingViewController params:params shouldCacheTarget:NO];
    if ([viewController isKindOfClass:[UIViewController class]]) {
        return viewController;
    }
    return [UIViewController new];
}
</code></pre>
<p>这里需要注意方法中传递的参数 <strong>kLZMediatorTarget_LZWorkTableComponents</strong> 和 <strong>kLZMediatorAction_newDoctorPrescribingViewController</strong> 分别对应工作台组件中 <strong>target-action</strong> 所在的模块 (也就是提供服务的模块，这也是单独的repo，但无需被其他人依赖，其他人通过category调用这里的功能），这两个参数，前者对应的是 <strong>target-action</strong> 所在组件中的以 <strong>Target_</strong> 为前缀的类，后者对应该类里的具体的以 <strong>Action_</strong> 为前缀声明的某个方法。前面所说的利用 <strong>runtime</strong> 实现的 <strong>target-action</strong> 方法，指的正是这个地方。</p>
<p>注意: 这两个参数值，一定要与工作台组件中 <strong>Target</strong> 目录下的类名相一致!!! 切记！ 切记！ 切记！ </p>
<h3 id="在-target-action-所在的组件中增加提供服务的类"><a href="#在-target-action-所在的组件中增加提供服务的类" class="headerlink" title="在 target-action 所在的组件中增加提供服务的类"></a>在 target-action 所在的组件中增加提供服务的类</h3><p>在工作台组件（<strong>LZWorkTableComponents</strong>）中 <strong>Target</strong> 目录下新建名称为： <strong>Target_LZWorkTableComponents</strong> 继承于 <strong>NSObject</strong> 的类，这个类的命名规则与上面说的 <strong>kLZMediatorTarget_LZWorkTableComponents</strong> 参数相一致，然后新增方法，方法名以前缀 <strong>Action_</strong> 开头，同样需要与上面说的<strong>kLZMediatorAction_newDoctorPrescribingViewController</strong> 参数相一致。如下：</p>
<p><strong>Target_LZWorkTableComponents.h</strong> 中声明中间件调用的返回工作台组件中某个控制器的实例方法：</p>
<pre><code class="objectivec">#pragma mark - 患者管理组件调用
/**
 返回LZNewDoctorPrescribingViewController实例
 */
- (UIViewController *)Action_newDoctorPrescribingViewController:(NSDictionary *)param;
</code></pre>
<p><strong>Target_LZWorkTableComponents.m</strong> 中实现该方法：</p>
<pre><code class="objectivec">#import &lt;LZDataBaseComponents/PationModel.h&gt;
#import &quot;LZNewDoctorPrescribingViewController.h&quot;

/**
 返回LZNewDoctorPrescribingViewController实例

 @param param 患者dictionary
 @return LZNewDoctorPrescribingViewController实例
 */
- (UIViewController *)Action_newDoctorPrescribingViewController:(NSDictionary *)param
{
    PationModel *pationModel = [[PationModel alloc] init];
    [pationModel setValuesForKeysWithDictionary:param];

    LZNewDoctorPrescribingViewController *newDoctorPrescribinVC = [[LZNewDoctorPrescribingViewController alloc] init];
    newDoctorPrescribinVC.model = pationModel;

    return newDoctorPrescribinVC;
}
</code></pre>
<p>这里 <strong>PationModel</strong> 为数据库组件中的类，需要注意一下这里使用尖括号引入的头文件，<strong>LZNewDoctorPrescribingViewController</strong> 控制器为工作台组件中的类。</p>
<h3 id="在其它组件中调用中间件的方法进行通讯"><a href="#在其它组件中调用中间件的方法进行通讯" class="headerlink" title="在其它组件中调用中间件的方法进行通讯"></a>在其它组件中调用中间件的方法进行通讯</h3><p>这里仍以工作台组件（<strong>LZWorkTableComponents</strong>）为例，比如，在患者组件中想跳转至工作台组件中的看病开方详情页（<strong>LZNewDoctorPrescribingViewController</strong>），需要通过上面的工作台中间件（<strong>LZWorkTableComponents_Category</strong>）进行通讯，而不是直接导入 <strong>#import “LZNewDoctorPrescribingViewController.h”</strong> 头文件调用。具体事例，如下：</p>
<p>在患者管理组件中，</p>
<pre><code class="objectivec">#import &lt;LZWorkTableComponents_Category/LZMediator+LZWorkTableComponents.h&gt;

NSDictionary *pationModelDic = model.mj_keyValues;
UIViewController *newDoctorVC = [[LZMediator sharedInstance]  LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic :pationModelDic];
[weakSelf presentViewController: newDoctorVC animated:YES completion:nil];
</code></pre>
<p>这里通过一个 <strong>LZMediator</strong> 的单例来调用工作台中间件（<strong>LZWorkTableComponents_Category</strong>）中 <strong>LZMediator</strong> 的类别(<strong>LZMediator+LZWorkTableComponents</strong>) 中的方法，获得 <strong>view controller</strong> 之后，在这种场景下，到底 <strong>push</strong> 还是 <strong>present</strong> ，其实是要由使用者决定的，<strong>mediator</strong> 只要给出 <strong>view controller</strong> 的实例就好了。</p>
<h2 id="原工程中资源文件的处理"><a href="#原工程中资源文件的处理" class="headerlink" title="原工程中资源文件的处理"></a>原工程中资源文件的处理</h2><p>这里所说的资源文件指的是项目中的图片，现在主工程中的 <strong>Assets</strong> 存放全部的资源文件，需要将其移动到各个组件中去。在上文新建模板工程时，对应文件夹下也会生成一个 <strong>Assets</strong> 文件夹，这个文件夹就是用来存放组件中使用到的图片文件的。 针对这个文件夹中图片资源的存放和使用，有两种方式：</p>
<ol>
<li>直接将图片 <strong>copy</strong> 到模板工程中 <strong>Assets</strong> 文件夹下，包括 <strong>@2x</strong>, <strong>@3x</strong> 图片；</li>
<li>在工程中组件下 <strong>Resources</strong> 目录下，新建 <strong>Assets.xcassets</strong> 文件，直接将图片拖放到 <strong>Assets</strong> 文件中，与主工程中 <strong>Assets</strong> 文件的用法一致。</li>
</ol>
<p>针对以上两种存放图片的方式，在文件中读取图片的方式也完全不同。方式一：</p>
<pre><code class="js">s.resource_bundles = {
&#39;LZBasisComponents&#39; =&gt; [&#39;LZBasisComponents/LZBasisComponents/Assets/*.{png,plist}&#39;]
}
</code></pre>
<p>需要在对应组件的 <strong>.podspec</strong> 文件中设置访问图片资源的路径及资源文件类型，然后在项目中导入所要访问的图片，最后访问图片，如下：</p>
<pre><code class="objectivec">[UIImage imageWithName:@&quot;xtsz_N&quot; bundleName:@&quot;LZBasisComponents&quot;];
</code></pre>
<p>访问图片时需要在方法 <strong>bundleName:</strong> 后面加上图片所在的组件名称。可以写一个 <strong>UIImage</strong> 的类别统一加载组件图片资源，</p>
<pre><code class="objectivec">@interface UIImage (Image)

//组件之间加载图片资源
+ (UIImage *)imageWithName:(NSString *)imageName forClass:(Class)sourceClass;
+ (UIImage *)imageWithName:(NSString *)imageName bundleName:(NSString *)bundleName;
+ (UIImage *)imageWithName:(NSString *)imageName bundleName:(NSString *)bundleName forClass:(Class)sourceClass;
</code></pre>
<p>方式二：相比方式一，更加简单，管理图片也更加直观。可以直接使用原来的方法<strong>imageWithName</strong> 来加载图片。但这里需要注意这个存放资源图片文件在组件中对应的路径并不在模板工程 <strong>Assets</strong> 路径下。</p>
<h2 id="受工期影响"><a href="#受工期影响" class="headerlink" title="受工期影响"></a>受工期影响</h2><ol>
<li>抽取组件前未将项目中冗余的类删除，导致这些类最后被抽到组件中；</li>
<li>在抽取组件时，版本仍在继续迭代，这就造成组件抽取完成后，需要再花时间合并新代码到组件中；</li>
<li>前期为了快速分离功能组件，往往将与该组件关联的其它功能模块的代码也抽到组件中；</li>
</ol>
<p>出现 <strong>2</strong> 中的情况，就需要记录一下新版本迭代修改了组件中的哪些类，还要记录提测后修改 <strong>QA</strong> 提出的 bug 时修改了哪些类，最后，再对比 <strong>Git</strong> 和 <strong>svn</strong> 的提交日志，查看修改了哪些类。</p>
<h2 id="组件化过程中遇到的问题及解决方式"><a href="#组件化过程中遇到的问题及解决方式" class="headerlink" title="组件化过程中遇到的问题及解决方式"></a>组件化过程中遇到的问题及解决方式</h2><p>抽离业务组件，一般分为四步，这里以抽离患者管理组件为例：</p>
<ol>
<li>将患者管理模块所有代码 <strong>copy</strong> 到新建的患者管理模板工程中（注意要将复制的代码放到 <strong>ReplaceMe.m</strong> 所在目录下）；</li>
<li>梳理患者管理中与主工程有交互的功能类，明确使用了哪些三方库和自定义控件，剔除未使用到的类，整理工程目录结构（这一步主要是整理现有的代码逻辑，结构，去除冗余的类）；</li>
<li>将模板工程中患者管理代码中涉及数据库操作，公用模块，全局自定义控件等其它组件的功能抽出来。那些暂时无法划分到其它组件中的类，暂时 <strong>copy</strong> 一份放到 <strong>Redundancy</strong> 文件夹下。患者管理组件只能导入其它组件并引用后，才能使用。不能再以直接引入主工程的头文件的方式调用类了（这一步主要是从组件角度斩断组件与主工程单方面的关联）；</li>
<li>将患者管理模块所在的模板工程上传至 <strong>GitLab</strong>，然后在已集成了基础组件的壳工程中引入该组件并调试。</li>
</ol>
<p>第 <strong>4</strong> 步建立在壳工程之上，这里所谓的壳工程是指集成了主工程 <strong>AppDelegate</strong> 中初始化功能和基础组件，可以进行登录操作，同步用户的数据。有了数据就可以进行页面展示，就能进一步测试组件功能是否完整。</p>
<h3 id="1-duplicate-symbols-for-architecture-arm64"><a href="#1-duplicate-symbols-for-architecture-arm64" class="headerlink" title="1. duplicate symbols for architecture arm64"></a>1. duplicate symbols for architecture arm64</h3><pre><code class="objectivec">duplicate symbol_LZKanBingHomeViewController._closeImageV in:
    /Users/huahua/Library/Developer/Xcode/DerivedData/CloudOffice-enrpnhjeeqovpuffsdjmigxqovpi/Build/Intermediates.noindex/CloudOffice.build/Debug-iphoneos/CloudOfficeTest.build/Objects-normal/arm64/LZKanBingHomeViewController.o
    /Users/huahua/Library/Developer/Xcode/DerivedData/CloudOffice-enrpnhjeeqovpuffsdjmigxqovpi/Build/Products/Debug-iphoneos/LZWorkTableComponents/libLZWorkTableComponents.a(LZKanBingHomeViewController.o)
ld: 31 duplicate symbols for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<p>根据错误提示，删除主工程中的重复类文件，因为这些类已经抽离到组件中了。这也是集成组件后联调出现最对，最常见的一种错误。</p>
<h3 id="2-OBJC-CLASS-LZKanBingHomeViewController-referenced-from-objc-class-ref-in-libLZWorkTableComponents-a-LZWorkTableMangerController-o-ld-symbol-s-not-found-for-architecture-arm64-clang-error-linker-command-failed-with-exit-code-1-use-v-to-see-invocation"><a href="#2-OBJC-CLASS-LZKanBingHomeViewController-referenced-from-objc-class-ref-in-libLZWorkTableComponents-a-LZWorkTableMangerController-o-ld-symbol-s-not-found-for-architecture-arm64-clang-error-linker-command-failed-with-exit-code-1-use-v-to-see-invocation" class="headerlink" title="2. _OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o) ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation)"></a>2. _OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o) ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation)</h3><pre><code class="objectivec">objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o)

ld: symbol(s) not found for architecture arm64
</code></pre>
<p>这个错误是由于向工程中某个组件下导入类时，未将导入类与与组件进行关联导致。根据错误提示 <strong>OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a</strong> 可以知道是工作台组件（<strong>LZWorkTableComponents</strong>）中的类（<strong>LZKanBingHomeViewController</strong>）未与组件建立关联。解决方式：在工程组件中选中 <strong>LZKanBingHomeViewController.m</strong> 切换到该类的 <strong>“Show the File inspector”</strong> 设置项中，检查文件的设置项。如图，</p>
<p> <img src="https://xibhe.oss-cn-beijing.aliyuncs.com/ModuleFirstExplore_inspector.png" alt="inspector"></p>
<p>设置 <strong>“Target Membership”</strong> 下 <strong>“LZWorkTableComponents”</strong> 为选中状态，重新编译，即可。 </p>
<h3 id="3-Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’"><a href="#3-Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’" class="headerlink" title="3. Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’"></a>3. Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’</h3><p>头文件重复引用的问题，可以在各个基础组件中新建 <strong>.h</strong> 头文件，用于存放其他类会用到类的头文件，使用时直接导入。例如：</p>
<pre><code class="objectivec">#import &lt;LZBasisComponents/LZBasisComponents.h&gt;
#import &lt;LZDataBaseComponents/LZDataBaseComponents.h&gt;
</code></pre>
<h3 id="4-GlobalMethod-showName-”请输入正确手机号码”-inView-self-headView-dianhuaView-不执行"><a href="#4-GlobalMethod-showName-”请输入正确手机号码”-inView-self-headView-dianhuaView-不执行" class="headerlink" title="4. [GlobalMethod showName:@”请输入正确手机号码” inView:self.headView.dianhuaView] 不执行"></a>4. [GlobalMethod showName:@”请输入正确手机号码” inView:self.headView.dianhuaView] 不执行</h3><p>这里 <strong>LZBasisComponents</strong> 中已经通过 <strong>GlobalMethod</strong> 类引入了<strong>MBProgressHUD</strong>，若在组件外重复引入新的 <strong>MBProgressHUD</strong> 会导致该代码不执行。</p>
<h3 id="5-暂时注释掉组件中跳转至其它组件控制器的方法"><a href="#5-暂时注释掉组件中跳转至其它组件控制器的方法" class="headerlink" title="5. 暂时注释掉组件中跳转至其它组件控制器的方法"></a>5. 暂时注释掉组件中跳转至其它组件控制器的方法</h3><p>由于组件间不能直接进行通讯，当用于处理组件间交互的中间件没有完成时，为了编译成功，可以先注释掉跳转到其它组件控制器的代码。</p>
<h3 id="6-Reference-to-‘LZHttpRequestPost’-is-ambiguous"><a href="#6-Reference-to-‘LZHttpRequestPost’-is-ambiguous" class="headerlink" title="6. Reference to ‘LZHttpRequestPost’ is ambiguous"></a>6. Reference to ‘LZHttpRequestPost’ is ambiguous</h3><pre><code class="objectivec">+ (void)hasNewRemoteConsulationWithParam:(NSDictionary *)param
  success:(void(^)(LZHttpResponseModel *responseModel))success
  failure:(void(^)(NSError *error))failure{

[self baseRequestWithParam:param path:[LZHttpDomainManage sharedInstance].YCHZ method:LZHttpRequestPost success:success failure:failure];
}
</code></pre>
<p>很奇怪的一个问题，项目中顶一个一个网络请求类型的枚举 — <strong>LZHttpRequestType</strong>，项目中很多用到 <strong>LZHttpRequestPost</strong> 这个枚举类型就会报这个错误，但只要将该参数换成枚举所对应的整数值就行。暂时先这样解决，后来再看这个错误，觉得是头文件重复引用造成的，之前的老项目中有有一个叫 <strong>Foundation.h</strong> 的头文件，里面引用的是一些基本的配置类，工具类，还有一个很奇怪的引用，每个项目开发者都会在这个头文件里引入自己所编写功能的头文件。例如，</p>
<pre><code class="objectivec">/*************此.h 文件是用来导入公用的头文件的***************/
#import &quot;GlobalMacro.h&quot;
#import &quot;URLMacro.h&quot;
#import &quot;GlobalMethod.h&quot;
#import &quot;PlaceholderTextView.h&quot;
#import &quot;UIImageView+WebCache.h&quot;

#import &quot;UIView+Frame.h&quot;
#import &quot;MJRefresh.h&quot;
#import &quot;HLNavigationController.h&quot;
#import &lt;AdSupport/ASIdentifierManager.h&gt;
#import &quot;NSString+MD5.h&quot;
#import &quot;Masonry.h&quot;
#import &quot;UILabel+LZLabel.h&quot;
#import &quot;NSArray+LZAddition.h&quot;

//多人开发，避免冲突
#import &quot;LWB.h&quot;
#import &quot;DLN.h&quot;
#import &quot;LYY.h&quot;
#import &quot;XXL.h&quot;
</code></pre>
<p>注释是为了避免多人开发的冲突，在这些每个人姓名首字母缩写的头文件中，引入的是这个人所开发功能类的头文件，就这样一层套一层。在组件中如果引用了这个<strong>Foundation.h</strong> 头文件，很大几率会造成重复重复引用。而且还有一点需要注意：组件中若要引入其它组件类的头文件，最好以尖括号引入。例如，引入基本组件中的某个类，</p>
<pre><code class="objectivec">#import &lt;LZBasisComponents/LZHttpDomainManage.h&gt;
</code></pre>
<p>一些基本的配置类的引入，工具类的引入，则可以用包含这些类的所有头文件的一个总的 <strong>.h</strong> 头文件的形式引入，</p>
<pre><code class="objectivec">#import &lt;LZBasisComponents/LZBasisComponents.h&gt;
</code></pre>
<p>就这样一步步的将那些多余的头文件和姓名首字母缩写的头文件从 <strong>Foundation.h</strong> 中移除，去除重复引入的头文件。</p>
<h3 id="7-iOS-9-3-5-系统下，页面布局错乱的问题"><a href="#7-iOS-9-3-5-系统下，页面布局错乱的问题" class="headerlink" title="7. iOS 9.3.5 系统下，页面布局错乱的问题"></a>7. iOS 9.3.5 系统下，页面布局错乱的问题</h3><p>组件拆分中遇到的一个很棘手的问题，在 <strong>iOS 9.3.5</strong> 的 <strong>ipad</strong> 上，左侧切换视图的选项显示不出来，同时，右侧页面布局错乱无法点击。运行项目， 点击<strong>Debug View Hierarchy</strong> 查看视图层级，发现左侧菜单所有切换按钮的布局都乱掉了，挤在一起了。主视图控制器中的 <strong>MainView</strong> 的 <strong>Frame</strong> 获取的一直都是错的，工程中 <strong>Frame</strong> 坐标的获取都是通过 <strong>UIView</strong> 的类别计算获取的，如果不通过类别获取是可以得到正确的值的。但即使将主视图和菜单中所有获取坐标的方式都通过系统方法获取，还是加载不出完整的视图。</p>
<p>最后搜索项目中所有与计算视图布局有关的类，发现了真相。主工程中有很多计算坐标的类别，这些类别重复定义了视图的坐标，需要移除未使用的类别。同时，将组件中计算坐标的 <strong>UIView+Frame</strong> 类移至主工程中，从 <strong>podFile</strong> 中移除 <strong>HandyFrame</strong>, 移除主工程中未使用到的 <strong>UIView+AutoLayout</strong>， <strong>UIView+TXFrame</strong> 等计算页面布局的类别。 </p>
<h3 id="8-Include-of-non-modular-header-inside-framework-module-‘LZBasisComponents-LZHttpClient’-‘-Users-zyjk-imac-penghe-Library-Developer-Xcode-DerivedData-CloudOffice-ffqipmpyrmrjqmevvpibbskoycre-Build-Products-Debug-iphoneos-AFNetworking-AFNetworking-framework-Headers-AFURLRequestSerialization-h’"><a href="#8-Include-of-non-modular-header-inside-framework-module-‘LZBasisComponents-LZHttpClient’-‘-Users-zyjk-imac-penghe-Library-Developer-Xcode-DerivedData-CloudOffice-ffqipmpyrmrjqmevvpibbskoycre-Build-Products-Debug-iphoneos-AFNetworking-AFNetworking-framework-Headers-AFURLRequestSerialization-h’" class="headerlink" title="8. Include of non-modular header inside framework module ‘LZBasisComponents.LZHttpClient’: ‘/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFURLRequestSerialization.h’"></a>8. Include of non-modular header inside framework module ‘LZBasisComponents.LZHttpClient’: ‘/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFURLRequestSerialization.h’</h3><pre><code class="objectivec">Include of non-modular header inside framework module &#39;LZBasisComponents.AFHTTPRequestOperationManager_Synchronous&#39;: &#39;/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFHTTPRequestOperationManager.h&#39;
</code></pre>
<p>AFN中头文件引用的包含了同一个头文件，删除报错类 <strong>.h</strong> 中一些重复的引用，改为 <strong>&lt; &gt;</strong> 引入。</p>
<pre><code class="objectivec">AFHTTPRequestOperationManager+Synchronous.h 中引入 #import &lt;AFNetworking/AFHTTPRequestOperationManager.h&gt;
AFHTTPRequestOperationManager+Synchronous.m 中引入 #import &lt;AFNetworking/AFNetworking.h&gt;
LZHttpClient.h 中引入 #import &lt;AFNetworking/AFURLRequestSerialization.h&gt;
LZHttpClient.m 中引入 #import &lt;AFNetworking/AFNetworking.h&gt;
</code></pre>
<h3 id="9-组件间的依赖关系"><a href="#9-组件间的依赖关系" class="headerlink" title="9. 组件间的依赖关系"></a>9. 组件间的依赖关系</h3><p>组件间的依赖关系，若两个组件间存在依赖，则依赖于某个组件的另一个组件可以直接引用所依赖组件中类的头文件，不需要加 <strong>&lt; &gt;</strong> 导入（但为了明确组件中引用类的来源，同时避免头文件的重复引用，建议以 <strong>&lt; &gt;</strong> 的方式引入头文件）。同理，若两个组件间不存在依赖关系，即使，使用了 <strong>&lt; &gt;</strong> 引用也无法引入该组件的任何文件。</p>
<p>这里需要明确项目中哪些功能模块为核心模块，哪些模块依存于核心模块。以我们项目为例，工作台组件（<strong>LZWorkTableComponents</strong>）为核心组件，在组件化初期可以以工作台组件为主，在其 <strong>.podspec</strong> 文件中依赖于其它功能组件，而不是中间件，</p>
<pre><code class="js"> s.dependency &quot;LZLoginComponents&quot;
 s.dependency &quot;LZPatientManageComponent&quot;
 s.dependency &quot;LZPharmacyComponents&quot;
 s.dependency &quot;LZMineComponents&quot;
</code></pre>
<p>此时需要注意：这种依赖关系是单向的。即，工作台组件依赖于其它功能组件，而其他功能组件不能依赖于工作台组件。这样也是为了避免组件间形成相互依赖的循环，为后面解除组件间依赖提供便利。</p>
<h3 id="10-如何将两个组件之间通过代理交互替换为通过中间件交互"><a href="#10-如何将两个组件之间通过代理交互替换为通过中间件交互" class="headerlink" title="10. 如何将两个组件之间通过代理交互替换为通过中间件交互"></a>10. 如何将两个组件之间通过代理交互替换为通过中间件交互</h3><p>项目中经常会用到代理处理两个不同功能间页面的跳转。在组件化过程中，也经常会遇到类似于 <strong>A组件</strong> 中的某个类需要调用 <strong>B组件</strong> 中的某个类，以完成从 <strong>A组件</strong> <strong>push 或者 present</strong> 或者 <strong>addSubview</strong> 到 <strong>B组件</strong> 控制器的逻辑。</p>
<p>这里普通的组件间通讯可以通过上文所说的 <strong>中间件</strong> ，复杂一些的，<strong>如将之前的代理替换为中间件</strong>需要做一些其他的处理，如下：</p>
<p>例如，工作台组件中 <strong>患者健康档案</strong>，需要调用患者管理组件中的 <strong>病例</strong> 模块，需要在患者管理中间件（<strong>LZPatientManageComponent_Category</strong>）中定义回调的方法，如下：</p>
<p>在类 <strong>LZMediator+LZPatientManageComponent</strong> 中，</p>
<pre><code class="objectivec">#pragma mark - 统一前缀
NSString *const kLZMediatorTarget_LZPatientManageComponent = @&quot;LZPatientManageComponent&quot;;

#pragma mark - 方法名称
NSString *const kLZMediatorAction_LuHealthRecordsView = @&quot;LuHealthRecordsView&quot;;        // 患者健康档案view

#pragma mark - block回调
NSString * const LZPatientManageComponent_HealthRecordsViewBlock = @&quot;HealthRecordsViewBlock&quot;;    // 患者健康档案block回调

@implementation LZMediator (LZPatientManageComponent)

/**
 创建患者健康档案实例

 @param pationModelDic 患者model字典
 @param prescriptionFlag 处方类型
 @param recoresViewBlock 患者健康档案的block回调
 @return 患者健康档案实例
 */
- (UIView *)LZPatientManageComponent_LuHealthRecordsView:(NSDictionary *)pationModelDic withPrescriptionFlag:(NSString *)prescriptionFlag withHealthRecordsViewBlock:(void (^)(NSDictionary *dic))recoresViewBlock
{
    NSMutableDictionary *params = [NSMutableDictionary dictionary];
    if (recoresViewBlock) {
        params[LZPatientManageComponent_HealthRecordsViewBlock] = recoresViewBlock;
        params[@&quot;pationModelDic&quot;] = pationModelDic;
        params[@&quot;prescriptionFlag&quot;] = prescriptionFlag;
    }

    UIView *healthRecordsView = [self performTarget:kLZMediatorTarget_LZPatientManageComponent action:kLZMediatorAction_LuHealthRecordsView params:params shouldCacheTarget:NO];
    if ([healthRecordsView isKindOfClass:[UIView class]]) {
        return healthRecordsView;
    }
    return [UIView new];
}

@end
</code></pre>
<p>这里主要将代理替换为 <strong>Block</strong> 以实现方法的回调。主要传递了三个参数，</p>
<ul>
<li><strong>pationModelDic</strong>，由于病例视图展示的数据是以 <strong>model</strong> 形式传递的，而中间件只能接收字典类型的参数，所以在调用方法前需要将 <strong>model</strong> 转化为 <strong>NSDictionary</strong></li>
<li><strong>prescriptionFlag</strong>，该参数为临时添加的参数，用于判断处方类型。</li>
<li><strong>recoresViewBlock</strong>，患者健康档案 <strong>block</strong> 回调，针对视图 <strong>show</strong> 之后的各种附加处理，如，网络请求，存储返回值。</li>
</ul>
<p>这里需要在最终需要调用的患者病历视图类 (<strong>LuHealthRecordsView</strong>) 中增加对应的 <strong>Block</strong> 方法，当操作 <strong>LuHealthRecordsView</strong> 的实例触发视图上的事件时会有结果值回调。（这一步正是替代了原有的两个功能组件间用于交互的代理方法）。具体如下：</p>
<p>在 <strong>LuHealthRecordsView.h</strong> 中声明，</p>
<pre><code class="objectivec">typedef void (^HealthRecordBlock)(NSDictionary *dic);   // 用于返回病史/过敏史的block回调(主要应用于患者中间件的传值)

@property (nonatomic, copy) HealthRecordBlock healthRecordBlock;
</code></pre>
<p>在 <strong>LuHealthRecordsView.m</strong> 中触发回调，</p>
<pre><code class="objectivec">- (void)sureBtnClick
{
    NSDictionary *recordsDic = @{@&quot;buttonType&quot;: @&quot;1&quot;,
                                 @&quot;userTag&quot;: [NSNumber numberWithInteger:self.userTag],
                                 @&quot;illHistory&quot;: self.contentView2.view1.textView.text,
                                 @&quot;allergicHistory&quot;: self.contentView2.view2.textView.text
                                 };
    self.healthRecordBlock(recordsDic);
}
</code></pre>
<p>这里同样是以字典方式返回操作结果，这也是组件化中很重要的一个点 —- <strong>去 model 化</strong>。</p>
<p>在这里还要提一个点，这个大的 <strong>Action</strong> 方法的调用，传入的所有参数都需要与实际要调用的视图一一对应。也就是说用到什么参数，就在该方法中增加什么参数。</p>
<p>患者管理组件（<strong>LZPatientManageComponent</strong>）中，<strong>Target</strong> 目录下处理调用类实例方法，在类 <strong>Target_LZPatientManageComponent</strong> 对应方法下实现，如下：</p>
<p>在 <strong>Target_LZPatientManageComponent.m</strong> 中</p>
<pre><code class="objectivec">/**
 返回LuHealthRecordsView视图
 */
- (UIView *)Action_LuHealthRecordsView:(NSDictionary *)param
{
    LuHealthRecordsView *healthRecordsView = [[LuHealthRecordsView alloc] initWithFrame:CGRectMake(106/2, 70, SCREEN_WIDTH - 106, SCREEN_HEIGHT - 140)];
    NSDictionary *pationModelDic = param[@&quot;pationModelDic&quot;];
    PationModel *pationModel = [[PationModel alloc] init];
    [pationModel setValuesForKeysWithDictionary:pationModelDic];
    healthRecordsView.model = pationModel;
    healthRecordsView.prescriptionFlag = param[@&quot;prescriptionFlag&quot;];
    [healthRecordsView showMe];

    healthRecordsView.healthRecordBlock = param[@&quot;HealthRecordsViewBlock&quot;];

    return healthRecordsView;
}
</code></pre>
<p><strong>LuHealthRecordsView</strong> 为最终需要调用的视图类，在调用前需要将传过来的参数进行转化，</p>
<ul>
<li><strong>param[@”pationModelDic”]</strong> 转化为对应的 <strong>PationModel</strong></li>
<li><strong>param[@”prescriptionFlag”]</strong> 处方类型的标识</li>
<li>还有最为重要的一点，将 <strong>param[@”HealthRecordsViewBlock”]</strong> 的 <strong>block</strong> 赋给 <strong>healthRecordsView.healthRecordBlock</strong> 从而触发回调。</li>
</ul>
<p>最后，在工作台组件中调用患者管理中间件进行通讯，如下：</p>
<pre><code class="objectivec">NSDictionary *pationModelDic = self.patientModel.mj_keyValues;
    __weak typeof(self) weakSelf = self;
    UIView *healthRecordsView = [[LZMediator sharedInstance] LZPatientManageComponent_LuHealthRecordsView:pationModelDic withPrescriptionFlag:@&quot;3&quot; withHealthRecordsViewBlock:^(NSDictionary *dic) {

        NSString *buttonType = dic[@&quot;buttonType&quot;];
        weakSelf.illHistory = dic[@&quot;illHistory&quot;];
        weakSelf.allergicHistory = dic[@&quot;allergicHistory&quot;];

        if ([buttonType isEqualToString:@&quot;0&quot;]) {
            //键盘处理
//            [IQKeyboardManager sharedManager].enable = YES;
            [self.healthRecordsBgView removeFromSuperview];
            NSInteger userTag = [dic[@&quot;userTag&quot;] integerValue];
            if (userTag != 3) {
                [weakSelf savePatientHealthRecords];
            }

        } else if ([buttonType isEqualToString:@&quot;1&quot;]) {
            //键盘处理
//            [IQKeyboardManager sharedManager].enable = YES;
            [weakSelf savePatientHealthRecords];
            weakSelf.headerView.patientModel = weakSelf.patientModel;

        }
    }];
    [_healthbg addSubview:healthRecordsView];
</code></pre>
<p><strong>block</strong> 回调中处理了未进行组件化前代理方法的工作。最后，这里需要强调一个点，当用于通讯的中间件中需要新增与某个组件通讯的方法时，最好是遵循一个原则：</p>
<blockquote>
<p>谁污染谁治理，谁调用谁新增。</p>
</blockquote>
<p>即，哪个组件需要进行与其它组件通讯，则由有这个需要的组件的发起者，去他需要调用的组件的中间件中新增用于通讯的方法。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>涉及到项目组件化还有一些收尾工作：</p>
<ul>
<li>创建壳工程，配置App运行的基本环境</li>
<li>去除主工程 <strong>Assets.xcassets</strong> 目录下的多余资源文件(这些文件已抽到各个业务功能组件中)</li>
<li>组件化方案中的去 <strong>model</strong> 的设计</li>
<li>将各个功能模块中涉及到数据库组件，<strong>SQLite</strong> 的查询语句都移动到数据库组件中</li>
</ul>
<p>5月初开始对项目进行重构，原以为只要项目完成组件化，重构工作就顺理成章的结束了。但现在看来组件化不是重构的结束，仅仅是一个开始。在我看来以私有 <strong>pod</strong> 为形式的组件化，只是一种强制解除各个功能模块之间耦合度的方式。它将一个复杂的项目按功能拆分成不同 <strong>pod</strong> 库，不同组件之前想要通讯，只能通过中间件。因此，我认为组件化的本质是对代码结构的整理，它无形中制定了一套编码规范，迫使开发者在编写代码时不能随心所欲的按照自己的喜好堆放代码。</p>
<p>如果你一开始都注意代码规范，同时又时时留意该如果降低工程中功能间的耦合度。那么，完全没有必要进行组件化。</p>
<blockquote>
<p>组件化只是术，而非道。</p>
</blockquote>
<p>组件化只是项目重构的第一步，项目重构之路道阻且长，但行则必至。这里为了在后续的重构工作中提醒自己，同时，打个疫苗（希望这次打的是真疫苗）预防一下后续重构中可能会遇到的问题。翻译了一篇文章 — <a href="https://xibhe.com/2018/08/10/RebuildFlagsSignaling/" target="_blank" rel="external">重写代码会失败的几个征兆</a> 对比文章中的5个方面，结合正在开发的项目，希望有所帮助。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="external">iOS应用架构谈 开篇 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">iOS应用架构谈 view层的组织和调用方案 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="external">iOS应用架构谈 网络层设计方案 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html" target="_blank" rel="external">iOS应用架构谈 本地持久化方案及动态部署 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">iOS应用架构谈 组件化方案 - Casa Taloyum</a></p>
<p><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a></p>
<p><a href="http://www.ximublog.cn/modularization/" target="_blank" rel="external">组件化方案调研</a></p>
<p><a href="https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/" target="_blank" rel="external">模块化与解耦</a></p>
<p><a href="https://git-scm.com/book/zh/v2/服务器上的-Git-GitLab" target="_blank" rel="external">服务器上的 Git - GitLab</a></p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/4420" target="_blank" rel="external">XCode 7.1 - Include of non-modular header inside framework</a></p>
<p><a href="https://forums.developer.apple.com/thread/23554" target="_blank" rel="external">Include of non-modular header inside framework module</a></p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/3511" target="_blank" rel="external">Reference to ‘enum_value’ is ambiguous</a></p>
<p><a href="https://github.com/AFNetworking/AFNetworking/issues/2205" target="_blank" rel="external">Make AFNetworking compatible for an iOS 8 Cocoa Touch Framework</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目经过三年多的迭代，总共有三拨人接手，代码整体风格各异，迭代后的旧代码与新代码揉在一起，难解难分。各功能模块间相互依赖，头文件多次重复引用，编译一次大概花费5分钟。不得不进行代码组件化后重构。关于应用架构以及组件化的方案 &lt;a href=&quot;https://casatwy.
    
    </summary>
    
      <category term="架构" scheme="http://XibHe.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="组件化" scheme="http://XibHe.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>从一个蓝牙打印说起</title>
    <link href="http://XibHe.github.io/2018/05/28/Compiling/"/>
    <id>http://XibHe.github.io/2018/05/28/Compiling/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-11-11T07:19:40.503Z</updated>
    
    <content type="html"><![CDATA[<p>遇到在 <strong>Release</strong> 模式下 <strong>80mm蓝牙打印机</strong> 无法打印的问题，最终的解决方式都是围绕 <strong>Debug</strong> 和 <strong>Release</strong> 这两种模式展开的。</p>
<h3 id="可能打造无法打印的原因"><a href="#可能打造无法打印的原因" class="headerlink" title="可能打造无法打印的原因"></a>可能打造无法打印的原因</h3><h4 id="1-需要打印的处方药品过多，排列太过复杂造成"><a href="#1-需要打印的处方药品过多，排列太过复杂造成" class="headerlink" title="1.需要打印的处方药品过多，排列太过复杂造成"></a>1.需要打印的处方药品过多，排列太过复杂造成</h4><p>于是，构建一个最简单的打印模板，打印一行最简单的日期，将打印功能尽可能的简单化，看是否是由打印功能本身引起的。结果，仍然无法打印。</p>
<h4 id="2-线程问题，未在主线程刷新UI导致"><a href="#2-线程问题，未在主线程刷新UI导致" class="headerlink" title="2.线程问题，未在主线程刷新UI导致"></a>2.线程问题，未在主线程刷新UI导致</h4><p>每次选择蓝牙打印机打印处方单时，控制台就会输出线程相关的错误，如下：</p>
<pre><code class="objectivec">2018-05-18 15:52:30.568985+0800 CloudOfficeTest[3340:1191905] [reports] Main Thread Checker: UI API called on a background thread: -[UIApplication windows]
PID: 3340, TID: 1191905, Thread name: (none), Queue name: com.apple.root.default-qos.overcommit, QoS: 21
Backtrace:
4   LZBasisComponents                   0x0000000101baad4c +[MBProgressHUD hideHUDForView:animated:] + 132
5   LZBasisComponents                   0x0000000101baab9c +[MBProgressHUD(MJ) hideHUDForView:] + 72
6   LZBasisComponents                   0x0000000101baabf0 +[MBProgressHUD(MJ) hideHUD] + 48
7   CloudOfficeTest                     0x0000000100aee2c8 -[LZBluetoothPrintView startPrint] + 300
8   Foundation                          0x00000001828de860 &lt;redacted&gt; + 996
9   libsystem_pthread.dylib             0x0000000181b1831c &lt;redacted&gt; + 308
10  libsystem_pthread.dylib             0x0000000181b181e8 &lt;redacted&gt; + 0
11  libsystem_pthread.dylib             0x0000000181b16c28 thread_start + 4
</code></pre>
<pre><code class="objectivec">2018-05-18 15:52:38.876328+0800 CloudOfficeTest[3340:1191725] This application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes.
 Stack:(
    0   Foundation                          0x00000001829f266c &lt;redacted&gt; + 96
    1   Foundation                          0x00000001829f2350 &lt;redacted&gt; + 76
    2   Foundation                          0x0000000182822da0 &lt;redacted&gt; + 132
    3   Foundation                          0x00000001829f0458 &lt;redacted&gt; + 112
    4   UIKit                               0x000000018b610b18 &lt;redacted&gt; + 172
    5   UIKit                               0x000000018b32234c &lt;redacted&gt; + 1348
    6   QuartzCore                          0x0000000185edbec8 &lt;redacted&gt; + 184
    7   QuartzCore                          0x0000000185edffa8 &lt;redacted&gt; + 332
    8   QuartzCore                          0x0000000185e4ea98 &lt;redacted&gt; + 336
    9   QuartzCore                          0x0000000185e74eb4 &lt;redacted&gt; + 540
    10  QuartzCore                          0x0000000185e7559c &lt;redacted&gt; + 244
    11  libsystem_pthread.dylib             0x0000000181b17680 &lt;redacted&gt; + 572
    12  libsystem_pthread.dylib             0x0000000181b173d0 &lt;redacted&gt; + 88
    13  libsystem_pthread.dylib             0x0000000181b17168 _pthread_wqthread + 1340
    14  libsystem_pthread.dylib             0x0000000181b16c20 start_wqthread + 4
)
</code></pre>
<p>这里报错是由于 <strong>MBProgressHUD</strong> 导致的，将打印时的 <strong>MBProgressHUD</strong> 都注释掉，仍然无法打印。 又因为在打印时使用了 <strong>NSThread</strong> 去更新打印状态，就怀疑是 <strong>NSThread</strong> 导致的问题。</p>
<pre><code class="objectivec">    if (thread == NULL) {
        [GlobalMethod showName:@&quot;正在打印中&quot; inView:_contentView delay:3];
        thread = [[NSThread alloc] initWithTarget:self selector:@selector(startPrint) object:nil];
        [thread start];
    } else {
        [GlobalMethod showName:@&quot;正在打印中&quot; inView:_contentView delay:3];
    }
</code></pre>
<p>这里索性就把 <strong>NSThread</strong> 的代码也注释掉。此时，编译后再次调用打印<br>功能，后台虽然不会输出线程相关的错误了，但连接上的蓝牙打印机仍然没有任何反应。</p>
<h4 id="3-当-Edit-Scheme-中-Build-Configuration-为-Debug-时，就可以调用蓝牙打印机进行打印。"><a href="#3-当-Edit-Scheme-中-Build-Configuration-为-Debug-时，就可以调用蓝牙打印机进行打印。" class="headerlink" title="3.当 Edit Scheme 中 Build Configuration 为 Debug 时，就可以调用蓝牙打印机进行打印。"></a>3.当 <strong>Edit Scheme</strong> 中 <strong>Build Configuration</strong> 为 <strong>Debug</strong> 时，就可以调用蓝牙打印机进行打印。</h4><p>选择Xcode中，<strong>Product -&gt; Scheme -&gt; Edit Scheme</strong>，注意 <strong>Run</strong> 和 <strong>Archive</strong> 这两种编译方式，选择 <strong>Build Configuration</strong> 就可以切换 <strong>Debug</strong> 和 <strong>Release</strong> 这两种不同的模式。</p>
<p>这就需要对比 <strong>release</strong> 与 <strong>debug</strong> 两种模式的不同，尤其是在调用 <strong>CoreBluetooth</strong> 时的不同。</p>
<p><strong>Release</strong> 是发行版本，比 <strong>Debug</strong> 版本多一些优化，文件比 <strong>Debug</strong> 文件小。 <strong>Debug</strong> 是调试版本，<strong>Debug</strong> 和 <strong>Release</strong> 调用两个不同的底层库。通俗点讲，我们开发者自己内部真机或模拟器调试时，使用 <strong>Debug</strong> 模式就好，等到想要发布时，也就是说需要大众客户使用时，需要构建 <strong>Release</strong> 版本，具体区别如下：</p>
<ol>
<li><strong>Debug</strong> 是调试版本，包括的程序信息更多；</li>
<li>只有 <strong>Debug</strong> 版的程序才能设置断点、单步执行、使用 <strong>TRACE/ASSERT</strong> 等调试输出语句；</li>
<li><strong>Release</strong> 不包含任何调试信息，所以体积小、运行速度快。</li>
</ol>
<p>简而言之，<strong>Release</strong> 版本会对最终发布的项目做优化，以提高 <strong>App</strong> 的运行速度。</p>
<pre><code class="objectivec">//读取特征中的数据
- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {

    NSLog(@&quot;enter didUpdateValueForCharacteristic!&quot;);
    NSLog(@&quot;read data=%@!&quot;,characteristic.value);
}
</code></pre>
<p>如果将此处的 <strong>NSLog</strong> 输出注释掉是否也可以打印？</p>
<p>控制台会一直输出打印类 <strong>LZBluetoothPrintView</strong> 的一个方法 </p>
<pre><code class="objectivec">&lt;LZBluetoothPrintView.m : 382&gt; -[LZBluetoothPrintView peripheral:didUpdateValueForCharacteristic:error:]
2018-05-18 15:52:38.778826+0800 CloudOfficeTest[3340:1191349] enter didUpdateValueForCharacteristic!
</code></pre>
<pre><code class="objectivec">- (void)viewDidLoad
{
    [super viewDidLoad];
#ifdef DEBUG
    NSLog(@&quot;Test DEBUG mode&quot;);
#else
    NSLog(@&quot;Test Release mode&quot;);
#endif
}
</code></pre>
<h3 id="不同的解决方案"><a href="#不同的解决方案" class="headerlink" title="不同的解决方案"></a>不同的解决方案</h3><h4 id="方案一：将-Build-Settings-里面的-Apple-LLVM-9-0-Preprocessing-Preprocessor-Macros-这里。在-release-下增加配置项-DEBUG-1，即可打印。"><a href="#方案一：将-Build-Settings-里面的-Apple-LLVM-9-0-Preprocessing-Preprocessor-Macros-这里。在-release-下增加配置项-DEBUG-1，即可打印。" class="headerlink" title="方案一：将 Build Settings 里面的 Apple LLVM 9.0 - Preprocessing - Preprocessor Macros 这里。在 release 下增加配置项 DEBUG = 1，即可打印。"></a>方案一：将 <strong>Build Settings</strong> 里面的 <strong>Apple LLVM 9.0 - Preprocessing - Preprocessor Macros</strong> 这里。在 <strong>release</strong> 下增加配置项 <strong>DEBUG = 1</strong>，即可打印。</h4><p>只是暂时解决了打印问题，慎用！因为默认情况下 <strong>release</strong> 模式是不需要设置为 <strong>DEBUG</strong> 模式的。</p>
<p>这里有一个疑问？当设置 <strong>Edit Scheme</strong> 的 <strong>Archive</strong> 中 <strong>Build Configuration</strong> 为 <strong>Release</strong> 时，此时，<strong>Archive</strong> 后生成一个 <strong>ipa</strong>包，导出并安装后发现程序中调用的仍然 <strong>DEBUG</strong> 模式下的程序。代码如下：</p>
<pre><code class="objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    UIView *backView1 = [[UIView alloc] initWithFrame:CGRectMake(self.view.center.x - 20, self.view.center.y - 20, 40, 40)];
    [self.view addSubview:backView1];

#ifdef DEBUG
    backView1.backgroundColor = [UIColor redColor];
    NSLog(@&quot;Test DEBUG mode&quot;);
#else
    backView1.backgroundColor = [UIColor greenColor];
    NSLog(@&quot;Test Release mode&quot;);
#endif
}
</code></pre>
<p>此时，打开通过 <strong>ipa</strong> 包安装的程序，展示的为红色的视图。</p>
<h4 id="方案二：将-Build-Settings-里面的-Optimization-Level-的-release-对应的配置项改为-None-OO"><a href="#方案二：将-Build-Settings-里面的-Optimization-Level-的-release-对应的配置项改为-None-OO" class="headerlink" title="方案二：将 Build Settings 里面的 Optimization Level 的 release 对应的配置项改为 None[-OO]"></a>方案二：将 <strong>Build Settings</strong> 里面的 <strong>Optimization Level</strong> 的 <strong>release</strong> 对应的配置项改为 <strong>None[-OO]</strong></h4><p>修改 <em>release</em> 模式下的编译策略为 <strong>-OO</strong> 即，不做任何编译优化。编译策略是对代码编译过程的优化（c-&gt;汇编），优化后的代码效率比较高，但是可读性比较差，且编译时间更长。</p>
<p>GCC_OPTIMIZATION_LEVEL = Fastest, Smallest   [-OS] 优化级别：</p>
<ul>
<li>None： 不做优化使用这个设置，编译器的目标是减少编译成本，使调试产生预期的结果。</li>
<li>Fast：优化编译将为大函数占用更多的时间和内存使用这个设置，编译器将尝试减少代码的大小和执行时间，不进行任何优化，需要大量编译时间。</li>
<li>Faster：编译器执行几乎所有支持的优化，它不考虑空间和速度之间的平衡与“Fast”设置相比，该设置会增加编译时间和生成代码的性能。编译器不进行循环展开、内联函数和寄存器变量的重命名。</li>
<li>Fastest：开启“Faster”支持的所有的优化，同时也开启内联函数和寄存器变量的重命名选项</li>
<li>Fastest，smallest：优化代码大小这个设置启用“Faster”所有的优化，一般不增加代码大小，它还执行旨在减小代码大小的进一步优化。</li>
</ul>
<h4 id="方案三：将蓝牙打印页面的预览视图中所有-define-NSLog-format-…-do-对应的-NSLog-注释掉。"><a href="#方案三：将蓝牙打印页面的预览视图中所有-define-NSLog-format-…-do-对应的-NSLog-注释掉。" class="headerlink" title="方案三：将蓝牙打印页面的预览视图中所有 #define NSLog(format, …) do 对应的 NSLog 注释掉。"></a><del>方案三：将蓝牙打印页面的预览视图中所有 <strong>#define NSLog(format, …) do</strong> 对应的 <strong>NSLog</strong> 注释掉。<del></del></del></h4><p>最后发现将打印页面的所有输出语句注释掉不会起到任何作用，因此，只剩下 <strong>方案二</strong> 可行了。</p>
<h4 id="方案四：从源码编译入手，利用-Clang-在编译为可执行文件前，过滤编译过程中影响打印的操作。"><a href="#方案四：从源码编译入手，利用-Clang-在编译为可执行文件前，过滤编译过程中影响打印的操作。" class="headerlink" title="方案四：从源码编译入手，利用 Clang 在编译为可执行文件前，过滤编译过程中影响打印的操作。"></a>方案四：从源码编译入手，利用 <strong>Clang</strong> 在编译为可执行文件前，过滤编译过程中影响打印的操作。</h4><p>相对而言，这种方式是最复杂，最有难度的一种方式。但却能追本溯源，从根本上明白为什么无法打印？</p>
<h3 id="从源码到可执行文件"><a href="#从源码到可执行文件" class="headerlink" title="从源码到可执行文件"></a>从源码到可执行文件</h3><p>Low Level Virtual Machine (LLVM) 是一个开源的编译器架构，Clang 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。</p>
<p>利用<a href="http://www.alonemonkey.com/2016/12/21/learning-llvm/" target="_blank" rel="external">LLVM</a> 将源码编译为可被不同语言识别的中间表示(IR)。</p>
<h4 id="可以用Clang做什么"><a href="#可以用Clang做什么" class="headerlink" title="可以用Clang做什么?"></a>可以用Clang做什么?</h4><h5 id="1-libclang进行语法分析"><a href="#1-libclang进行语法分析" class="headerlink" title="1. libclang进行语法分析"></a>1. libclang进行语法分析</h5><p>可以使用libclang里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。</p>
<h5 id="2-LibTooling"><a href="#2-LibTooling" class="headerlink" title="2. LibTooling"></a>2. LibTooling</h5><p>对语法树有完全的控制权，可以作为一个单独的命令使用，如：clang-format</p>
<h5 id="3-ClangPlugin"><a href="#3-ClangPlugin" class="headerlink" title="3. ClangPlugin"></a>3. ClangPlugin</h5><p>对语法树有完全的控制权，作为插件注入到编译流程中，可以影响build和决定编译过程。目录:llvm/tools/clang/examples</p>
<p>这里蓝牙打印的在release模式下无法打印的问题，涉及到编译器编译至可执行文件时，中间所做的优化处理。可以尝试从编译流程入手，进行相应的语法分析，过滤掉非必须但影响蓝牙打印的优化操作。</p>
<blockquote>
<p>通过遍历语法树，去修改里面的方法名和返回变量名。</p>
</blockquote>
<p>.cpp 文件，在编译源文件时，C++编译器会对符号(函数或变量)名作某些修正，修正后生成目标文件的后缀为.cpp。</p>
<blockquote>
<p>基于 Pass，我们可以做什么？ 我们可以编写自己的 Pass 去混淆代码，以增加他人反编译的难度。</p>
</blockquote>
<ol>
<li>LLVM 编译一个源文件的过程：<br>预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</li>
<li>基于 LLVM，我们可以做什么？<ol>
<li>做语法树分析，实现语言转换 OC 转 Swift、JS or 其它语言，字符串加密。</li>
<li>编写 ClangPlugin，命名规范，代码规范，扩展功能。</li>
<li>编写 Pass，代码混淆优化”</li>
</ol>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://halfrost.github.io/2016/08/手把手教你给一个iOS-app配置多个环境变量/" target="_blank" rel="external">手把手教你给一个iOS app配置多个环境变量</a></p>
<p><a href="https://stackoverflow.com/questions/3784583/xcode-debug-vs-release-build-when-debugging" target="_blank" rel="external">XCode debug vs release build when debugging</a></p>
<p><a href="http://www.alonemonkey.com/2016/12/21/learning-llvm/" target="_blank" rel="external">初识 LLVM</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/" target="_blank" rel="external">结构化编译器前端 Clang 介绍</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到在 &lt;strong&gt;Release&lt;/strong&gt; 模式下 &lt;strong&gt;80mm蓝牙打印机&lt;/strong&gt; 无法打印的问题，最终的解决方式都是围绕 &lt;strong&gt;Debug&lt;/strong&gt; 和 &lt;strong&gt;Release&lt;/strong&gt; 这两种模式展开
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="编译器" scheme="http://XibHe.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="环境变量" scheme="http://XibHe.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>从一个数据量过多的优化说起</title>
    <link href="http://XibHe.github.io/2018/04/18/SQLOptimize/"/>
    <id>http://XibHe.github.io/2018/04/18/SQLOptimize/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-11-11T07:21:57.961Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间遇到一个问题，程序中查询患者信息的功能，当患者数据量超过 <strong>30000</strong> 条时，会出现卡顿，APP 无响应的问题。在处理这个需求时，需要将本地数据库中的全部患者数据查询出来，然后按照从 <strong>A - Z</strong> 的患者首字母进行分组排序。对于不属于 <strong>A - Z</strong> 的数据，将其分为 <strong>#</strong> 组。</p>
<h3 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h3><p>更新记录:</p>
<ul>
<li>2018 年 04 月，第一版。</li>
<li>2018 年 06 月，补充后续的优化方案。</li>
</ul>
<h2 id="卡顿问题的解决"><a href="#卡顿问题的解决" class="headerlink" title="卡顿问题的解决"></a>卡顿问题的解决</h2><p>原来的代码逻辑如下：</p>
<pre><code class="objectivec">// 全部患者数据
_allPatients = [[LZDatabaseHelper sharedInstance] getAllPatient];
NSMutableArray *tempArray = _allPatients.mutableCopy;
    for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) {
        LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
        sectionModel.sectionTitle = [NSString stringWithFormat:@&quot;%c&quot;,a];
        for (int i = 0; i &lt; _allPatients.count; i++) {
            PationMoedl *pationModel = _allPatients[i];
            if (pationModel.userShortName.length &gt; 0) {
                char temp = [pationModel.userShortName characterAtIndex:0];
                if (a == temp) {
                    [sectionModel.patientList addObject:pationModel];
                    [tempArray removeObject:pationModel];
                }
            }
        }
        if (sectionModel.patientList.count &gt;0) {
            [self.patientArray addObject:sectionModel];
        }
    }
    LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
    sectionModel.sectionTitle = @&quot;#&quot;;
    if (tempArray.count &gt; 0) {
        [sectionModel.patientList addObjectsFromArray:tempArray];
        [self.patientArray insertObject:sectionModel atIndex:0];
    }
    [_patientTableView reloadData];
</code></pre>
<p>从上面的代码可以计算出排序的时间复杂度，第一个 <strong>for</strong> 循环执行 <strong>26</strong> 次，嵌套在内的第二个 <strong>for</strong> 循环会执行 <strong>30000</strong> 次。时间复杂度用大写字母 <strong>O</strong> 来表示，因此该排序的时间复杂度是:</p>
<font color="#e5622" size="5"> O(26 * 30000) </font>

<p>也就是说当点击对应的按钮查看患者后，会执行 <strong>780000</strong> 次 <strong>for</strong> 去遍历全部患者，并将符合首字母符合 <strong>A - Z</strong> 的患者添加到 <strong>sectionModel.patientList</strong> 数组中，然后刷新列表展示排好序的数据。这也是为什么会出现患者量少时没有问题，一但患者量达到上万条时就会出现点击对应按钮后，就会出现卡顿的问题。要解决这样的问题，需要从如何降低时间复杂度着手。</p>
<p>尝试了 <strong>4</strong> 种不同的方案，如下：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一:"></a>方案一:</h3><p>算法角度上，以空间换时间，一下子就创建好 26 个存放 A - Z 首字母排序的数组，以减少循环次数为目的，循环一次，找到对应首字母序列的数据，从数据源中移除这些数据；然后，继续开始下一次遍历，以此类推，直到查询出所有排序数组。（时间复杂度，空间复杂度）</p>
<ul>
<li><p>桶排序算法</p>
</li>
<li><p>快速排序算法</p>
</li>
</ul>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二:"></a>方案二:</h3><p>几种不同遍历方式的比较，试图通过比较查询效率，找到最快的遍历方式。</p>
<ul>
<li>经典 for 循环</li>
<li>for in (NSFastEnumeration)</li>
<li>KVC 集合运算符 </li>
<li>enumerateObjectsUsingBlock</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent) </li>
</ul>
<p>初始化 <strong>100</strong> 个对象的遍历操作所消耗的时间(毫秒级): </p>
<ul>
<li>经典for循环 — 0.0023</li>
<li>for in (NSFastEnumeration) — 0.003090</li>
<li>makeObjectsPerformSelector — 0.001120</li>
<li>kvc集合运算符 — 0.004272</li>
<li>enumerateObjectsUsingBlock — 0.001145</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent) — 0.001605</li>
</ul>
<p>这样并不能看出什么结论，当初始化 <strong>1000000</strong> 个对象时就会有很大差距</p>
<ul>
<li>经典for循环 — 1.246721</li>
<li>for in (NSFastEnumeration) — 0.025955</li>
<li>makeObjectsPerformSelector — 0.068234</li>
<li>kvc集合运算符 — 21.677246</li>
<li>enumerateObjectsUsingBlock — 0.586034</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent) — 0.722548</li>
</ul>
<p>可以看出当数据量少时，<strong>for in</strong> 的速度并不突出，但当数量达到一定量级后，<strong>for in</strong> 的遍历速度就体现出来了。</p>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三:"></a>方案三:</h3><p>折中方案，为了避免查询时卡死主线程，将查询方法放在 <strong>异步线程</strong> 里，然后在 <strong>主线程</strong> 中刷新数据源。如下：</p>
<pre><code class="objectivec">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{

        for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) {
            LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
            sectionModel.sectionTitle = [NSString stringWithFormat:@&quot;%c&quot;,a];

            for (PationMoedl *pationModel in _allPatients) {
                // 根据数据库中的患者简称，将对应简称的model存入sectionModel.patientList中
                if (pationModel.userShortName.length &gt; 0) {
                    char temp = [pationModel.userShortName characterAtIndex:0];
                    if (a == temp) {
                        [sectionModel.patientList addObject:pationModel];
                        [tempArray removeObject:pationModel];
                    }
                }
            }
            if (sectionModel.patientList.count &gt;0) {
                [self.patientArray addObject:sectionModel];
            }
        }

        LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
        sectionModel.sectionTitle = @&quot;#&quot;;
        if (tempArray.count &gt; 0) {
            [sectionModel.patientList addObjectsFromArray:tempArray];
            [self.patientArray insertObject:sectionModel atIndex:0];
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            [_patientTableView reloadData];
            [MBProgressHUD hideHUDForView:self];
        });

});
</code></pre>
<h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><p>方案4也是最终采用的方案，主要时间排序的功能用 <strong>SQL</strong> 语句去实现，在每次遍历时，传入一个当前的序列，通过执行数据库查询语句得到一个分好的序列数组，这样就大大减少了 <strong>for</strong> 循环的次数，提高了速度。但为了不卡死线程，仍然需要与 <strong>GCD</strong> 结合起来使用。如下：</p>
<pre><code class="objectivec">[MBProgressHUD showMessag:@&quot;加载中&quot; toView:self];
// 1. 将整个查询的耗时操作放到 GCD 中
dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
//  查询出所有患者数据，为搜索功能提供数据源
     _allPatients = [[LZDatabaseHelper sharedInstance] getAllPatientForIndexes];
     // 2. 从 A - Z 进行 26 次遍历
    for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) {
        NSString *orderNumber = [NSString stringWithFormat:@&quot;%c&quot;,a];
        // 3. 通过 SQL 语句查出对应首字母序列的返回的数组
        NSArray *patientRankArray = [[LZDatabaseHelper sharedInstance] getPatientGroup:orderNumber];
        // 4. 将查询到的某一序列数组与分组名称进行绑定
        if (patientRankArray &amp;&amp; patientRankArray.count &gt; 0) {
            LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
            sectionModel.sectionTitle = orderNumber;
            [sectionModel.patientList addObjectsFromArray:patientRankArray];
            [self.patientArray addObject:sectionModel];
        }
    }

        // 5. 通过 SQL 语句查出其他非 A-Z 的数据
        NSArray *otherArray = [[LZDatabaseHelper sharedInstance] getPatientMistakeGroup];

        // 6. 将查询到的非 A-Z 插入到患者数据源中
        if (otherArray &amp;&amp; otherArray.count &gt; 0) {
            LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
            sectionModel.sectionTitle = @&quot;#&quot;;
            [sectionModel.patientList addObjectsFromArray:otherArray];
            [self.patientArray insertObject:sectionModel atIndex:0];
        }

        // 7. 主线程中刷新列表
        dispatch_async(dispatch_get_main_queue(), ^{
            [_patientTableView reloadData];
            [MBProgressHUD hideHUDForView:self];
        });

    });
</code></pre>
<p>具体步骤如下：</p>
<ol>
<li>将整个查询的耗时操作放到 GCD 中；</li>
<li>从 A - Z 进行 26 次遍历；</li>
<li>通过 SQL 语句查出对应首字母序列的返回的数组；</li>
<li>将查询到的某一序列数组与分组名称进行绑定；</li>
<li>通过 SQL 语句查出其他非 A-Z 的数据；</li>
<li>将查询到的非 A-Z 插入到患者数据源中；</li>
<li>主线程中刷新列表。</li>
</ol>
<p>这里将最为耗时的对应首字母遍历数据操作，通过 <strong>SQL</strong> 查询语句来实现。那么 <strong>SQL</strong> 语句的查询速度究竟如何呢？可以在处理 <strong>SQL</strong> 查询的方法里增加计算方法执行耗时的代码：</p>
<pre><code class="objectivec">// 记录开始时间，放在方法执行的最前面
NSDate *startDate = [NSDate date];

// 记录结束时间，放到方法执行结束的位置
NSDate *finishDate = [NSDate date];
NSTimeInterval interval = [finishDate timeIntervalSinceDate:startDate];
NSLog(@&quot;查询全部患者数据耗时: %f&quot;,interval);
</code></pre>
<p>返回的时间戳大概为 <strong>0.45</strong> 毫秒。</p>
<h2 id="关于数据库查询语句的优化"><a href="#关于数据库查询语句的优化" class="headerlink" title="关于数据库查询语句的优化"></a>关于数据库查询语句的优化</h2><ol>
<li>建立索引</li>
<li>不要把SQL语句写得太复杂</li>
<li>避免过度使用 Select * 查询所有数据 （实际使用时只需要某一个或几个字段）</li>
<li>统一 <strong>SQL</strong> 语句的写法 (主要区分大小写)</li>
<li><strong>REPLACE INTO</strong> 语句的使用<ul>
<li><em>REPLACE</em> 作用与 <em>INSERT</em> 完全一致，但如果旧表中的行具有相同的值作为一个新行 <em>PRIMARY KEY</em> 或 <em>UNIQUE</em> 索引，旧行插入新行之前删除。</li>
<li><em>REPLACE</em> 是一个 <em>MySQL</em> 扩展 <em>SQL</em> 标准。它要么插入要么先删除再插入。</li>
<li>注意，除非表有一个 <em>PRIMARY KEY</em> 或 <em>UNIQUE</em> 索引，否则使用 <em>REPLACE</em> 语句是没有意义的。</li>
</ul>
</li>
<li><p><strong>SQL</strong> 语句的拓展</p>
<ul>
<li><em>sqlite</em> 截取字符串前几位后再进行查询</li>
<li>在 <em>sqlite</em> 中使用 <em>regex</em> 进行查询</li>
<li><p>SUBSTR()，SQL 中的 substring 函数是用来抓出一个栏位资料中的其中一部分。这个函数的名称在不同的数据库中不完全一样：</p>
<blockquote>
<p>MySQL: SUBSTR( ), SUBSTRING( )<br>Oracle: SUBSTR( )<br>SQL Server: SUBSTRING( )</p>
</blockquote>
</li>
<li><p>upper()函数，将小写转化为大写；lower()函数，将大写转化为小写。</p>
</li>
</ul>
</li>
</ol>
<pre><code class="objectivec">// 根据 A - Z 进行分组查询
NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, userName, userShortName, birthday, sex, phone, address FROM table_sickPerson WHERE clinicId = &#39;%@&#39; AND status like &#39;0&#39; AND isDelete like &#39;0&#39; AND SUBSTR(upper(userShortName),1,1) = &#39;%@&#39; &quot;,clinkId,orderNumber];
</code></pre>
<ul>
<li>GLOB 用来连接正则表达式的关键字</li>
</ul>
<pre><code class="objectivec">// 查询非 A - Z 的数据
NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, userName, userShortName, birthday, sex, phone, address FROM table_sickPerson WHERE clinicId = &#39;%@&#39; AND status like &#39;0&#39; AND isDelete like &#39;0&#39; AND SUBSTR(upper(userShortName),1,1) GLOB &#39;[^A-Z]&#39; &quot;,clinkId];
</code></pre>
<p>之前没有在 <strong>SQLite</strong> 中使用过 <strong>regex</strong> 还以为不支持呢，最后几经波折，在官网上找到了对应的文档！</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/SQLDataOptimize_thumbnail01.png" alt="SQLite官网"></p>
<h2 id="ONE-PIECE"><a href="#ONE-PIECE" class="headerlink" title="ONE PIECE"></a>ONE PIECE</h2><h3 id="一个关于-CoreData-的问题"><a href="#一个关于-CoreData-的问题" class="headerlink" title="一个关于 CoreData 的问题"></a>一个关于 CoreData 的问题</h3><p><strong>Core Data</strong> 是 <strong>iOS5</strong> 之后才出现的一个框架，本质上是对 <strong>SQLite</strong> 的一个封装，它允许按照实体-属性-值模型组织数据，并以 <strong>XML</strong>，二进制文件或<strong>SQLite</strong> 数据文件的格式将其序列化。<strong>Core Data</strong> 允许用户使用代表实体和实体间关系的高层对象来操作数据。它也可以管理序列化的数据，提供对象生存期管理与 <strong>object graph</strong> 管理，包括存储。<strong>Core Data</strong> 直接与 <strong>SQLite</strong> 交互，避免开发者使用原本的 <strong>SQL</strong> 语句。</p>
<p>这里在尝试使用 <strong>Core Data</strong> 时遇到一个问题，在获取模型路径，创建模型对象时，一直报错：</p>
<pre><code class="objectivec">    NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@&quot;testModel&quot; withExtension:@&quot;momd&quot;];
    _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    return _managedObjectModel;
</code></pre>
<pre><code class="objectivec"> *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;CoreData: Cannot load NSManagedObjectModel.  nil is an illegal URL parameter&#39;
</code></pre>
<p><strong>Core Data</strong> 数据库的名字和封装类里的名字是一致的。</p>
<h3 id="使用Blob存储NSData遇到的问题"><a href="#使用Blob存储NSData遇到的问题" class="headerlink" title="使用Blob存储NSData遇到的问题"></a>使用Blob存储NSData遇到的问题</h3><p>先通过 <em>UPDATE</em> 语句更新数据，</p>
<pre><code class="objectivec">// 更新faceFeatureData
+ (void)updateFaceFeatureData:(NSData *)faceFeatureData
{
    FMDatabase *dataBase = [ConfigurateDB open];
    [dataBase beginTransaction];

    NSString *sql = [NSString stringWithFormat:@&quot;UPDATE Register SET faceFeatureData = &#39;%@&#39; WHERE id = &#39;1&#39;&quot;,faceFeatureData];
    [dataBase executeUpdate:sql];

    [dataBase commit];
}
</code></pre>
<p>再通过 <em>SELECT</em> 获取更新的值。</p>
<pre><code class="objectivec">// 获取个人信息
+ (AFRPerson *)getInformationWithUserID:(NSInteger)Id
{
    FMDatabase *dataBase = [ConfigurateDB open];
    NSString *sql = [NSString stringWithFormat:@&quot;SELECT * FROM Register WHERE id = &#39;%ld&#39;&quot;,Id];
    FMResultSet * resultSet = [dataBase executeQuery:sql];
    AFRPerson *person = nil;
    while ([resultSet next]) {
        person = [[AFRPerson alloc] init];

        person.Id = [resultSet intForColumn:@&quot;id&quot;];
        person.faceID  = [resultSet intForColumn:@&quot;faceID&quot;];
        person.faceFeatureData = [resultSet dataForColumn:@&quot;faceFeatureData&quot;];
        person.name = [resultSet stringForColumn:@&quot;name&quot;];
        person.attendanceStatus = [resultSet stringForColumn:@&quot;attendanceStatus&quot;];
    }

    [resultSet close];

    return person;
}
</code></pre>
<p>发现 <em>person.faceFeatureData</em> 这个 <em>NSData</em> 类型的属性值，更新前与更新后再次获取的字节长度不一致，前者为：22020 bytes，后者为：48096 bytes。正常结果二者应是一致的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>第一手资料永远是官方文档！！！</li>
<li>算法真的真的很重要! ! !</li>
<li>很多性能问题，首先可以先从算法角度进行思考；</li>
<li>使用 <strong>GCD</strong> 多线程技术来处理耗时任务；</li>
<li>算法，不同遍历方式进行比较，<strong>SQL</strong>查询语句的优化，<strong>GCD</strong> 这几种方式相结合总能给人意想不到的惊喜，没有一种解决方案是孤立存在的。</li>
</ul>
<p>对症下药吧！将提高查询效率和减少遍历次数二者相结合。做完这次优化后，还是想问一句：这是最优的方案吗？还可以进一步优化吗? </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后，这种方式虽然可以缓解数据量达到 <em>30000</em> 条时的卡顿状况。但打开列表页面时，仍然会 <em>loading</em> 两三秒， 最终处理方案是：当数据量大于 <em>5000</em> 条时，进行分页加载，一次加载 <em>200</em> 条，此时就没有必要将数据按首字母缩写排序了，可通过搜索框搜索出对应患者；当数据量小于 <em>5000</em> 时，仍保持之前的逻辑。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.sqlite.org/search?s=d&amp;q=regexp" target="_blank" rel="external">sqlite.org Documentation</a></p>
<p><a href="https://www.w3cschool.cn/sql/7vn4tfq0.html" target="_blank" rel="external">w3cschool SQL</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html" target="_blank" rel="external">13.2.9 REPLACE Syntax</a></p>
<p><a href="https://stackoverflow.com/questions/7793488/regex-in-sqlite-and-objectivec" target="_blank" rel="external">Regex in SQLite and ObjectiveC</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Core_Data" target="_blank" rel="external">Core Data</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间遇到一个问题，程序中查询患者信息的功能，当患者数据量超过 &lt;strong&gt;30000&lt;/strong&gt; 条时，会出现卡顿，APP 无响应的问题。在处理这个需求时，需要将本地数据库中的全部患者数据查询出来，然后按照从 &lt;strong&gt;A - Z&lt;/strong&gt; 的患
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="SQLite" scheme="http://XibHe.github.io/tags/SQLite/"/>
    
      <category term="性能优化" scheme="http://XibHe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解RunLoop</title>
    <link href="http://XibHe.github.io/2018/03/18/RunLoopAnalysis/"/>
    <id>http://XibHe.github.io/2018/03/18/RunLoopAnalysis/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-11-11T07:25:47.976Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客介绍了使用 <em>WKWebView</em> 进行性能调优，以及使用中遇到的问题。当在弱网环境下频繁切换 <em>H5</em> 页面时，就会出现应用卡死的情况。<a href="http://xibhe.com/2018/02/03/WKWebView-disabuse/" target="_blank" rel="external">使用WKWebView进行性能调优</a>，控制台会报三个错误，其中一个错误是：</p>
<pre><code class="objectivec">2018-02-01 11:09:01.952689+0800 CloudOfficeTest[614:68129] void SendDelegateMessage(NSInvocation *): delegate (webView:decidePolicyForNavigationAction:request:frame:decisionListener:) failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode
</code></pre>
<p>错误中出现了 <em>main run loop mode: kCFRunLoopDefaultMode</em> 的信息提示，最后虽然将项目中的 <em>UIWebView</em> 替换为 <em>WKWebView</em> ( <em>WKWebView</em>的内存消耗相比 <em>UIWebView</em> 低了一个数量级)。但却没有将这个报 <em>RunLoop</em> 的错误解释清楚，今天就结合一些实例叙述一下自己对 <em>RunLoop</em> 的浅见。</p>
<h3 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h3><p>更新记录:</p>
<ul>
<li>2018 年 03 月，第一版。</li>
<li>2018 年 04 月，补充利用 RunLoop 解决一些问题的 Demo。</li>
</ul>
<h3 id="RunLoop-是什么"><a href="#RunLoop-是什么" class="headerlink" title="RunLoop 是什么"></a>RunLoop 是什么</h3><p><em>Runloop</em> 是 <em>iOS</em> 底层机制，就是一个运行循环，确切的说是为了保证程序会一直运行不退出的死循环。</p>
<p>在 <em>iOS</em> 中的入口函数执行类似逻辑，这里打印只会输出 <em>执行了!!!</em>，并不会输出 <em>有没有执行???</em>，这里开启了一个和主线程相关的 <em>RunLoop</em>，导致 <em>UIApplicationMain</em> 不会返回，一直处在运行中。</p>
<pre><code class="objectivec">int main(int argc, char * argv[]) {
    @autoreleasepool {
        NSLog(@&quot;执行了!!!&quot;);
        // 主线程死循环 --- RunLoop
        int a = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
        NSLog(@&quot;有没有执行???&quot;);
        return a;
    }
}
</code></pre>
<font color="#DC143C" size="3">下面这段内容摘抄自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 中 <em>RunLoop的概念</em> 中的叙述。</font>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常代码逻辑是这样的：</p>
<pre><code class="c">function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code></pre>
<p>这种模型通常被称作<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event loop</a>。<em>Event Loop</em> 在很多系统和框架里都有实现，比如：</p>
<ul>
<li><em>Node.js</em> 的事件处理</li>
<li><em>Windows</em> 程序的消息循环</li>
<li><em>OSX/iOS</em> 的 <em>RunLoop</em></li>
</ul>
<p>实现这种模型的关键的在于：</p>
<blockquote>
<p>如何管理事件/消息，如何让线程在没有处理消息时休眠，以避免资源占用；在有消息到来时立刻被唤醒。</p>
</blockquote>
<p>所以，<em>RunLoop</em> 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的 <em>Event Loop</em> 逻辑。线程执行了这个函数后，就会一直处于这个函数内部 <em>接受消息 –&gt; 等待 –&gt; 处理</em> 的循环中，直到这个循环结束（比如，传入 <em>quit</em> 消息），函数返回。</p>
<p><em>OSX/iOS</em> 系统中，提供了两个这样的对象：<em>NSRunLoop</em> 和 <em>CFRunLoopRef</em>。<em>NSRunLoop</em> 是基于 <em>CFRunLoopRef</em> 的封装，提供了面向对象的 <em>API</em>，但这些 <em>API</em> 不是线程安全的。<em>CFRunLoopRef</em> 是在 <em>CoreFoundation</em> 框架内的，它提供了纯 <em>C函数</em> 的 <em>API</em>，所以这些 <em>API</em> 都是线程安全的。</p>
<h3 id="RunLoop-的作用"><a href="#RunLoop-的作用" class="headerlink" title="RunLoop 的作用"></a>RunLoop 的作用</h3><ol>
<li>保住程序不退出，持续运行；</li>
<li>负责监听程序中的各种事件，如：网络，触摸，定时器等；</li>
<li>渲染 <em>UI</em>；</li>
<li>节省 <em>CPU</em> 资源，提高程序性能；</li>
<li>线程间的通讯。</li>
</ol>
<h3 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h3><font color="#DC143C" size="3">下面这段内容摘抄自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 中 <em>RunLoop 与线程的关系</em> 中的叙述。</font>

<p>苹果不允许直接创建 <em>RunLoop</em>，它只提供了两个自动获取的函数：<em>CFRunLoopGetMain()</em> 和 <em>CFRunLoopGetCurrent()</em>。 这两个函数内部的逻辑大概是下面这样:</p>
<pre><code class="c">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;

/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&amp;loopsLock);

    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }

    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));

    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }

    OSSpinLockUnLock(&amp;loopsLock);
    return loop;
}

CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}

CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
</code></pre>
<ol>
<li>线程和 <em>RunLoop</em> 是一一对应的；</li>
<li>线程刚刚创建时并没有 <em>RunLoop</em>，如果你不主动获取，那它一直不会有；</li>
<li><em>RunLoop</em> 的创建发生在第一次获取时，<em>RunLoop</em> 的销毁发生在线程结束时；</li>
<li>只能在一个线程的内部获取其 <em>RunLoop</em> (主线程除外)。</li>
</ol>
<h3 id="CoreFoundation-中-RunLoop-的组成结构"><a href="#CoreFoundation-中-RunLoop-的组成结构" class="headerlink" title="CoreFoundation 中 RunLoop 的组成结构"></a>CoreFoundation 中 RunLoop 的组成结构</h3><p><em>CoreFoundation</em> 中关于 <em>RunLoop</em> 有5个类：</p>
<ul>
<li><em>CFRunLoopModeRef</em> // 运行模式，每次调用时只能选择一种，在不同模式中做不同的操作。</li>
<li>__CFRunLoop <em> </em>CFRunLoopRef<em>; // 获得当前 </em>RunLoop*</li>
<li>__CFRunLoopSource <em> </em>CFRunLoopSourceRef*; // 事件源</li>
<li>__CFRunLoopObserver <em> </em>CFRunLoopObserverRef*; // 观察者</li>
<li>__CFRunLoopTimer <em> </em>CFRunLoopTimerRef*; // 定时器时间</li>
</ul>
<font color="#DC143C" size="3">下面这段内容摘抄自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 中 <em>RunLoop 对外接口</em> 中的叙述。</font>

<p>其中 <em>CFRunLoopModeRef</em> 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/RunLoopAnalysis_01.png?imageView/4/w/300" alt="CFRunLoopModeRef的关系"></p>
<ol>
<li><strong>CFRunLoopModeRef</strong>，一个 <strong>RunLoop</strong> 包含若干个 <strong>Mode</strong><br>，每个 <strong>Mode</strong> 又包含若干个 <strong>Source/Timer/Observer</strong>。每次调用 RunLoop的主函数时，只能指定其中一个 <strong>Mode</strong>，这个 <strong>Mode</strong> 被称为 <strong>CurrentMode</strong>。如果需要切换 <strong>Mode</strong>，只能退出 <strong>RunLoop</strong>，再重新指定一个 <strong>Mode</strong> 进入。这样做主要是为了分隔开不同组的 <strong>Source/Timer/Observer</strong>，让其互不影响。</li>
<li><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。<strong>source</strong> 有两个版本：<strong>source0</strong> 和 <strong>source1</strong>。<ol>
<li><strong>Source0</strong> 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <strong>CFRunLoopSourceSignal(source)</strong>，将这个 <strong>Source</strong> 标记为待处理，然后手动调用 <strong>CFRunLoopWakeUp(runloop)</strong> 来唤醒 <strong>RunLoop</strong>，让其处理这个事件。</li>
<li><strong>Source1</strong> 包含了一个 <strong>mach_port</strong> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 <strong>Source</strong> 能主动唤醒 <strong>RunLoop</strong> 的线程。</li>
</ol>
</li>
<li><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 <strong>NSTimer</strong> 是 <strong>toll-free bridged</strong> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 <strong>RunLoop</strong> 时，<strong>RunLoop</strong> 会注册对应的时间点，当时间点到期时，<strong>RunLoop</strong> 会被唤醒一执行那个回调。</li>
<li><strong>CFRunLoopObserverRef</strong> 是观察者，每个 <strong>Observer</strong> 都包含了一个回调（函数指针），当 <strong>RunLoop</strong> 的状态发生变化时，观察者就能通过回调接受这个变化。可以观察的时间点有以下几个：</li>
</ol>
<pre><code class="objectivec">/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 即将进入休眠
    kCFRunLoopExit         = (1UL &lt;&lt; 7), // 即将退出Loop
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};
</code></pre>
<blockquote>
<p>上面的 <em>Source/Timer/Observer</em> 被统称为 <em>mode item</em>，一个 <em>item</em> 可以同时加入多个 <em>mode</em>。但一个 <em>item</em> 被重复加入同一个 <em>mode</em> 时，是不会有效果的。如果一个 <em>mode</em> 中一个 <em>item</em> 都没有，则 <em>RunLoop</em> 会直接退出，不进入循环。</p>
</blockquote>
<h3 id="RunLoop的-Mode"><a href="#RunLoop的-Mode" class="headerlink" title="RunLoop的 Mode"></a>RunLoop的 Mode</h3><p>关于 <em>RunLoop</em> 的 <em>Mode</em> 可以通过下面的例子，展开来说，</p>
<pre><code class="objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerCurrentThread) userInfo:nil repeats:YES];
    // 将timer加入到RunLoop中
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
}

- (void)timerCurrentThread
{
    static int a = 0;
    NSLog(@&quot;当前线程%@---%d&quot;,[NSThread currentThread],a++);
}
</code></pre>
<p>这里将 <em>timer</em> 加入到 <em>RunLoop</em> 中，通过当前运行的 <em>RunLoop</em><br>观察事件的执行。这里需要注意给 <em>timer</em> 添加的是 <em>NSDefaultRunLoopMode</em> 模式。</p>
<p>那么，在上面例子的基础上，我再添加一个 <em>UITextView</em> 控件，编译运行后，当滑动控件时，发现控制台不会继续输出 <em>timerCurrentThread</em> 方法中的打印。是因为阻塞了主线程导致的吗？不是的，这里 <em>RunLoop</em> 无法同时处理屏幕触摸事件和 <em>timer</em> 回调。此时，试着将模式替换为 <em>UITrackingRunLoopMode</em>，</p>
<pre><code class="objectivec">[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];
</code></pre>
<p>再滑动 <em>UITextView</em> 控件，控制台会继续输出。结合上面的所说的一个 <em>RunLoop</em> 包含若干个 <em>Mode</em>，每个 <em>Mode</em> 又包含若干个 <em>Source/Timer/Observer</em>，例子中的关系可以这样表示，如图所示，</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/RunLoopAnalysis_02.png" alt=""></p>
<p>这里在 <em>UITrackingRunLoopMode</em>（UI模式）下的优先级最高，当通过触摸事件唤醒该模式时，当前 <em>RunLoop</em> 会忽落掉其它模式，优先处理UI模式下的事件。 同样在UI模式下，没有触摸手机屏幕时，即使有 <em>timer</em> 回调也不会继续处理，因此，当不再滑动控件时，控制台就不会再有任何输出了。如果想要兼顾默认模式和UI模式，可以这样做：</p>
<pre><code class="objectivec">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];
</code></pre>
<p>将 <em>timer</em> 同时添加到两种模式中，在触摸屏幕时(UI模式)，会处理 <em>timer</em> 回调，当不在触摸屏幕时(默认模式)，也会处理 <em>timer</em> 回调。那么有没有一种模式可以兼顾这两种模式呢？答案是肯定的。如下，</p>
<pre><code class="objectivec">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>
<p>这里的 <em>NSRunLoopCommonModes</em> (占位模式)，相当于前两种模式的叠加。</p>
<blockquote>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>— 摘录自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
</blockquote>
<p>系统默认注册了5个Mode，如下：</p>
<ol>
<li><em>NSDefaultRunLoopMode</em> 默认模式</li>
<li><em>UITrackingRunLoopMode</em> UI模式</li>
<li><em>NSRunLoopCommonModes</em> 占位模式</li>
<li>初始化模式</li>
<li>系统内核模式</li>
</ol>
<p>经常用到的是前三种模式。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><h3 id="利用-RunLoop-解决一些问题"><a href="#利用-RunLoop-解决一些问题" class="headerlink" title="利用 RunLoop 解决一些问题"></a>利用 RunLoop 解决一些问题</h3><h4 id="1-RunLoop-渲染UI-—-减少滑动卡顿"><a href="#1-RunLoop-渲染UI-—-减少滑动卡顿" class="headerlink" title="1. RunLoop 渲染UI — 减少滑动卡顿"></a>1. RunLoop 渲染UI — 减少滑动卡顿</h4><p>在 <em>tableView</em> 上加载多张高清大图时，在拖拽很快的时候，所有的图片渲染都交给 <em>RunLoop</em> 一次循环中处理掉，这样就会导致滑动时卡顿的问题。那么该如何解决呢？这里以 <em>iPhone 6s</em> 为例，<em>tableView</em> 最多一次显示18张图片，分为18次加入到 <em>RunLoop</em> 中，而不是一次。</p>
<p>具体怎么做呢？通过监听 <em>RunLoop</em> 的循环！通过 <em>observer</em> 观察活动的不同状态。具体步骤：</p>
<ul>
<li>添加观察者，观察 Runloop 循环；</li>
<li>观察状态变化；</li>
<li>将原来添加图片的代码加入到数组中</li>
<li>在 Runloop 的回调方法中，拿出数组中加载图片的代码，执行。</li>
</ul>
<p>关键代码如下：</p>
<pre><code class="objectivec">- (void)addRunloopObserver
{
    // 1. 得到runloop
    CFRunLoopRef runloop = CFRunLoopGetCurrent();
    // 2. 获取上下文
    CFRunLoopObserverContext context = {
        0,
        (__bridge void *)self,
        &amp;CFRetain,
        &amp;CFRelease,
        NULL
    };
    // 3. 创建观察者
    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(NULL, kCFRunLoopBeforeWaiting, YES, 0, &amp;callback, &amp;context);
    // 4. 添加观察者
    CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);
    // 5. 释放
    CFRelease(observer);
}

#pragma mark - 在回调里面加载图片（Runloop循环一次加载一次）
void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){

    NSLog(@&quot;%@&quot;,info);
    LoadImageViewController *vc = (__bridge LoadImageViewController *)info;
    if (vc.tasks.count == 0) {
        return;
    }

    runloopBlock taskBlock = vc.tasks.firstObject;
    taskBlock();
    [vc.tasks removeObjectAtIndex:0];
}
</code></pre>
<h4 id="2-通过-RunLoop-让-Crash-的-App-回光返照"><a href="#2-通过-RunLoop-让-Crash-的-App-回光返照" class="headerlink" title="2. 通过 RunLoop 让 Crash 的 App 回光返照"></a>2. 通过 RunLoop 让 Crash 的 App 回光返照</h4><p>由 <em>SIGABRT</em> 引起的 <em>crash</em> 是系统发这个 <em>SIGABRT</em> 给 App，程序收到这个<em>SIGABRT</em> 后，就会把主线程的 <em>RunLoop</em> 杀死，程序就挂掉了。这个例子只针对 <em>SIGABRT</em> 引起的 <em>Crash</em> 有效。</p>
<pre><code class="objectivec">CFRunLoopRef runloop = CFRunLoopGetCurrent();  
    //获取所有Mode，因为可能有很多Mode，每个Mode都需要跑，此处可以选择提交下崩溃信息之类的  
    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;程序崩溃了&quot; message:@&quot;崩溃信息&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil];  
    [alertView show];  
    NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(runloop));  
    while (1) {  
        //快速切换Mode  
        for (NSString *mode in allModes) {  
            CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);  
        }  
    }
</code></pre>
<font size="4"> 未完善Demo： <a href="https://github.com/XibHe/RunLoopCase" target="_blank" rel="external">https://github.com/XibHe/RunLoopCase</a></font>

<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>在准备写这篇博客前，第一反应就是一定要参考 <a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 两年前写的 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 这篇文章，但当花了一天时间看完 <a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 的文章后，又不知道该如何下手了？脑子里满是 <a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 博客的影子。<a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 的这篇文章简直就是 iOS 开发界的 <strong>《春江花月夜》</strong>，给人一种 <strong>“孤篇压全唐”</strong> 的感觉。</p>
<p>自己起的调太高了，为了不跑调，就只能假唱了。这篇文章中有一半内容是<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 的原话。写到最后，才发现这哪里是自己对 <strong>RunLoop</strong> 的深入理解？写的明明是自己的挣扎与不甘啊！从事 iOS 开发四年的我，又该何去何从呢？愿与诸君共勉：</p>
<blockquote>
<p>心之所向，身之所往；道阻且长，行则将至。</p>
</blockquote>
<p>最后，得知 <a href="https://blog.ibireme.com/2017/09/01/diary/#more-42043" target="_blank" rel="external">ibireme</a> 去岁身体有恙，想来现在早已康复。祝：一切安好！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
<p><a href="https://github.com/diwu/RunLoopWorkDistribution" target="_blank" rel="external">RunLoopWorkDistribution</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客介绍了使用 &lt;em&gt;WKWebView&lt;/em&gt; 进行性能调优，以及使用中遇到的问题。当在弱网环境下频繁切换 &lt;em&gt;H5&lt;/em&gt; 页面时，就会出现应用卡死的情况。&lt;a href=&quot;http://xibhe.com/2018/02/03/WKWebView-di
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="RunLoop" scheme="http://XibHe.github.io/tags/RunLoop/"/>
    
      <category term="CFRunLoopObserverRef" scheme="http://XibHe.github.io/tags/CFRunLoopObserverRef/"/>
    
  </entry>
  
  <entry>
    <title>使用WKWebView进行性能调优</title>
    <link href="http://XibHe.github.io/2018/02/03/WKWebView-disabuse/"/>
    <id>http://XibHe.github.io/2018/02/03/WKWebView-disabuse/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2018-11-18T14:01:49.939Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周，用户频繁反应一个问题：切换到某个功能页面后，加载H5页面相应时间过长，当H5页面未展示出来时，此时，再切换到其他页面，App会卡死。我们试着在公司的网络环境下复现这个问题，但并未复现。</p>
<h2 id="错误的尝试"><a href="#错误的尝试" class="headerlink" title="错误的尝试"></a>错误的尝试</h2><p>最开始时并没有意识到是webView的原因，反而因为前几天刚解决了一个UI线程的bug，将这个卡顿问题主观上当做线程问题去解决。基于此做了以下操作：</p>
<ol>
<li>增加webView加载失败的代理方法；</li>
<li>在加载完成和加载失败时，取消加载进度动画的展示；</li>
<li>在将项目中的页面替换为 <strong>WKWebView</strong> 后，发现在访问下个H5页面时，无法共享 <strong>Cookie</strong> 的问题（下面会详细说下这个问题是如何解决的），导致无法获取到已经验证成功的用户登录信息。</li>
</ol>
<p>先期采用方法1和方法2，但测试时还是会造成卡顿。后期替换为 <strong>WKWebView</strong> 后，亟待解决 <strong>Cookie</strong> 无法共享的问题，想着能不能在每次加载H5页面时，都在请求链接后面拼上用户信息的各种参数，经测试，这样做仍然无法解决页面跳转后读取用户信息的bug。而且还因每次访问页面频繁与服务器进行验证，给服务器带来了性能压力。</p>
<h2 id="问题的复现"><a href="#问题的复现" class="headerlink" title="问题的复现"></a>问题的复现</h2><p>这时考虑到用户应该是在弱网环境下进行操作，遇到的问题。于是，使用网络封包分析工具Charles模拟慢速网络。选择Throttle present：56 kbps Modem。此时，再切换页面，先切换到那个加载H5的页面，然后再来回切换其他几个页面，就会出现APP卡死的情况。(这里需要说明的是其他切换的页面有4个同样是加载H5页面，一共有8个主界面)。</p>
<p>现在问题基本可以明确了，每次加载H5页面时都要初始化webView导致了程序内存消耗过大，造成APP卡死。</p>
<h2 id="控制台报错"><a href="#控制台报错" class="headerlink" title="控制台报错"></a>控制台报错</h2><p>调试时，在程序频繁切换刷新页面直至卡死阶段，控制台一直报错，主要报错如下：</p>
<h3 id="1-Domain-NSURLErrorDomain-Code-999"><a href="#1-Domain-NSURLErrorDomain-Code-999" class="headerlink" title="1. Domain=NSURLErrorDomain Code=-999"></a>1. <strong>Domain=NSURLErrorDomain Code=-999</strong></h3><pre><code class="objectivec">&lt;LZoutsourceViewController.m : 226&gt; -[LZoutsourceViewController webView:didFailProvisionalNavigation:withError:]
2018-01-31 21:02:22.084257+0800 CloudOfficeTest[9230:4603782] error:Error Domain=NSURLErrorDomain Code=-999 &quot;(null)&quot; UserInfo={NSErrorFailingURLStringKey=http://test.net/h5/zskt/spkt.html? _WKRecoveryAttempterErrorKey=&lt;WKReloadFrameErrorRecoveryAttempter: 0x1c0822d20&gt;}
</code></pre>
<h3 id="2-NSURLConnection-finished-with-error-code-1002"><a href="#2-NSURLConnection-finished-with-error-code-1002" class="headerlink" title="2. NSURLConnection finished with error - code -1002"></a>2. <strong>NSURLConnection finished with error - code -1002</strong></h3><pre><code class="objectivec">2018-01-31 21:35:56.144596+0800 CloudOfficeTest[9301:4618465] NSURLConnection finished with error - code -1002
2018-01-31 21:36:02.742996+0800 CloudOfficeTest[9301:4618815] TIC TCP Conn Failed [14:0x1c41702c0]: 3:-9802 Err(-9802)
</code></pre>
<h3 id="3-failed-to-return-after-waiting-10-seconds-main-run-loop-mode-kCFRunLoopDefaultMode"><a href="#3-failed-to-return-after-waiting-10-seconds-main-run-loop-mode-kCFRunLoopDefaultMode" class="headerlink" title="3. failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode"></a>3. <strong>failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode</strong></h3><pre><code class="objectivec">2018-02-01 11:09:01.952689+0800 CloudOfficeTest[614:68129] void SendDelegateMessage(NSInvocation *): delegate (webView:decidePolicyForNavigationAction:request:frame:decisionListener:) failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode
</code></pre>
<p>其中，前两个错误都有错误码，分别对应</p>
<blockquote>
<p>Code=-999，NSURLErrorCancelled</p>
<p>code -1002，NSURLErrorUnsupportedURL</p>
</blockquote>
<p>-999的错误，是因为webView在之前的请求还没有加载完成，就发起了下一个请求，此时webView会取消之前的请求，因此会回调的请求失败这里。</p>
<p>这里使用的是WKWebView，因此，需要在WKWebView加载失败的代理方法里拦截掉被取消的请求。</p>
<pre><code class="objectivec">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error
{
    // code = -999，被取消什么也不干
    if ([error code] == NSURLErrorCancelled) {
        return;
    }
    NSLog(@&quot;error:%@&quot;,error);

    // 失败后的后续处理.....
}
</code></pre>
<p>第3个错误中看到了<strong>main run loop</strong>的字样，感觉很有可能是造成卡顿的元凶了。又在项目中全局搜了一下报错的这个方法，发现是使用的js与oc交互框架—<strong>WebViewJavaScriptBridge</strong>中的方法。</p>
<pre><code class="objectivec">// WebViewJavascriptBridge.m

- (void)webView:(WebView *)webView decidePolicyForNavigationAction:(NSDictionary *)actionInformation request:(NSURLRequest *)request frame:(WebFrame *)frame decisionListener:(id&lt;WebPolicyDecisionListener&gt;)listener
</code></pre>
<p>这个方法是框架<strong><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a></strong>中的方法，主要用于处理UIWebView与JS交互。到目前为止，仍然不能定位到究竟是UIWebView与JS交互时发生了什么？才导致报这个错误。只是隐隐的感觉到可能和初始化UIWebView时的内存消耗有关，毕竟WKWebView的内存消耗相比UIWebView低了一个数量级。于是，将加载会卡顿的页面替换为<strong>WKWebView</strong>来加载H5页面，通过降低频繁初始化消耗的内存，减少页面卡死的概率。但在替换后遇到一些比较棘手的问题。</p>
<h2 id="具体替换步骤"><a href="#具体替换步骤" class="headerlink" title="具体替换步骤"></a>具体替换步骤</h2><ul>
<li>引入WKWebView的代理，生成<strong>WKWebViewJavascriptBridge</strong>桥接对象</li>
</ul>
<pre><code class="objectivec">#import &quot;WKWebViewJavascriptBridge.h&quot;
#import &quot;LZWKWebKitSupport.h&quot;

@interface LZPartnerMainViewController ()&lt;WKNavigationDelegate&gt;

@property WKWebViewJavascriptBridge *jsBridge;
/**WKWebView**/
@property (nonatomic, strong) WKWebView *wkWebView;
</code></pre>
<ul>
<li>初始化WKWebView</li>
</ul>
<pre><code class="objectivec">- (void)viewDidLoad 
{
_wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:YES];
[_wkWebView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];
[self.view addSubview:_wkWebView];

self.jsBridge = [WKWebViewJavascriptBridge bridgeForWebView:_wkWebView];
[self.jsBridge setWebViewDelegate:self];

// 使用WKWebViewJavascriptBridge进行桥接，OC端注册方法，由js端进行调用
    [_jsBridge registerHandler:@&quot;testObjcCallback&quot; handler:^(id data, WVJBResponseCallback responseCallback) {
        NSLog(@&quot;data:%@&quot;,data);
        NSString *urlStr = nil;
        NSString *processIsTop = nil;
        if ([data isKindOfClass:[NSString class]]) {
            urlStr = data;
        }else{
            NSDictionary *dic = data;
            urlStr = dic[@&quot;url&quot;];
            processIsTop = dic[@&quot;processIsTop&quot;];
        }
        responseCallback(@&quot;Response from testObjcCallback&quot;);
    }];
}
</code></pre>
<p>注意，这里通过<strong>LZWKWebKitSupport</strong>来初始化一个<strong>WkWebView</strong>是为了同步Cookie，后面会具体说到为什么要同步Cookie及如何同步。</p>
<ul>
<li>设置WkWebView的代理方法</li>
</ul>
<pre><code class="objectivec">#pragma mark - WKNavigationDelegate
// 开始加载
- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation
{
    self.loadingView.hidden = NO;
    NSLog(@&quot;didCommitNavigation&quot;);
}

// 加载完成
- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation
{
    self.loadingView.hidden = YES;
    NSLog(@&quot;didFinishNavigation&quot;);
}

// 加载失败
- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error
{
    // code = -999
    if ([error code] == NSURLErrorCancelled) {
        return;
    }
    NSLog(@&quot;didFailProvisionalNavigation error.code = %ld&quot;,error.code);
}

#pragma mark - wkwebviewDelegate
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler
{
    decisionHandler(WKNavigationActionPolicyAllow);
}

//接收到服务器响应 后决定是否允许跳转，主要用来处理请求失败的情况。
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler
{
    decisionHandler(WKNavigationResponsePolicyAllow);
    NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response;

    // 读取cookies
    NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];
    for (NSHTTPCookie *cookie in cookies) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
    }

    if (response.statusCode &amp;&amp; response.statusCode != 200) {
        LZErrorHintType type = LZErrorHintType404;
        if (![[Singleton shareInstance] hasNet]) {
            type = LZErrorHintTypeNet;
        }
        __weak typeof(self) weakSelf = self;
        if (!_errorView) {
            //弹出错误界面，点击刷新按钮刷新界面
            LZErrorHintView *errorView = [[LZErrorHintView alloc] initWithFrame:self.view.bounds type:type refreshBlock:^{
                [weakSelf loadHTMLPage];
            }];
            weakSelf.errorView = errorView;
            [self.view addSubview:errorView];
        }
        return;
    }
    if ([[Singleton shareInstance] hasNet]) {
        if (_errorView) {
            [_errorView removeFromSuperview];
            _errorView = nil;
        }
    }else{
        if(!_errorView){
            __weak typeof(self) weakSelf = self;
            LZErrorHintView *errorView = [[LZErrorHintView alloc] initWithFrame:self.view.bounds type:LZErrorHintTypeNet refreshBlock:^{
                [weakSelf viewWillAppear:YES];
            }];
            _errorView = errorView;
            errorView.tag = 2200;
            [self.view addSubview:errorView];
        }
    }
}
</code></pre>
<h2 id="替换UIWebView为WKWebView后遇到的问题及解决方法"><a href="#替换UIWebView为WKWebView后遇到的问题及解决方法" class="headerlink" title="替换UIWebView为WKWebView后遇到的问题及解决方法"></a>替换UIWebView为WKWebView后遇到的问题及解决方法</h2><h3 id="1-使用WKWebViewJavascriptBridge进行桥接时，加载H5页面闪退。"><a href="#1-使用WKWebViewJavascriptBridge进行桥接时，加载H5页面闪退。" class="headerlink" title="1. 使用WKWebViewJavascriptBridge进行桥接时，加载H5页面闪退。"></a>1. 使用<strong>WKWebViewJavascriptBridge</strong>进行桥接时，加载H5页面闪退。</h3><p>这里需要更新<strong>WebViewJavaScriptBridge</strong>桥接框架中WKWebView的桥接方法，</p>
<pre><code class="objectivec">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    if (webView != _webView) { return; }
    NSURL *url = navigationAction.request.URL;
    __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate;

    if ([_base isWebViewJavascriptBridgeURL:url]) {
        if ([_base isBridgeLoadedURL:url]) {
            [_base injectJavascriptFile];
        } else if ([_base isQueueMessageURL:url]) {
            [self WKFlushMessageQueue];
        } else {
            [_base logUnkownMessage:url];
        }
        decisionHandler(WKNavigationActionPolicyCancel);
        return; 
        // 对比之前的方法，这个地方多了一个return
    }

    if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:decidePolicyForNavigationAction:decisionHandler:)]) {
        [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];
    } else {
        decisionHandler(WKNavigationActionPolicyAllow);
    }
}
</code></pre>
<h3 id="2-WKWebView加载完网页后，点击里面的按钮，不跳转的问题。"><a href="#2-WKWebView加载完网页后，点击里面的按钮，不跳转的问题。" class="headerlink" title="2. WKWebView加载完网页后，点击里面的按钮，不跳转的问题。"></a>2. WKWebView加载完网页后，点击里面的按钮，不跳转的问题。</h3><p>设置WKWebView的另一个代理WKUIDelegate，从名称能看出它是webView在user interface上的代理，</p>
<pre><code class="objectivec">// 创建新的webView
// 可以指定配置对象、导航动作对象、window特性。如果没用实现这个方法，不会加载链接，如果返回的是原webview会崩溃。
-(WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures
{
if (!navigationAction.targetFrame.isMainFrame) {
    [webView loadRequest:navigationAction.request];
}
    return nil;
}
</code></pre>
<p>要调用下面的方法是有条件的，WKNavigationDelegate中的该方法是用户点击网页上的链接，需打开新页面时，将先调，是否允许跳转到链接。</p>
<pre><code class="objectivec">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler｛
 WKFrameInfo *sFrame = navigationAction.sourceFrame;//navigationAction的出处
 WKFrameInfo *tFrame = navigationAction.targetFrame;//navigationAction的目标
//只有当  tFrame.mainFrame == NO；时，表明这个 WKNavigationAction 将会新开一个页面。
// 才会调用createWebViewWithConfiguration这个代理方法。
｝
</code></pre>
<p>这样就新开一个webView，如果我们只是显示网页，这样会消耗性能，没有必要。</p>
<h3 id="3-如何同步WKWebView的Cookie"><a href="#3-如何同步WKWebView的Cookie" class="headerlink" title="3. 如何同步WKWebView的Cookie"></a>3. <font color="#FF0000">如何同步WKWebView的Cookie</font></h3><p>在将UIWebView替换为WKWebView后加载速度提高了，页面卡死的问题基本没有再出现过。但遇到了一个更加棘手的问题，之前使用的是UIWebView，它会对首次加载H5页面后的用户登录信息进行同步，这样我由当前的H5页面跳转到一个新的UIWebView进行请求时，会自动找到上个页面同步的用户信息，从而加载当前用户对应的内容。</p>
<blockquote>
<p><strong>WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。</strong></p>
</blockquote>
<p>因此，如何实现多个 <strong>WKWebView</strong> 之间共享 <strong>Cookie</strong>（session Cookie and persistent Cookie）数据。是决定能否继续使用<strong>WKWebView</strong>的关键。如果不能解决这个问题，就只能再继续使用之前的 <strong>UIWebView</strong> 了，之前所做的一切都没有用处了。</p>
<p>解决多个 <strong>WKWebView</strong> 之间共享 <strong>Cookie</strong> 的问题，首先要弄明白三个问题？</p>
<ol>
<li><strong>WKWebView</strong> 与 <strong>webView</strong> 在 <strong>Cookie</strong> 设置，读取上有什么不同？</li>
<li><strong>WKWebView</strong> 会将对应的 <strong>Cookie</strong> 存在什么地方？</li>
<li>如何取到 <strong>WKWebView</strong> 的 <strong>Cookie</strong> 并将其注入到要访问的下一个 <strong>WKWebView</strong> 中？</li>
</ol>
<p>结合以上三个问题，在网上搜索很多关于 <strong>WKWebView</strong> 的 <strong>Cookie</strong> 存储在什么地方？ 这些资料普遍认为 <strong>WKWebView</strong> 拥有自己的私有存储，不会将 <strong>Cookie</strong> 存入到标准的 <strong>Cookie</strong> 容器 <strong>NSHTTPCookieStorage</strong> 中。但在实际项目中，却发现 <strong>WKWebView</strong> 实例可以读取到存储于 <strong>NSHTTPCookieStorage</strong> 中的 <strong>Cookie</strong>。最后，看到了<a href="https://bugly.qq.com/v2/" target="_blank" rel="external">腾讯Bugly</a>的一篇技术文章 —- <a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>，也印证了我的观点。</p>
<blockquote>
<p>实践发现 WKWebView 实例其实也会将 Cookie 存储于 NSHTTPCookieStorage 中，但存储时机有延迟，在iOS 8上，当页面跳转的时候，当前页面的 Cookie 会写入 NSHTTPCookieStorage 中，而在 iOS 10 上，JS 执行 document.cookie 或服务器 set-cookie 注入的 Cookie 会很快同步到 NSHTTPCookieStorage 中。</p>
</blockquote>
<p>看来以后搜索技术文章，不能太片面了，一定要结合一些大厂的权威技术文章来具体分析。</p>
<p>下一步，就是如何在发起请求时注入 通过 <strong>NSHTTPCookieStorage</strong> 获取的<strong>Cookie</strong>。网上关于 <strong>WKWebView</strong> 的 <strong>Cookie</strong> 注入方法有以下几种:</p>
<ol>
<li><strong>JS</strong>注入 —- 在初始化 <strong>WKWebView</strong> 的时候，通过 <strong>WKUserScript</strong> 设置，使用<strong>javascript</strong> 注入 <strong>Cookie</strong>，一开始发送 <strong>NSMutableURLRequest</strong> 请求的时候也要加上 <strong>Cookie</strong>，并且保证两个地方的设置的cookie一致。参考 — <a href="https://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview" target="_blank" rel="external">Can I set the cookies to be used by a WKWebView?</a></li>
<li><strong>WKHTTPCookieStore</strong> —- 利用 <strong>iOS11 API WKHTTPCookieStore</strong> 解决 <strong>WKWebView</strong> 首次请求不携带 <strong>Cookie</strong> 的问题。参考 — <a href="https://helpcdn.aliyun.com/knowledge_detail/60199.html" target="_blank" rel="external">iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明</a></li>
<li>利用 <strong>iOS11</strong> 之前的 API 解决 <strong>WKWebView</strong> 首次请求不携带 <strong>Cookie</strong> 的问题。参考 — <a href="https://helpcdn.aliyun.com/knowledge_detail/60199.html" target="_blank" rel="external">iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明</a></li>
<li>通过让所有 <strong>WKWebView</strong> 共享同一个 <strong>WKProcessPool</strong> 实例，可以实现多个 <strong>WKWebView</strong> 之间共享 <strong>Cookie（session Cookie and persistent Cookie）</strong> 数据。不过 <strong>WKWebView WKProcessPool</strong> 实例在 app 杀进程重启后会被重置，导致 <strong>WKProcessPool</strong> 中的 <strong>Cookie</strong>、<strong>session Cookie</strong> 数据丢失，目前也无法实现 <strong>WKProcessPool</strong> 实例本地化保存。</li>
</ol>
<p>方法1，经过测试行不通，可能是后台读取 <strong>Cookie</strong> 的方式有问题；方法2，是 <strong>iOS 11</strong> 的 <strong>API</strong> ，不具有普适性；方法3，在测试时无法通过 <strong>url</strong> 匹配到 <strong>Cookie</strong>；最后，只剩下方法4了，需要注意在特殊场景下 <strong>Cookie</strong> 丢失的情况：</p>
<blockquote>
<p>app 杀进程重启后会被重置，导致 <strong>WKProcessPool</strong> 中的 <strong>Cookie</strong>、<strong>session Cookie</strong> 数据丢失，目前也无法实现 <strong>WKProcessPool</strong> 实例本地化保存。</p>
</blockquote>
<p>但以我们的应用为例，哪怕是主动杀进程，重新打开应用；还是应用突然闪退，重新打开应用。首次加载某个含有用户登录验证的H5页面时，需要在发起请求的地方拼上用户特定信息的参数，因此，即使之前存储的 <strong>Cookie</strong> 数据丢失了，也会在首次加载时重新获取。如下：</p>
<pre><code class="objectivec">Singleton *sin = [Singleton shareInstance];
NSString *baseIpPort = [LZUserDefaults objectForKey:PreferenceKey_SystemInit_ZyPartnerIPPort];
NSString *urlString = [[NSString stringWithFormat:@&quot;%@/test1/test2?Id=%@&amp;Name=%@&amp;Pid=%@&quot;,baseIpPort,sin.clinicId,[LZUserDefaults objectForKey:PreferenceKey_Name],[LZUserDefaults objectForKey:PreferenceKey_Pid]] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];
request.HTTPMethod = @&quot;POST&quot;;
request.timeoutInterval = 15.0f;
[_wkWebView loadRequest:request];
</code></pre>
<p>因此，对于 <strong>APP</strong> 重启后 <strong>Cookie</strong> 数据可能丢失的情况，难道不可以在首次加载H5页面时，重新获取一下用户登录信息的 <strong>Cookie</strong> 吗？对我而言，现在的项目就是这样做的。</p>
<h2 id="通过-WKProcessPool-实现多个-WKWebView-之间共享-Cookie"><a href="#通过-WKProcessPool-实现多个-WKWebView-之间共享-Cookie" class="headerlink" title="通过 WKProcessPool 实现多个 WKWebView 之间共享 Cookie"></a>通过 WKProcessPool 实现多个 WKWebView 之间共享 Cookie</h2><h3 id="1-新建一个名为-LZWKWebKitSupport-的类，用于生成一个统一的，全局使用同一个-WKProcessPool-的-WKWebView-对象。"><a href="#1-新建一个名为-LZWKWebKitSupport-的类，用于生成一个统一的，全局使用同一个-WKProcessPool-的-WKWebView-对象。" class="headerlink" title="1. 新建一个名为 LZWKWebKitSupport 的类，用于生成一个统一的，全局使用同一个 WKProcessPool 的 WKWebView 对象。"></a>1. 新建一个名为 <strong>LZWKWebKitSupport</strong> 的类，用于生成一个统一的，全局使用同一个 <strong>WKProcessPool</strong> 的 <strong>WKWebView</strong> 对象。</h3><pre><code class="objectivec">// LZWKWebKitSupport.h

#import &lt;Foundation/Foundation.h&gt;
#import &lt;WebKit/WebKit.h&gt;

@interface LZWKWebKitSupport : NSObject
@property (nonatomic, strong,readonly) WKProcessPool *processPool;
+ (instancetype)sharedSupport;
+ (WKWebView *)createSharableWKWebView:(BOOL)isFullScreen isShowNav:(BOOL)showNav;
@end
</code></pre>
<pre><code class="objectivec">// LZWKWebKitSupport.m
#import &quot;LZWKWebKitSupport.h&quot;
@interface LZWKWebKitSupport()
@end

@implementation LZWKWebKitSupport
+ (instancetype)sharedSupport {
    static LZWKWebKitSupport *_instance;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [LZWKWebKitSupport new];
    });
    return  _instance;
}

- (instancetype)init {
    if (self = [super init]) {
        self.processPool = [WKProcessPool new];
    }
    return self;
}

+ (WKWebView *)createSharableWKWebView:(BOOL)isFullScreen isShowNav:(BOOL)showNav
{
    WKUserContentController* userContentController = [WKUserContentController new];
    NSMutableString *cookies = [NSMutableString string];
    WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:[cookies copy]                                                        injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
    [userContentController addUserScript:cookieScript];    
    WKWebViewConfiguration *configuration = [WKWebViewConfiguration new];
    // 一下两个属性是允许H5视频自动播放,并且全屏,可忽略
    configuration.allowsInlineMediaPlayback = YES;
    configuration.mediaPlaybackRequiresUserAction = NO;
    // 全局使用同一个processPool
    configuration.processPool = [[LZWKWebKitSupport sharedSupport] processPool];
    configuration.userContentController = userContentController;
    // 考虑到左侧菜单栏，需要设置webView的不同frame
    WKWebView *wk_webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, y, width, height) configuration:configuration];

    return wk_webView;
}
@end
</code></pre>
<h3 id="2-在加载H5的地方初始化-LZWKWebKitSupport，并在-WKNavigationDelegate-中获取-cookie，并设置到本地。"><a href="#2-在加载H5的地方初始化-LZWKWebKitSupport，并在-WKNavigationDelegate-中获取-cookie，并设置到本地。" class="headerlink" title="2. 在加载H5的地方初始化 LZWKWebKitSupport，并在 WKNavigationDelegate 中获取 cookie，并设置到本地。"></a>2. 在加载H5的地方初始化 <strong>LZWKWebKitSupport</strong>，并在 <strong>WKNavigationDelegate</strong> 中获取 <strong>cookie</strong>，并设置到本地。</h3><pre><code class="objectivec">// 初始化LZWKWebKitSupport
- (void)viewDidLoad{
_wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:YES];
[self.view addSubview:_wkWebView];
}
</code></pre>
<pre><code class="objectivec">#pragma mark - wkwebviewDelegate
//接收到服务器响应 后决定是否允许跳转
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler
{
    decisionHandler(WKNavigationResponsePolicyAllow);
    NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response;
    // 读取cookie，并设置到本地
    NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];
    for (NSHTTPCookie *cookie in cookies) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
    }
}
</code></pre>
<h3 id="3-在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。"><a href="#3-在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。" class="headerlink" title="3. 在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。"></a>3. 在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。</h3><p>这里以跳转到 <strong>LZDetailViewController</strong> 页面为例，先是通过<strong>LZWKWebKitSupport</strong> 初始化一个 <strong>WKWebView</strong></p>
<pre><code class="objectivec">// LZDetailViewController.m
- (void)viewDidLoad {
    [super viewDidLoad];
    //初始化视图
    [self setUpSubViews];   
}

- (void)setUpSubViews{
    _wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:NO];
    _wkWebView.UIDelegate = self;
    [self.view addSubview:_wkWebView];
    _jsBridge = [WKWebViewJavascriptBridge bridgeForWebView:_wkWebView];
    [_jsBridge setWebViewDelegate:self];
}
</code></pre>
<p>然后在加载请求时，注入之前设置的 <strong>Cookie</strong></p>
<pre><code class="objectivec">- (void)loadUrl{
    if (!_urlStr) {
        return;
    }

    NSURL *url = [NSURL URLWithString:_urlStr];
    NSMutableString *cookies = [NSMutableString string];
    NSMutableURLRequest *requestObj = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15.0];
    // 一般都只需要同步BJSESSIONID,可视不同需求自己做更改
    NSString * BJSESSIONID;
    // 获取本地所有的Cookie
    NSArray *tmp = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];
    for (NSHTTPCookie * cookie in tmp) {
        if ([cookie.name isEqualToString:@&quot;BJSESSIONID&quot;]) {
            BJSESSIONID = cookie.value;
            break;
        }
    }
    if (BJSESSIONID.length) {
        // 格式化Cookie
        [cookies appendFormat:@&quot;BJSESSIONID=%@;&quot;,BJSESSIONID];
    }
    // 注入Cookie
    [requestObj setValue:cookies forHTTPHeaderField:@&quot;Cookie&quot;];
    // 加载请求
    [self.wkWebView loadRequest:requestObj];
}
</code></pre>
<p>通过以上三步就可以达到同步 <strong>Cookie</strong> 的目的，现在看来之前通过 <strong>JS脚本</strong> 注入 <strong>Cookie</strong> 失败，可能是由于后台需要同步 <strong>BJSESSIONID</strong>，而<strong>BJSESSIONID</strong> 是 <strong>HtppOnly</strong>，不允许通过js脚本修改。</p>
<p>最后，需要特别注意的一点是：<font color="#FF0000">考虑在加载H5页前，是否需要清除某些H5页面的 <strong>Cookie</strong> ? </font></p>
<p>这里对于我们的项目而言，加载的需要验证用户身份信息的H5页面，是需要清除 <strong>Cookie</strong> 的，因为用户的权限不同，所看到的界面就不同，在同一台设备下切换不同的用户时，如果不清除之前的 <strong>Cookie</strong>，所展示的就是上一个用户的信息。</p>
<pre><code class="objectivec">- (void)deleteWKCookies
{
    // 清除WKWebView缓存的cookie(根据ip)
    if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 9.0){

        NSString *iPPort = [LZUserDefaults objectForKey:PreferenceKey_SystemInit_ZyIPPort];
        NSArray *iPPortArray = [iPPort componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@&quot;/&quot;]];
        NSString *recordIP;
        if ([iPPortArray count] &gt; 2) {
            recordIP = partnerIPPortArray[2];
        }

        WKWebsiteDataStore *dateStore = [WKWebsiteDataStore defaultDataStore];
        [dateStore fetchDataRecordsOfTypes:[WKWebsiteDataStore allWebsiteDataTypes] completionHandler:^(NSArray&lt;WKWebsiteDataRecord *&gt; * __nonnull records) {
            for (WKWebsiteDataRecord *record  in records)
            {
                // 以www.baidu.com为例，是否包含baidu.com
                if ([recordIP containsString:record.displayName])
                {
                    [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:record.dataTypes forDataRecords:@[record] completionHandler:^{
                        NSLog(@&quot;Cookies for %@ deleted successfully&quot;,record.displayName);
                    }];
                }
            }
        }];
    }
}
</code></pre>
<h2 id="WebView性能优化总结"><a href="#WebView性能优化总结" class="headerlink" title="WebView性能优化总结"></a>WebView性能优化总结</h2><p>一个加载网页的过程中，native、网络、后端处理、CPU都会参与，各自都有必要的工作和依赖关系；让他们相互并行处理而不是相互阻塞才可以让网页加载更快：</p>
<ul>
<li>WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。</li>
<li>后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。</li>
<li>脚本执行慢，就让脚本在最后运行，不阻塞页面解析。</li>
<li>同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。</li>
<li>WebView初始化慢，就随时初始化好一个WebView待用。</li>
<li>DNS和链接慢，想办法复用客户端使用的域名和链接。</li>
<li>脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。</li>
</ul>
<p>上面是美团点评技术团队关于<a href="https://tech.meituan.com/WebViewPerf.html" target="_blank" rel="external">WebView性能优化</a>的总结。</p>
<p>对比我们项目中有哪些页面用到了 <strong>UIWebView</strong>，哪些用到了 <strong>WKWebView</strong>，发现当前程序中一共有8个主要模块，其中，一共有4个主要模块是通过加载H5页面展示的，还有一个模块中部分嵌套了H5页面。这些页面中，有三个页面使用 <strong>WkWebView</strong> 加载，剩下的使用的是 <strong>UIWebView</strong> 加载页面，发生卡顿的页面多是频繁初始化 <strong>UIWebView</strong> 加载H5时发生的。</p>
<p>这里我们的项目中使用<strong>UIWebView</strong> 和 <strong>WKWebView</strong> 的地方有很多，没有一个管理类去居中调控的话，后期维护起来会很耗时，而且很容易出现bug。下一步的优化就是要构建这样一种集构建，配置，分发，操控为一身的通用类。</p>
<h2 id="Apple-Staff-的建议"><a href="#Apple-Staff-的建议" class="headerlink" title="Apple Staff 的建议"></a>Apple Staff 的建议</h2><p>关于在 <strong>WKwebView</strong> 中如何获取 <strong>Cookies</strong>，苹果的工程师也给出了建议<br>（<strong>May 11, 2017 1:40 AM</strong>）</p>
<blockquote>
<p>There isn’t a solution that works in all cases, alas.  All the approaches I know of have issues:</p>
<ul>
<li>NSHTTPCookieStorage isn’t reliable because WKWebView does all of its networking in a separate process, so you can’t get at the NSHTTPCookieStorage object being used by the web view.</li>
<li>JavaScript (like the WKUserScript example you referenced) doesn’t see any cookies tagged with HttpOnly.</li>
<li>WKWebsiteDataStore lets you know of the existence of the cookie but doesn’t let you get the contents.</li>
<li>The delegate approach you showed (which I’d not seen before, so brav{o,a} for your creativity!) won’t see all the cookies because not all responses are navigation responses.</li>
</ul>
<p>Under normal circumstances I’d recommend that you file an <a href="https://developer.apple.com/bug-reporting/" target="_blank" rel="external">enhancement request</a> requesting a better approach for this, but in this case I happen to know that WebKit Engineering is well aware of this issue (r. 31024691).<br>Right now the only approach that works in all cases is to use UIWebView, which is obviously less than ideal.</p>
</blockquote>
<p>但最后也提到了：目前，在所有情况下唯一有效的方法是使用 <strong>UIWebView</strong>，但这显然是不太理想的方案，和使用 <strong>WKWebView</strong> 的初衷相违背。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tech.meituan.com/WebViewPerf.html" target="_blank" rel="external">WebView性能、体验分析与优化</a></p>
<p><a href="https://developer.apple.com/documentation/webkit/wknavigationdelegate/1455641-webview?language=objc" target="_blank" rel="external">webView:decidePolicyForNavigationAction:decisionHandler:</a></p>
<p><a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a></p>
<p><a href="https://helpcdn.aliyun.com/knowledge_detail/60199.html" target="_blank" rel="external">iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明</a></p>
<p><a href="https://developer.apple.com/documentation/webkit/wknavigationdelegate/1455641-webview?language=objc" target="_blank" rel="external">Developer wknavigationdelegate documentation</a></p>
<p><a href="https://forums.developer.apple.com/thread/50057" target="_blank" rel="external">WKWebView and UIWebView Cookie</a></p>
<p><a href="https://forums.developer.apple.com/thread/77279" target="_blank" rel="external">How to get all cookies from WKWebView</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一周，用户频繁反应一个问题：切换到某个功能页面后，加载H5页面相应时间过长，当H5页面未展示出来时，此时，再切换到其他页面，App会卡死。我们试着在公司的网络环境下复现这个问题，但并未复现。&lt;/p&gt;
&lt;h2 id=&quot;错误的尝试&quot;&gt;&lt;a href=&quot;#错误的尝试&quot; cla
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="wkWebView" scheme="http://XibHe.github.io/tags/wkWebView/"/>
    
      <category term="webView性能调优" scheme="http://XibHe.github.io/tags/webView%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>2017年度总结</title>
    <link href="http://XibHe.github.io/2017/12/30/2017deadline/"/>
    <id>http://XibHe.github.io/2017/12/30/2017deadline/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-12-31T14:08:55.938Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间2017就要结束了，回首过去的一年，有过彷徨，有过不安，也有收获的感动与喜悦。过完17年我就拥有四年开发经验了，一直觉得四到五年的阶段是区别高级开发与初中级开发的分水岭。但这并不使我感到高兴，我深知这四年时光中一多半是在蹉跎中度过的。往之不谏，来者可追！2018！我来了。</p>
<h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p>对我这个年龄来说，结婚的很少，更别提孩子了。但我已经为人夫，为人父了！似乎用两三年的时间走完了别人十几年的路。太过年轻的我，总会时不时忘记自己身为父亲的责任，我媳妇(花花)总会不厌其烦的唤起我作为父亲该承担的责任。家里的大事小情，在花花的安排下井井有条。孩子的奶粉，尿不湿也不用我来操心，为了分担我的压力，花花早早给儿子断了母乳，离家挣钱。对花花我即心疼又愧疚，我不能一直用年轻作为借口，逃避身为男人的责任。<strong>家庭永远是第一位</strong>！</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/2017deadline_1.jpg" alt=""></p>
<blockquote>
<p>每个人都有属于自己的人生遥控器，它无时无刻不掌握在你自己的手中，你可以随时按快进键让时间从你的手中逃走，你也可以按回退键，想想自己曾经的错过与失误，你也可以按跳过键，它的另外一个名字叫做逃避…… 从前有个精灵一直在寻找彩虹那端的金罐，但最后，他发现那只是一罐麦片。</p>
</blockquote>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>年初给自己定下了一个目标：每周至少写一篇博客。到目前为止，算上这篇，一共是25篇。这25篇文章中，有5篇是译文，5篇是个人感悟，剩下15篇是技术上的分享。技术上的分享有些很肤浅，和大咖们由浅入深的技术文章比起来有些相形见绌。但我还是会坚持写下去的，须知泰山非一日之功。</p>
<p>写一篇鞭辟入里的爽文真的很费时间，前期需要阅读大量的相关文章，技术文档。最难得还是将所要描述的知识点与实际的代码，产品需求结合起来。因此，当你在自己的项目中解决了一个棘手的bug，或者实现了一个复杂的产品需求时，你再将这些解决问题的方案写成博客，就会有一种“下笔如有神”的感觉。就好比最近写了一篇名为<a href="http://xibhe.com/2017/11/06/JenKins-Continuous-Integration/" target="_blank" rel="external">利用JenKins持续集成iOS项目时遇到的问题</a>博文，通篇写下爱特别顺畅。因为这些流程都是我切身经历过得，在这里也只是再复述一篇操作流程而已。</p>
<p>相比之下这篇文章 — <a href="http://xibhe.com/2017/11/26/AF3.x/" target="_blank" rel="external">AFNetworking到底做了什么？</a> 写起来就不那么顺利，自己没有切实经历过，整个<strong>AFNetworking</strong>的源码，马马虎虎的读了两遍，不能透彻理解其中的精髓。也只能转载别人的观点。</p>
<p>自从给自己定下了一周至少写一篇博客的目标后，每到周末就特纠结，搜肠刮肚的想着如何结合实际开发构思出一篇好博文。有时实在没有好的点子，就翻译<strong>Medium</strong>和<strong>湾区日报</strong>上推荐的英文文章，或者写一些个人心得体会。</p>
<p>今年写的一些技术性文章也有不尽如人意的地方，有些文章，写的很粗浅，没有刨根问底追溯到本质上。有些文章是迫于一周要写一篇博文而拼凑成的，今年不会如此只求量而不求质了。但以文字的形式记录分享开发心得的习惯，一旦养成，就不会轻易舍弃，这算是2017年一个明显的收获吧！</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年看完了<font size="4" face="黑体">《图解HTTP》</font>、<font size="4" face="黑体">《黑客与画家》</font>、<font size="4" face="黑体">《软技能:代码之外的生存指南》</font>。正在看的有<font size="4" face="黑体">《人类简史》</font>、<font size="4" face="黑体">《啊哈!算法》</font>。看<font size="4" face="黑体">《啊哈!算法》</font>时，看的快忘得也快，还是没有结合实践，将书上的算法，用代码实现一遍。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/hacker-artist.jpg" alt="黑客与画家"></p>
<p>在这些书中，<font size="4" face="黑体">《黑客与画家》</font>这本书书对我启发最大，里面很多论述让我有种醍醐灌顶的感觉。现在回想起来，书中很多内容已经忘得差不多了，唯一记得的是：编程和绘画一样，是需要走心的，需要绞尽脑汁去构思的。</p>
<p>偶然在知乎上看到<strong><a href="https://www.zhihu.com/question/32039257" target="_blank" rel="external">你是怎么看完《JavaScript权威指南》《JavaScript高级程序设计》等这类厚书的？</a></strong>的提问，摘录其中一个赞同数最高的回答：</p>
<blockquote>
<p>与其说看书不如说看目录，从目录里找到感兴趣的章节，看掉，看到中途没兴趣了，就放下下次再看。工作中碰到什么问题不明白需要参考了，还是看目录，才大概会在什么章节里，探索一番，中间如果碰到感兴趣的，看掉，看到中间没兴趣了，放下，下次再看。要不了多久，整本书的70%-80%都翻遍了，其中有20%-30%翻了不止一遍，这些往往是核心的知识；至于剩下的20%没看过的，以后或许有机会的，没机会也不要紧，很多时候自己已经通过各种机缘学到了。</p>
<p>所以看技术厚书不在于多块或多慢，而是从容。</p>
</blockquote>
<p>其中，我认为结合书中知识点，<strong>理论联系实践</strong>是最为有效的掌握知识点的方法。读一些非技术的书籍，最重要的是能够让自己心安。</p>
<blockquote>
<p>此心安处是吾乡</p>
</blockquote>
<p>关于买书，今年没有买一本书。因为去年买的书，大概有七八本吧！只看完了三本，还有向公司申请采购的3本技术书籍，手中库存的书足够我看了。2018年在此立一个flag：<strong>看完6本书！</strong></p>
<h2 id="新部门"><a href="#新部门" class="headerlink" title="新部门"></a>新部门</h2><p>今年12月份时被调到一个新部门，开始接触到公司最为核心的项目。想想就有些小激动啊！因此，也会给自己提出更高的要求，写功能模块时要注意与其他功能的耦合性，兼顾需要考虑程序的性能，容错机制的相应。现有的开发模式，耦合性太高，如何实现高可用的组件化，降低功能模块间的耦合性？将是我们这个团队在18年需要重点考录的问题。希望能为这次项目模块的优化重构尽自己的一份力量。</p>
<h2 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h2><p>9月初接触微信小程序，和部门另外两个H5一起开发公司的一款小程序。中间吃了小程序产品原型还是是基于原生App思维而设计的亏，同时，也由于自己没有完全吃透小程序开发文档，在实现一些功能时踩了<a href="http://xibhe.com/2017/09/25/wx-mini-AppSummary/" target="_blank" rel="external">坑</a>。</p>
<p>这次小程序开发经历使我意识到自己的技术短板，陷入对技术的狂热之中。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。</p>
<blockquote>
<p>请勿陷入对技术的狂热之中</p>
</blockquote>
<p>若是早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不再积极进取，不再学习新技术。这种开发者被称为“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/introspect2.jpg" alt=""></p>
<p>2018年，新的一年，要在原有技术的基础之上找到突破口，将自己以前囫囵吞枣的知识点再好好品味一番。同时，也不能仅仅局限于iOS一方面的技术。</p>
<p>今年最直观的感觉是自己对于新技术的渴望，缺少那种如饥食渴的痴迷感。苹果开发者大会上的ARKit，CoreML，SiriKit这些新技术，对于我这个iOS开发者竟然毫无吸引力可言。这是我身上存在的一个大的缺陷，也是程序员堕落，不思进取的开始。<strong>对于程序员来说，最大的悲哀并不是35岁后被华为辞退，也不是42岁后跳楼。</strong> 而是：</p>
<blockquote>
<p>不再向往新技术。</p>
</blockquote>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/2017deadline_3.jpg" alt=""></p>
<blockquote>
<p>stay hungry，stay foolish.</p>
</blockquote>
<h2 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h2><p>家人朋友身体健康，自己技术日臻成熟。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间2017就要结束了，回首过去的一年，有过彷徨，有过不安，也有收获的感动与喜悦。过完17年我就拥有四年开发经验了，一直觉得四到五年的阶段是区别高级开发与初中级开发的分水岭。但这并不使我感到高兴，我深知这四年时光中一多半是在蹉跎中度过的。往之不谏，来者可追！2018！我来
    
    </summary>
    
      <category term="随笔" scheme="http://XibHe.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="2017" scheme="http://XibHe.github.io/tags/2017/"/>
    
      <category term="年度总结" scheme="http://XibHe.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>(译)创业就是要发起一场思想运动</title>
    <link href="http://XibHe.github.io/2017/12/09/Build%20a%20Movement/"/>
    <id>http://XibHe.github.io/2017/12/09/Build a Movement/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2018-11-11T07:51:04.505Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个创业者，我并不喜欢和开发者在午餐时间发生争论。</p>
<p>”这是胡说，“我们的首席技术官回复。“MailChimp的产品并不比其他产品好，这只是另一个发送消息的通讯工具而已。当它竞争对手提供同样的功能只需要花费几块钱时，为什么每月要额外花费200美元呢？“</p>
<p>我想说服他，MailChimp确保我们的电子邮件广告系列投递到顾客的收件箱，而不是他们的垃圾邮件文件夹。</p>
<p>但是他一直用我没有完全明白的技术解释来反驳我。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/mailchimp-hp-1.png" alt=""></p>
<p>“看，我们甚至可以建立我们自己的电子邮件机器人，做同样的事情，”他补充说。“你只是因为他们的品牌知名才使用它。”</p>
<p>是的，在一定程度上他说的很对。</p>
<p>在过去的几年中，MailChimp已经建立了一个标志性的品牌以其设计为中心的方法和非传统的营销活动。</p>
<p>猴子吉祥物<a href="https://blog.mailchimp.com/the-story-behind-the-mailchimp-billboards/" target="_blank" rel="external">广告牌</a>没有提到他们的名字…“MailKimp”和参与其他趣味取名活动达到了<a href="https://twitter.com/benchestnut/status/871678778782756864" target="_blank" rel="external">3.34亿人</a>…以设计为中心的<a href="https://mailchimp.com/2016/" target="_blank" rel="external">年度报告</a>与风格…</p>
<p>MailChimp的赠品也是非常规的。为猫咪准备的免费<a href="https://blog.drift.com/how-mailchimp-grew/" target="_blank" rel="external">猴子帽子</a>打动了像我一样准备付更多钱的超级粉丝。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/banner-compressor-1.jpg" alt=""></p>
<p>在一个任何人都可以一夜之间复制你的产品的世界里，MailChimp选择为猫咪编织猴子帽子，而不是进行军备竞赛建立更多的功能。</p>
<p>毕竟，公司甚至还接到一些大客户的<a href="https://medium.com/swlh/an-open-letter-to-mailchimp-8497318fc860" target="_blank" rel="external">公开信</a>和<a href="https://tinyletter.com/ben/letters/whale-hunting-or-scale-hunting" target="_blank" rel="external">警告</a>，如果没有更高级的功能，就有可能转向竞争对手。</p>
<p>MailChimp的回答？</p>
<blockquote>
<p>重点打造品牌客户的爱心。</p>
</blockquote>
<p>当我们接近2017年年底时，从未在<a href="https://www.nytimes.com/2016/10/06/technology/mailchimp-and-the-un-silicon-valley-way-to-make-it-as-a-start-up.html" target="_blank" rel="external">外部资金</a>上花费一分钱的电子邮件创业公司正在准备结束令人兴奋的增长达1500万客户的一年。</p>
<p>但是猴子生意足够了。</p>
<p>让我们着眼大局，了解这对初创企业如何在当今混乱的世界取得成功意味着什么：</p>
<ol>
<li><p><strong>你不必扰乱整个行业:</strong>尽管许多企业家正忙于构建下一个Uber或Facebook，但这是一个我们需要消除的神话。MailChimp并没有打乱任何一个行业，但它却在一个日益拥挤的市场上建立起了猴王国。</p>
</li>
<li><p><strong>如果你不打扰或创造一个全新的市场，</strong>你仍然可以在竞争激烈的行业里建立一个帝国:而且它涉及越来越多的超级粉丝，他们虔诚地跟随你的运动，即使你收取溢价，或者拒绝参加建立更多特征的军备竞赛，仍然会推荐你的品牌。</p>
</li>
</ol>
<p>但是，秘密是什么？</p>
<p>你如何接触民众，发展你的粉丝俱乐部，让你按自己的规则玩游戏，而不用担心竞争？</p>
<p><strong>选择各不相同，但一些世界上最成功的创业公司使用两个强大的战略:</strong></p>
<p>首先显然是“MailChimp方式”，即，将您的产品推销为高品质的品牌。正如他的创始人<a href="https://tinyletter.com/ben/letters/whale-hunting-or-scale-hunting" target="_blank" rel="external">Ben Chestnut</a>解释的那样:</p>
<blockquote>
<p>我们为商业客户制作应用程序，使用低价位的零件，然后以高质量，以设计为中心，可爱的B2C品牌推广应用程序。</p>
</blockquote>
<p>但是越来越多的蓬勃发展的创业公司使用另一种策略 - 不一定需要以设计为中心的方法。</p>
<p>它需要反过来影响人的思维：</p>
<p><strong>不要扰乱一个行业，扰乱思想</strong></p>
<p>正如马克·博切克（Mark Bonchek）在他广受欢迎的<a href="https://hbr.org/2014/07/dont-sell-a-product-sell-a-whole-new-way-of-thinking" target="_blank" rel="external">哈佛杂文</a>中所强调的那样：</p>
<blockquote>
<p>成功销售和销售创新的公司能够改变人们，不仅关注他们的产品，而且关心他们自己，市场和世界的想法。</p>
<p>不要销售产品，销售一种全新的思维方式。</p>
</blockquote>
<p>拿<a href="https://www.drift.com/" target="_blank" rel="external">Drift</a>来说，今天科技界的新星之一。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/drift-homepage-1.png" alt=""></p>
<p>并不是强迫人们理解他们的产品，像Drift这样的“推动者”<strong>推销思想的根本转变，即，引起他们创新的原始洞察力。</strong></p>
<p>对Drift而言，最初的洞察力导致了营销和销售方式的破旧，仍然依赖网站形式和烦人的销售后续行动。</p>
<p>这就是为什么，他们没有硬去销售或用产品信息淹没<a href="https://blog.drift.com/" target="_blank" rel="external">他们的博客</a>，而是谈论<a href="https://blog.drift.com/introducing-ilya-mirman/" target="_blank" rel="external">今天的营销和销售技巧</a>是怎样的，或者为什么<a href="https://blog.drift.com/why-g-joined-drift/" target="_blank" rel="external">营销自动化</a>和<a href="https://blog.drift.com/why-email-is-broken/" target="_blank" rel="external">电子邮件营销</a>被打破。</p>
<blockquote>
<p>这与你的价值主张不同。这是一个关于世界如何运作的假设（通常是无意识的），“Bonchek补充道。</p>
</blockquote>
<p>当你将其视为模板时，该逻辑很容易应用于任何创业项目：</p>
<blockquote>
<p>我们支持[插入]，并将人们思考[插入]的方式转变为[插入]。</p>
</blockquote>
<p>例如，Drift支持新的营销和销售方式，将人们对营销和销售的看法转变为更多的谈话驱动，个性化和人性化。</p>
<p>另外两家标志性公司–Basecamp和Salesforce也在重新思考现有的心智模式方面处于领先地位。</p>
<ul>
<li><p>Basecamp的创始人通过倡导“非硅谷之路”，改变人们对<a href="https://m.signalvnoise.com/on-being-a-bad-manager-e56e1fb3d9dc" target="_blank" rel="external">管理</a>，<a href="https://m.signalvnoise.com/wait-you-dont-control-your-calendar-3a40f8f642fe" target="_blank" rel="external">生产力</a>，<a href="https://m.signalvnoise.com/whats-an-hour-d5966ee5ad7d" target="_blank" rel="external">时间</a>，<a href="https://m.signalvnoise.com/exponential-growth-devours-and-corrupts-c5562fbf131" target="_blank" rel="external">增长</a>或<a href="https://m.signalvnoise.com/reconsider-41adf356857f" target="_blank" rel="external">创业公司运作方式</a>的看法，来壮大自己的超级粉丝。</p>
</li>
<li><p>Salesforce捍卫“无软件”的口号，将思想从打包的安装软件转移到云计算和软件即服务。</p>
</li>
</ul>
<p><strong>建立一个改变人们思维的引擎</strong></p>
<p>改变人们目前的思维模式不是一朝一夕就能实现的。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/dhh.png" alt=""></p>
<p>相反，你将需要一个可持续的引擎，一次又一次地<strong>在不同的环境和情况下向人们展示新的心智模式。</strong></p>
<p>例如，尽管Drift的博客每月已经超过了10万人，他们打开新的渠道，达到他们无法达到的观众，否则他们不会通过：</p>
<ul>
<li><p><strong>他们一年一度的“<a href="https://hypergrowth.drift.com/" target="_blank" rel="external">超级增长</a>”会议</strong>，专门讨论营销和销售的未来;</p>
</li>
<li><p><strong>他们的“<a href="https://itunes.apple.com/us/podcast/seeking-wisdom/id1072506427" target="_blank" rel="external">寻找智慧</a>”播客</strong>，通过音频对话传播他们的信息。</p>
</li>
</ul>
<p>像Drift一样，Basecamp的创始人们建立了一个多渠道的引擎，通过他们的畅销书，如’<a href="https://www.amazon.com/Rework-Jason-Fried/dp/0307463745" target="_blank" rel="external">返工</a>‘，他们的<a href="https://m.signalvnoise.com/" target="_blank" rel="external">流行博客</a>和<a href="https://rework.fm/" target="_blank" rel="external">播客</a>来接触新的人。</p>
<p>尽管如此，建立一个引导人们去思考新的思维方式的方法并不是保留给创业公司的。</p>
<p>像GE这样的大公司已经认识到他们称之为<strong>“市场份额之前的分享”</strong>的重要性。</p>
<p>GE的首席营销官<a href="https://hbr.org/2014/07/innovation-is-marketings-job-too" target="_blank" rel="external">Beth Comstock解释</a>了为什么他们大量投资于内容引擎:</p>
<blockquote>
<p>真正好的创新需要在被接受之前得到解释……这意味着成为一家内容工厂 - 从数据到视频，再到社交媒体，讲述媒体和方法的故事。</p>
</blockquote>
<p><strong>MailChimp的方式，Drift的方式，或着你的方式</strong></p>
<p>从博主到创业创始人，今天的制作者们都越来越关注：</p>
<blockquote>
<p>噪音太大，竞争如此激烈。</p>
</blockquote>
<p>像SaaS这样的空间变得<a href="https://hitenism.com/copycat-competitors-take-market/" target="_blank" rel="external">越来越有竞争力</a>，公司觉得他们差不多是在<a href="https://www.groovehq.com/blog/commoditization" target="_blank" rel="external">出售商品</a>，或者他们的产品可以在一夜之间复制。</p>
<p>这就是为什么在今天这个历史上<a href="https://medium.com/swlh/how-to-start-a-blog-in-the-most-cluttered-marketplace-in-history-ef50db328a09" target="_blank" rel="external">最混乱的市场</a>上，建立一场运动比以往任何时候都重要。</p>
<p>建立它，以MailChimp方式，漂移的方式，或你的方式。不管你采取什么样的路线，在企业中有一个与自己相得益彰的要素是一致的：对自己忠实。</p>
<p>对于MailChimp来说，这意味着推出非常规的营销活动，<a href="https://mailchimp.com/did-you-mean/" target="_blank" rel="external">故意错误地发音</a>他们的名字：</p>
<blockquote>
<p>我们相信与客户建立关系的最好方式就是成为你自己。</p>
<p>对我们来说，这意味着我们的名字有乐趣。</p>
</blockquote>
<p>对于Drift来说，这意味着在他们的首席营销官和首席执行官之间进行诚实的交谈 虽然世界上充斥着假装看起来专业的播客，Drift的非正式播客风格是“<a href="https://itunes.apple.com/us/podcast/seeking-wisdom/id1072506427?mt=2" target="_blank" rel="external">寻求智慧</a>”拥有忠实粉丝的原因之一。</p>
<p>正如Basecamp的创始人所<a href="https://www.amazon.com/Rework-Jason-Fried/dp/0307463745" target="_blank" rel="external">指出</a>的那样，倾注于自己的产品是一种从人群中脱颖而出的有力方式：</p>
<blockquote>
<p>如果你成功了，人们会试着复制你所做的。但是有一个很好的方法来保护自己免受抄袭：</p>
<p>让你成为你的产品或服务的一部分。注入你对销售方式的独特看法。</p>
<p>把自己投入到产品和产品周围：你是如何销售的，你是如何提供产品支持的，你是如何向顾客解释产品的，以及你是如何交付产品的。</p>
<p>竞争者永远不能复制你的产品。</p>
</blockquote>
<p>这对生意有好处。</p>
<p>-</p>
<p>不要建立一个初创公司，而是发起一场运动 - 从第一天开始。</p>
<p>如果你做得对，像我这样的超级粉丝可能会自愿花午餐时间，因采用你提供的方案而与他人进行激烈的讨论。</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="http://growthsupply.com/build-startup-movement/" target="_blank" rel="external">Don’t Build a Startup, Build a Movement</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个创业者，我并不喜欢和开发者在午餐时间发生争论。&lt;/p&gt;
&lt;p&gt;”这是胡说，“我们的首席技术官回复。“MailChimp的产品并不比其他产品好，这只是另一个发送消息的通讯工具而已。当它竞争对手提供同样的功能只需要花费几块钱时，为什么每月要额外花费200美元呢？“&lt;/p
    
    </summary>
    
      <category term="译文" scheme="http://XibHe.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="译文" scheme="http://XibHe.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="创业" scheme="http://XibHe.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking到底做了什么？</title>
    <link href="http://XibHe.github.io/2017/11/26/AF3.x/"/>
    <id>http://XibHe.github.io/2017/11/26/AF3.x/</id>
    <published>2017-11-25T16:00:00.000Z</published>
    <updated>2018-11-11T07:47:33.445Z</updated>
    
    <content type="html"><![CDATA[<p>最近在对接一个demo，主要是调用一下SDK，实现一些功能。发现这个demo的网络请求部分是基于<strong>NSURLConnection</strong>做的一些简单调用。用起来感觉总是怪怪的，于是就想切换回自己一直在用的<strong>AFNetworking</strong>。结果，和我想的还是不太一致。同时，也暴露出一个严重的问题：对<strong>AFNetworking</strong>实现原理，到底做了什么？可以说是一窍不通。之前一直以为对<strong>AFNetworking</strong>很熟悉了，现在看来，也只是停留在调用<strong>AFHTTPSessionManager</strong>的表面。</p>
<p><strong>NSURLSession</strong>， <strong>NSURLSessionDataTask</strong>这两个类是iOS做网络请求的核心类，而AFNetworking则是对其做了一系列封装，简化了使用系统原生API做网络请求的过程。</p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>更新记录:</p>
<ul>
<li>2017 年 11 月，第一版。</li>
<li>2017 年 12 月，对具体的步骤进行归类整理。</li>
</ul>
<p>对<strong>AFNetworking</strong>调用是做了一层简单的封装，将请求时用到的各种参数在一个继承自NSObject的类中统一配置。如下，</p>
<pre><code class="objectivec">+ (void)postWithUrl:(NSString*)url params:(NSDictionary*)params  success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure
{
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
    [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
    manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间
    manager.responseSerializer = [AFJSONResponseSerializer serializer];
    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@&quot;text/html&quot;];
    [manager POST:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

        NSDictionary *bodyObjDic = [responseObject objectForKey:@&quot;body&quot;];
        CLog(@&quot;bodyObjDic = %@&quot;,bodyObjDic);
        NSString *code = [bodyObjDic objectForKey:@&quot;code&quot;];
        CLog(@&quot;url = %@,code = %@&quot;,url,code);
        if ([code isEqualToString:@&quot;200&quot;]) {
            if(success)
                success ([responseObject objectForKey:@&quot;body&quot;]);
        } else if(code == nil){
            NSError *error = [NSError errorWithDomain:@&quot;请求错误&quot; code:-1 userInfo:nil];
            if(failure)
                failure(error);
        }

    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        if([@&quot;NSURLErrorDomain&quot; isEqualToString:error.domain]){
            error = [NSError errorWithDomain:@&quot;请监测您的网络环境&quot; code:error.code  userInfo:nil];
        }
        if([@&quot;NSCocoaErrorDomain&quot; isEqualToString:error.domain]){
            error = [NSError errorWithDomain:@&quot;服务器繁忙，请稍候重试&quot; code:error.code userInfo:nil];
        }
        if(failure)
            failure(error);
    }];
}
</code></pre>
<p>再将所有用于请求的url都放在这个类的类别中，统一管理。如下，</p>
<pre><code class="objectivec">/**
 注册接口
 */
+ (void)getRegistedWithParams:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure
 {
     [self postWithUrl:[NSString stringWithFormat:@&quot;%@&quot;,kILVBHost] params:params success:^(id JSON) {
        if(success){
            success(JSON);
        }
    } failure:^(NSError *error) {
        if(failure){
            failure(error);
        }
    }];
 }
</code></pre>
<p>demo在网络请求时，会将参数转换并设置到<strong>HTTPBody</strong>中，上面那种直接使用<strong>AFHTTPSessionManager</strong>进行POST请求的方式就不行，其无法在请求时将请求的参数设置到request的HTTPBody中。于是，尝试通过新建一个<strong>NSMutableURLRequest</strong>请求，通过设置它的<strong>HTTPBody</strong>到达目的。如下，</p>
<pre><code class="objectivec">+ (void)postWithUrl:(NSString*)url params:(NSDictionary*)params  success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure
{
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
    [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
    manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间
    manager.responseSerializer = [AFJSONResponseSerializer serializer];
    NSError *requestError = nil;
    NSMutableURLRequest *request = [manager.requestSerializer requestWithMethod:@&quot;POST&quot; URLString:url parameters:params error:&amp;requestError];
    request.HTTPBody = [NSData data];
    [manager.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        CLog(@&quot;data = %@,response = %@&quot;,data,response);
    }];
}
</code></pre>
<p>但请求时会报500的错误。看来还需要接着往深了抛，看看<strong>AFNetworking</strong>到底做了什么？</p>
<p>这里之所以会设置<strong>manager.requestSerializer</strong>为：</p>
<pre><code class="objectivec">[manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
[manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
</code></pre>
<p>是将<strong>NSMutableURLRequest</strong>与<strong>manager.requestSerializer</strong>混为一谈了。</p>
<p>demo中通过<strong>NSMutableURLRequest</strong>设置相应的请求头的属性值，如下：</p>
<pre><code class="objectivec">NSURL *URL = [NSURL URLWithString:url];
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];

if (data){
 [request setValue:[NSString stringWithFormat:@&quot;%ld&quot;,(long)[data length]] forHTTPHeaderField:@&quot;Content-Length&quot;];
 [request setHTTPMethod:@&quot;POST&quot;];
 [request setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
 [request setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
 [request setHTTPBody:data];        
}
</code></pre>
<p>而<strong>manager.requestSerializer</strong>用于设置<strong>AFHTTPRequestSerializer</strong>(请求参数解析类)的，之所以会报解析或者服务器先关错误，是由于没有设置网络请求的解析方式导致。而<strong>responseSerializer</strong>默认使用了JSON的解析方式，这也是为什么当使用AFN进行网络请求时，JSON会自动进行解析的原因。这里如果想进行默认的request和response序列化，就要在manager的默认设置完成之后，在开始进行网络访问前使用：</p>
<pre><code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
manager.requestSerializer = [AFJSONRequestSerializer serializer];
manager.responseSerializer = [AFJSONResponseSerializer serializer];
</code></pre><p>即可实现返回数据的自动解析。</p>
<h2 id="AFNetworking到底做了什么？"><a href="#AFNetworking到底做了什么？" class="headerlink" title="AFNetworking到底做了什么？"></a>AFNetworking到底做了什么？</h2><h3 id="AFNetworking概述"><a href="#AFNetworking概述" class="headerlink" title="AFNetworking概述"></a>AFNetworking概述</h3><p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/AFN_articlex.png" alt=""><br><a href="https://draveness.me/afnetworking1" target="_blank" rel="external">图片所在原文链接</a></p>
<p>AF分为如下5个功能模块：</p>
<ul>
<li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li>
<li>网络通信信息序列化/反序列化模块(Serialization)</li>
<li>网络状态监听模块(Reachability)</li>
<li>网络通信安全策略模块(Security)</li>
<li>对于iOS UIKit库的扩展(UIKit)</li>
</ul>
<p>AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的上层封装。而其余的四个模块，均是为了配合AFURLSessionManager类的网络通信做一些必要的处理工作。如上图，所示。</p>
<p>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager去做。 </p>
<p><a href="https://www.jianshu.com/p/856f0e26279d" target="_blank" rel="external">以上内容原文链接</a></p>
<h3 id="对外接口类AFHTTPSessionManager"><a href="#对外接口类AFHTTPSessionManager" class="headerlink" title="对外接口类AFHTTPSessionManager"></a>对外接口类AFHTTPSessionManager</h3><p>AFHTTPSessionManager不做实事，只是提供了对外调用的接口。</p>
<ul>
<li>调用父类方法进行初始化</li>
</ul>
<pre><code class="objectivec">- (instancetype)initWithBaseURL:(NSURL *)url
           sessionConfiguration:(NSURLSessionConfiguration *)configuration
{
    self = [super initWithSessionConfiguration:configuration];
    if (!self) {
        return nil;
    }
    //....
    return self;
}
</code></pre>
<ul>
<li>类似网络请求方法中，调用父类方法拿到task，这个类仅仅是把得到的task，resume即可</li>
</ul>
<pre><code class="objectivec"> NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;                                                   URLString:URLString parameters:parameters uploadProgress:nil                                             downloadProgress:downloadProgress                                                        success:success                                                       failure:failure];
 // 开始任务
 [dataTask resume];
</code></pre>
<ul>
<li>AFHTTPSessionManager还做了一件很重要的事，就是把传过来的参数，编码成我们请求时需要的<strong>request</strong>，并且传给父类去做网络请求。</li>
</ul>
<p>NSURLSession， NSURLSessionDataTask</p>
<pre><code class="objectivec">NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];
</code></pre>
<h3 id="AFNetworking请求核心类：AFURLSessionManager"><a href="#AFNetworking请求核心类：AFURLSessionManager" class="headerlink" title="AFNetworking请求核心类：AFURLSessionManager"></a>AFNetworking请求核心类：AFURLSessionManager</h3><p><strong>NSURLSessionDataTask,</strong><br>AFHTTPSessionManager的初始化方法，触发了这个类所有的初始化<br>初始化方法：</p>
<pre><code class="objectivec">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration；
</code></pre>
<pre><code class="objectivec">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    self = [super init];
    if (!self) {
        return nil;
    }

    if (!configuration) {
        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    }

    self.sessionConfiguration = configuration;

    self.operationQueue = [[NSOperationQueue alloc] init];
    // queue并发线程数为1，这个是代理回调的queue
    self.operationQueue.maxConcurrentOperationCount = 1;

    // 注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法。
    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    // 各种响应转码
    self.responseSerializer = [AFJSONResponseSerializer serializer];

    // ssl证书，是验证证书，还是公钥，还是不用
    self.securityPolicy = [AFSecurityPolicy defaultPolicy];

#if !TARGET_OS_WATCH
    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
#endif

    // 设置存储NSURL，task与AFURLSessionManagerTaskDelegate的词典（重点，在AF中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理）
    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

    // 设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全
    self.lock = [[NSLock alloc] init];
    self.lock.name = AFURLSessionManagerLockName;

    // 为所管理的session的所有task设置完成块,此方法为生成session之后就调用
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {

    // 置空处理
        for (NSURLSessionDataTask *task in dataTasks) {
            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];
        }

        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
        }

        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
        }
    }];

    return self;
}
</code></pre>
<p>这个方法初始化了一些我们后续需要用到的属性，其他的都很简单，唯一比较费解的两处可能是：</p>
<pre><code class="objectivec">self.operationQueue.maxConcurrentOperationCount = 1;

[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
       //置空处理
 }];
</code></pre>
<p>我们首先来讲讲这两个操作的作用：</p>
<ul>
<li><p>第一是让回调的代理queue是串行的，即请求完成的task只能一个个被回调。</p>
</li>
<li><p>第二是清空了session中所有task。</p>
</li>
</ul>
<pre><code class="objectivec">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {

    // 第一件事，创建NSURLSessionDataTask，里面适配了Ios8以下taskIdentifiers，函数创建task对象。
    __block NSURLSessionDataTask *dataTask = nil;

    // 其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理
    url_session_manager_create_task_safely(^{
        dataTask = [self.session dataTaskWithRequest:request];
    });

    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];

    return dataTask;
}
</code></pre>
<p>类似这个类中很多方法这样的方法，这些方法主要做两件事：</p>
<ol>
<li>调用session的方法，传request过去去生成task。注意这里调用了<strong>url_session_manager_create_task_safely</strong>函数去执行的Block,这个函数实现如下：</li>
</ol>
<pre><code class="objectivec">static void url_session_manager_create_task_safely(dispatch_block_t block) {
    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {
        dispatch_sync(url_session_manager_creation_queue(), block);
    } else {
      block();
    }
}
</code></pre>
<p>简单来讲就是为了适配iOS8以下task创建，其中taskIdentifiers属性不唯一，而这个属性是我们之后添加代理的key，它必须是唯一的。 所以这里做了一个判断，如果是iOS8以下，则用串行同步的方式去执行这个Block，也就是创建session。否则直接执行。</p>
<ol>
<li><strong>给每个task创建并对应一个AF的代理对象，这基本上是这个类的核心所在了</strong>，这个代理对象为其对应的“task做数据拼接及成功回调。</li>
</ol>
<p>方法如下：</p>
<pre><code class="objectivec">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
    // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系
    delegate.manager = self;
    delegate.completionHandler = completionHandler;
    // 这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应
    dataTask.taskDescription = self.taskDescriptionForSessionTasks;

    // 将AF delegate对象与 dataTask建立关系
    [self setDelegate:delegate forTask:dataTask];

    // 设置AF delegate的上传进度，下载进度块
    delegate.uploadProgressBlock = uploadProgressBlock;
    delegate.downloadProgressBlock = downloadProgressBlock;
}
</code></pre>
<p>将<strong>AF delegate</strong>对象与<strong>dataTask</strong>建立关系</p>
<pre><code class="objectivec">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
            forTask:(NSURLSessionTask *)task
{
    // 断言，如果没有这个参数，debug下crash在这
    NSParameterAssert(task);
    NSParameterAssert(delegate);

    // 加锁保证字典线程安全
    [self.lock lock];

    // 将AF delegate放入以taskIdentifier标记的字典中（同一个NSURLSession中的taskIdentifier是唯一的）
self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;

    // 为AF delegate 设置task 的progress监听
    [delegate setupProgressForTask:task];

    // 添加task开始和暂停的通知
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}
</code></pre>
<p>以上两个方法创建了一个AFURLSessionManagerTaskDelegate的代理，把这个代理和task的taskIdentifier一一对应，放到我们最早初始化的字典里，建立起映射。</p>
<p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，这些代理开始调用了：</p>
<p><strong>NSURLSessionDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
didBecomeInvalidWithError:(NSError *)error；

- (void)URLSession:(NSURLSession *)session
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler;
</code></pre>
<p><strong>NSURLSessionTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
willPerformHTTPRedirection:(NSHTTPURLResponse *)response
        newRequest:(NSURLRequest *)request
 completionHandler:(void (^)(NSURLRequest *))completionHandler；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
 needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error；
</code></pre>
<p><strong>NSURLSessionDataDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didReceiveResponse:(NSURLResponse *)response
 completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler；

- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask；

- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data；

- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
 willCacheResponse:(NSCachedURLResponse *)proposedResponse
 completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler；
</code></pre>
<p> <strong>NSURLSessionDownloadDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location；

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite；

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 didResumeAtOffset:(int64_t)fileOffset
expectedTotalBytes:(int64_t)expectedTotalBytes；
</code></pre>
<ul>
<li><p>AFURLSessionManager一共实现了如上所列举的一大堆NSUrlSession相关的代理。</p>
</li>
<li><p>而只转发了其中3条到AF自定义的delegate中：</p>
</li>
</ul>
<p><strong>NSURLSessionTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(__unused NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error;
</code></pre>
<p><strong>NSURLSessionDataTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(__unused NSURLSession *)session
          dataTask:(__unused NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data;
</code></pre>
<p><strong>NSURLSessionDownloadTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location;
</code></pre>
<p>AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p>
<p>总结一下，这些代理主要是做了一些额外的处理，并且调用了它的属性Block：</p>
<pre><code class="objectivec">@interface AFURLSessionManager ()
@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;
@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;
@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;
@end
</code></pre>
<p>等属性……</p>
<p>我们可以利用这些Block，做一些自定义的处理，Block会随着代理调用而被调用，这些代理帮我们做了一些类似数据分片、断点续传、https认证等工作</p>
<p>除此之外，有3个代理方法回调了我们的task的AF代理，包括<strong>请求完成</strong>的代理，<strong>收到数据</strong>的代理，以及<strong>下载完成</strong>的代理，以第一个为例：</p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
{
   // 根据task去取我们一开始创建绑定的delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];

    // delegate may be nil when completing a task in the background
    if (delegate) {
    // 把代理转发给我们绑定的delegate
        [delegate URLSession:session task:task didCompleteWithError:error];
    // 转发完移除delegate 
       [self removeDelegateForTask:task];
    }
    // 公用Block回调
    if (self.taskDidComplete) {
        self.taskDidComplete(session, task, error);
    }
}
</code></pre>
<p>通过我们之前设置的task和AF代理映射，去调用AF代理，并且把这个task从映射字典中移除。</p>
<p>接着就调用了AF的代理：(自定义代理3条中的一条)</p>
<pre><code class="objectivec">// AF实现的代理！被从urlsession那转发到这
- (void)URLSession:(__unused NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error
{

 // 强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block 
    __strong AFURLSessionManager *manager = self.manager;

    __block id responseObject = nil;

   // 用来存储一些相关信息，来发送通知用的
    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
   // 存储responseSerializer响应解析对象
    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;

    // Performance Improvement from #2672
    // **注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存** 
    NSData *data = nil;
    if (self.mutableData) {
        data = [self.mutableData copy];
        //We no longer need the reference, so nil it out to gain back some memory.
        self.mutableData = nil;
    }

    // 继续给userinfo填数据
    if (self.downloadFileURL) {
        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
    } else if (data) {
        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;
    }
    // 错误处理
    if (error) {
        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;

    // 可以自己自定义完成组 和自定义完成queue,完成回调
        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
            if (self.completionHandler) {
                self.completionHandler(task.response, responseObject, error);
            }
     // 主线程中完成通知
            dispatch_async(dispatch_get_main_queue(), ^{
                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
            });
        });
    } else {
        dispatch_async(url_session_manager_processing_queue(), ^{
            NSError *serializationError = nil;

            // 解析数据
            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];

            // 如果是下载文件，那么responseObject为下载的路径
            if (self.downloadFileURL) {
                responseObject = self.downloadFileURL;
            }

            // 写入userInfo
            if (responseObject) {
         userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
            }
           // 如果解析错误
            if (serializationError) {
                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
            }
           // 回调结果
            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
                if (self.completionHandler) {
                    self.completionHandler(task.response, responseObject, serializationError);
                }

                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
                });
            });
        });
    }
}
</code></pre>
<p>虽然这个方法有点长，但是它主要做了两件事：</p>
<ol>
<li><p>调用responseSerializer按照我们设置的格式，解析请求到的数据。</p>
</li>
<li><p>用completionHandler把数据回调出去，至此数据回到了用户手中。</p>
</li>
</ol>
<p>到这里，AF的整个主线流程就完了，当然，我们跳过了很多细节没有讲，比如responseSerializer的各种格式的解析过程，还有为了监听task的开始和挂起通知，所做的<strong>method swizzling</strong>，这里对iOS7的兼容问题的处理，算是相当精彩了。</p>
<p><a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="external">以上内容原文链接</a></p>
<h3 id="处理请求和响应：AFURLSerialization"><a href="#处理请求和响应：AFURLSerialization" class="headerlink" title="处理请求和响应：AFURLSerialization"></a>处理请求和响应：AFURLSerialization</h3><p>对发出请求以及接收响应的过程进行序列化，这涉及到两个模块：</p>
<ul>
<li>AFURLResponseSerialization</li>
<li>AFURLRequestSerialization</li>
</ul>
<p>前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。<br>我们首先会对 <strong>AFURLResponseSerialization</strong> 进行简单的介绍，因为这个模块使用在 <strong>AFURLSessionManager</strong> 也就是核心类中，而后者 <strong>AFURLRequestSerialization* 主要用于 </strong>AFHTTPSessionManager** 中，因为它主要用于修改 HTTP 头部。</p>
<p>有关解析类的详情见原文：</p>
<p><a href="https://draveness.me/afnetworking3#AFURLRequestSerialization" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三)</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本来想自己写关于AFN的使用心得，但发现自己的水平有限，不能把AFN主要做了什么？它是如何实现网络请求和解析的？这些问题说明白。只能将大牛文章中的精彩内容粘贴出来，做了一个简短的整理。这里引述<a href="https://www.jianshu.com/u/14431e509ae8" target="_blank" rel="external">涂耀辉</a>在<a href="https://www.jianshu.com/p/7ed7c0be15b4" target="_blank" rel="external">AFNetworking到底做了什么? (终)</a>一文中所说的一句话：</p>
<blockquote>
<p>AFNetworking中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.v2ex.com/amp/t/358780" target="_blank" rel="external">如何使用 AFNetworking 3.0 设置 Request.HttpBody</a> </p>
<p><a href="http://www.jianshu.com/p/856f0e26279d" target="_blank" rel="external">AFNetworking到底做了什么？</a> </p>
<p><a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="external">AFNetworking到底做了什么？(二)</a></p>
<p><a href="https://draveness.me/afnetworking1" target="_blank" rel="external">AFNetworking 概述（一）</a></p>
<p><a href="https://draveness.me/afnetworking3#AFURLRequestSerialization" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在对接一个demo，主要是调用一下SDK，实现一些功能。发现这个demo的网络请求部分是基于&lt;strong&gt;NSURLConnection&lt;/strong&gt;做的一些简单调用。用起来感觉总是怪怪的，于是就想切换回自己一直在用的&lt;strong&gt;AFNetworking&lt;/s
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="AFNetworking" scheme="http://XibHe.github.io/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>(译)软件开发这份工作到了35岁之后就是尽头了吗</title>
    <link href="http://XibHe.github.io/2017/11/19/dead-end%20job%20/"/>
    <id>http://XibHe.github.io/2017/11/19/dead-end job /</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2018-11-11T07:53:30.436Z</updated>
    
    <content type="html"><![CDATA[<p>我想你会问3个不同的问题，也许应该修改一下这个问题。我们来分解一下吧：</p>
<ol>
<li>年龄歧视是软件开发行业中的问题吗？</li>
<li>你应该把自己的职业转向管理角色，而不是个人开发者角色吗？</li>
<li>软件开发个人开发者是一个死胡同吗？</li>
</ol>
<p>在Quora上关于这些问题的提问，每个问题都有详细的回答，其中细节如上所述，所以我将简要地讨论每个问题。</p>
<p>对于年龄歧视，我不认为有人会否认这个行业有一定的年龄歧视。你可以看看几乎所有硅谷公司的新员工的平均年龄。我怀疑，大多数中等雇佣年龄远低于30。然而，这并不一定意味着官方的公司政策不会雇用超过一定年龄，种族，性别，性别偏好或其他特征的候选人。</p>
<p>为什么在高科技产业中存在年龄歧视，原因是多方面的，并非是所有公司一起商量好不雇用年长员工。一方面，许多公司发现，使用新的大学毕业生（麻省理工学院和斯坦福大学等）作为招聘的主要对象是最容易的。新毕业生便宜。他们有一个稳定的质量。他们不受其他公司经验的束缚。他们是一张白纸，比较容易教他们企业文化，软件方法论，最佳实践，并与参与其他业务的新毕业相互配合工作。</p>
<p>我认为，硅谷的任何人都不会认为，如果你有一个在相关技术方面拥有3年扎实编程经验的候选人（加上也是有名望的毕业生），不是一个好的候选人。事实上，我甚至可以说N年开发经验并不重要，没有确切的说明，有N年相关经验的候选人比N + 1年经验的候选人要好，所有其他因素是平等的，技能 以及与公司正在进行的业务相关的经验。</p>
<p>对于工程师来说，保持相关性的技术变化太快的说法可能是一回事，但是构建网络的核心技术已经存在了几十年了。C语言早在七十年代末就出现了，已近有将近四十多年的历史了。Javascript语言，第一次出现在1997年，大概是20年前。这意味着几十年开发经验的工程师，他们的工作已经接近退休年龄，整个职业生涯一直专注于C和运行Unix服务器。这样的工程师非常少，有这么多的经验，但是我怀疑有谁会试图宣称刚刚毕业的22岁的人肯定比60岁的人好，相比之下，他们的一些人已近专研了40多年技术。当然，这些类型的工程师很少。</p>
<p>因此，对于问题的另一方面，我不认为软件工程是一个死胡同的事业。我想说的是，在薪酬增长方面，在一定的时间之后，它会趋于稳定。部分原因就是工程师本质上是人为的商品。除非你是一个非常特别的工程师，事实上，你总是可以被其他人取代。与其他竞争性行业相比，我认为这有助于保持软件工程工资水平。不过，我几乎可以保证，对软件工程师的需求将超过应聘者中新毕业生或其他人的供应，所以你总能找到工作。不过，你可能不会每年收到那些10％的指数提升，就像你两三年前那样。</p>
<p>最后，关于转为管理者是否是一个更好的选择，我想问为什么只考虑这个选项？当然有许多职业道路可供选择。你可以转换到另一个工程领域。例如，许多不喜欢创造产品的软件工程师会转移到其他角色，有时在同一个公司，例如运营，产品管理，项目管理，质量保证，或者更少的技术，如销售或行政职位。我也有一些完全改变职业的朋友，比如全职教学。</p>
<p>最后让我说，以为自己为例，在和那些具有扎实工程背景的经理人员一起工作时，我很欣赏他们，最好是与公司相关技术的软件工程，所以请不要急于进入工程管理的职业道路。对于我们这些将来可能不得不与你打交道的人，作为开发者，可以获得5年或6年的良好工程实践经验。了解这个行业是如何运作的，作为一个经验丰富的开发者。只有这样，才能考虑把你的职业转向管理方向。就像你不会雇用花店来建造布鲁克林大桥。同样也不会聘请没有任何开发经验的人担任项目经理。</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://www.quora.com/Is-software-development-really-a-dead-end-job-after-age-35-40/answer/Jeff-Nelson-32?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website" target="_blank" rel="external">Is software development really a dead-end job after age 35-40?</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想你会问3个不同的问题，也许应该修改一下这个问题。我们来分解一下吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;年龄歧视是软件开发行业中的问题吗？&lt;/li&gt;
&lt;li&gt;你应该把自己的职业转向管理角色，而不是个人开发者角色吗？&lt;/li&gt;
&lt;li&gt;软件开发个人开发者是一个死胡同吗？&lt;/li&gt;

    
    </summary>
    
      <category term="译文" scheme="http://XibHe.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="译文" scheme="http://XibHe.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="职业生涯" scheme="http://XibHe.github.io/tags/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title>凌冬将至</title>
    <link href="http://XibHe.github.io/2017/11/11/introspect/"/>
    <id>http://XibHe.github.io/2017/11/11/introspect/</id>
    <published>2017-11-10T16:00:00.000Z</published>
    <updated>2018-11-11T07:56:58.586Z</updated>
    
    <content type="html"><![CDATA[<p>至此光棍节来临之际，祝各位光棍们节日快乐，年年无今日，岁岁无今朝，早日脱单。最近一个月不是很忙，之前做的项目在8月中旬停了下来，项目是停了下来，但整个项目组却闲不下来。九月份接手了一个新需求，为公司的另一个项目开发录入药品的小程序。工期算上测试、发布大概是二十天。这中间虽然是第一次接触小程序开发，最后，跌跌撞撞的总算是顺利上线了。</p>
<p>开发小程序的这段时间，总是有些难熬，自己之前并没有HTML、CSS、JavaScript的基础，在w3cschool上看了两天的HTML、CSS基础，就硬着头皮上了。不过还好有一个前端老司机带着，一起踩踩小程序的坑。在前两年前端很火的时候，我就很想跟风学习一下了，但总是给自己找各种理由。最后，学习计划就不了了之了。这次的学习动机来的如此强烈，看来只有<strong>将自己的学习动力与工作中的业务需求捆绑起来，才能迈出这第一步</strong>。</p>
<p>随着开发的深入，不得不惊讶于小程序<strong>“用完即走”</strong>的设计理念。与移动端APP相比，小程序真的很小，开发成本小的多。不得不感慨，移动开发的凌冬将至，或许早已来临了。苹果的光环正在消退，不只是iOS开发，没有哪种技术是长盛不衰的，对所有的与技术相关的开发者而言:</p>
<blockquote>
<p>请勿陷入对技术的狂热之中</p>
</blockquote>
<p>自从今年以来，发现了自己的技术短板。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。</p>
<p>最近两年以来，互联网的发展不再像早期那样粗放了，对各种技术人员的需求趋于稳定。<strong>“一招鲜，吃遍天”</strong>的时代终会落幕，全栈会成为一种趋势。不只贫穷会限制我们的想象力，作为一名开发者，我们因对某项技术的狂热崇拜也会限制我们在业务需求上的想象力。应戒之，慎之。</p>
<p>但无论如何增加知识广度的同时，先扪心自问自己所擅长技术是否全面掌握了。拿我自己来说，也有四年多 iOS 开发经验了，但做的项目都是很普通的那种。这里并不是说普通项目不能提高开发水平，相对于那些业务逻辑复杂的项目，其复杂的关联业务、交互设计会早早的暴露出性能方面的问题，因此，开发者不得不从各方面考虑，最终深入研究这些技术点，并形成最终的优化方案。而普通应用很少遇到性能上的瓶颈，开发者也早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不在积极进取。我管这种开发者叫“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/introspect1.png" alt=""></p>
<p>这也是很多初级中级 iOS 开发者的共性，没有深入某一具体的方向解决对应的问题，没有自己的技术深度。当我们被全栈开发这种趋势追赶着拼命向前奔命，花费时间、精力学习那些新技术时，需要反思自己有没有达到所擅长领域的技术深度，对掌握的知识，是肤浅还是真正的精通。</p>
<p><img src="https://xibhe.oss-cn-beijing.aliyuncs.com/introspect2.jpg" alt=""></p>
<p>互联网发展非常快，每天每个月都有很多的新技术面世。在我们朝着全栈一路狂奔时，需要思考为什么要用这个技术？它能解决什么问题？有什么弊端吗？为了技术而技术，考虑问题的全面性就会差很多。裹足不前不行，盲目追新亦是不行，这里很考验我们对新技术的判断，最终这些技术都要对应业务场景，或许多经历几次因业务需求变化而导致的通宵加班，彻夜上线才会让开发者有所反思，经历几次痛苦的重构才会刻骨铭心吧！</p>
<p>但无论如何，凌冬将至，大家过冬的粮食都储备充足了吗？</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;至此光棍节来临之际，祝各位光棍们节日快乐，年年无今日，岁岁无今朝，早日脱单。最近一个月不是很忙，之前做的项目在8月中旬停了下来，项目是停了下来，但整个项目组却闲不下来。九月份接手了一个新需求，为公司的另一个项目开发录入药品的小程序。工期算上测试、发布大概是二十天。这中间虽然
    
    </summary>
    
      <category term="随笔" scheme="http://XibHe.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="自省" scheme="http://XibHe.github.io/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
</feed>
