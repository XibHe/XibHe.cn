<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XibHe&#39;s Blog</title>
  <subtitle>It is never too late，Just do it better.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://XibHe.github.io/"/>
  <updated>2018-07-28T10:21:00.063Z</updated>
  <id>http://XibHe.github.io/</id>
  
  <author>
    <name>XibHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组件化初探</title>
    <link href="http://XibHe.github.io/2018/07/18/ModuleFirstExplore/"/>
    <id>http://XibHe.github.io/2018/07/18/ModuleFirstExplore/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-07-28T10:21:00.063Z</updated>
    
    <content type="html"><![CDATA[<p>项目经过三年多的迭代，总共有三拨人接手，代码整体风格各异，迭代后的旧代码与新代码揉在一起，难解难分。各功能模块间相互依赖，头文件多次重复引用，编译一次大概花费5分钟。不得不进行代码组件化后重构。关于应用架构以及组件化的方案 <a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">casatwy</a> 已经说得很透彻了，在这里我就没有必要再班门弄斧了。这篇文章主要是记录自己项目组件化时如何拆分各个功能模块？抽离组件遇到了哪些问题？阶段性测试时遇到了哪些棘手的问题？因此，这篇文章的实践性较强，希望可以解决各位在组件化过程中遇到大部分问题。</p>
<h2 id="现在项目中存在的问题"><a href="#现在项目中存在的问题" class="headerlink" title="现在项目中存在的问题"></a>现在项目中存在的问题</h2><p>代码不够整齐，目录结构混乱，分类不够明确，随着一次次的版本迭代，增加了不同的业务线，开发人员变动比较频繁，工程越来越臃肿。莫名其妙的继承关系，Base类，Expand类，Category混乱，三者之间存在重复的功能，这也为后面提到的在组件化过程中遇到一个棘手问题埋下了炸弹。</p>
<h2 id="期望达到的效果"><a href="#期望达到的效果" class="headerlink" title="期望达到的效果"></a>期望达到的效果</h2><ol>
<li>解除各个功能模块间的依赖；</li>
<li>可以单独引入并测试某一个功能组件；</li>
<li>功能与功能之间不再相互引用重复的未使用到的类；</li>
<li>将一个单一的工程项目，分解成各个独立的组件，然后按照某种方式，任意组合成一个拥有完整业务逻辑的工程。</li>
</ol>
<h2 id="组件划分粒度及其相互间的依赖"><a href="#组件划分粒度及其相互间的依赖" class="headerlink" title="组件划分粒度及其相互间的依赖"></a>组件划分粒度及其相互间的依赖</h2><p>组件化是为了解决项目中遇到的问题，不是为了组件化而组件化。模块的划分，以及模块的扩展性，可以增加新的模块，为将来业务的拓展留有余地。基础模块的划分很重要，其他的模块都是建立在基础模块之上的。</p>
<blockquote>
<p>兵马未动，基础组件先行。</p>
</blockquote>
<ul>
<li>基础组件(LZBasisComponents)：基本配置(常量，宏)，分类(各类系统类的拓展)，网络(AFN的封装)，工具类(loading，字符串操作，日期格式处理，文件操作等)</li>
<li>数据库组件(LZDataBaseComponents)：封装了各个功能模块的数据库增，删，改，查的基本操作，基于 <em>FMDB</em> 封装了基本的 <em>SQLite</em> 数据库操作；</li>
<li>功能组件(LZFunctionComponents)：主要用来存放一些自定义控件，eg.自定义弹出窗，错误信息提示View，自定义KeyBoardView，一些按钮和label；</li>
<li>登录组件(LZLoginComponents)：项目中通过登录操作初始化一些基本配置，配置账号体系下用户所能使用的权限。基于登录功能业务上衍生了广告页，热门活动宣传页，某个版本需要强制升级的弹出窗，以及用户协议等功能。</li>
<li>登录中间件(LZLoginComponents_Category)：主要用来处理登录组件(LZLoginComponents)与主工程之间的数据通讯；</li>
<li>工具箱组件(LZToolsComponents)：项目中处理不同设备间数据同步的功能，页面展示的权限控制功能。</li>
</ul>
<blockquote>
<p>自顶向下设计，自底向上实现，先测量，后优化。— casatwy</p>
</blockquote>
<p>以上所列的 <em>6</em> 个组件可以统称为项目基础组件，自基础向上延伸到其他功能模块，为其他模块提供底层支持，同时，在生成私有库时，其他功能模块也要与之建立起依赖关系。</p>
<p>这里数据的持久化基于数据库组件，其中公共类的维护 (以数据库组件为例，每个人维护自己模块下的数据库操作类。eg.LZDatabaseHelper+PatientModel 即为，患者组件下对应的所有患者的数据库操作，处理后的数据以 PatientModel 为存储形式。)</p>
<blockquote>
<p>找到所有需要的模块， 把模块放在该放的地方。 — casatwy</p>
</blockquote>
<p>一个公共模块，如果多个模块都会用到，那么最好是将它抽成一个组件。eg. LZToolsComponents组件中，就存放了一些工具类，这些工具类无法下沉到基础组件中。但其它模块却会用到。</p>
<blockquote>
<p>高内聚，低耦合。</p>
</blockquote>
<p>接下来按功能模块划分组件就比较直观了，比较典型的就是根据 <em>TableBar</em> 来划分，这里适用于大部分 App 的功能模块。以下这些功能组件的划分才是组件化划分的核心所在，也只有将功能组件独立出来，才能达到高内聚，低耦合的目的。</p>
<ul>
<li>工作台组件(LZWorkTableComponents)：主要处理项目中核心功能 — 开方，该模块下由三个小模块组成；</li>
<li>药房管理组件(LZPharmacyComponents)：涉及到药品库存管理的模块；</li>
<li>患者管理组件(LZPatientManageComponent)：管理患者个人就诊信息；</li>
<li>我的模块(LZMineComponents)：配置用户的个人信息，设置处方模板，管理诊所子账号，增值服务，账号设置，配置外接硬件(蓝牙打印机，激光打印机，扫码枪)等</li>
<li>所有H5功能组件(LZWebViewComponents)：该组件统一管理统计报表，专家咨询，知识课堂，活动商城等功能模块的 <em>web</em> 页面。</li>
</ul>
<p>以上各功能组件都分别对应各自的中间件，用来同其他功能组件进行通讯。如下，</p>
<ul>
<li>工作台中间件(LZWebViewComponents_category)</li>
<li>药房管理中间件(LZPharmacyComponents_Category)</li>
<li>患者管理组件(LZPatientManageComponent_Category)</li>
<li>我的中间件(LZMineComponents_Category)</li>
<li>H5交互中间件(LZWebViewComponents_category)</li>
</ul>
<p>以上是基础组件和功能组件的划分，正是有了这些泾渭分明的区分，才能为组件化之间解耦提供基础的支持。</p>
<h2 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC MVVM"></a>MVC MVVM</h2><p>MVC架构，MVVM架构的，这种层次划分，主要是针对数据流动的方向而言的</p>
<p>以解决问题为主，而不是生搬硬套架构。</p>
<h2 id="CoCoaPods-私有库"><a href="#CoCoaPods-私有库" class="headerlink" title="CoCoaPods 私有库"></a>CoCoaPods 私有库</h2><p>通过 <em>cocopods</em> 把组件打包成单独的 <em>私有pod</em> 库来进行管理，这样就可以通过 <em>podfile</em> 文件，进行动态的增删和版本管理了。</p>
<h3 id="1-使用模板快速创建测试工程（组件所在的工程）"><a href="#1-使用模板快速创建测试工程（组件所在的工程）" class="headerlink" title="1.使用模板快速创建测试工程（组件所在的工程）"></a>1.使用模板快速创建测试工程（组件所在的工程）</h3><blockquote>
<p>$ pod lib create LZBasisComponents</p>
</blockquote>
<p><img src="http://odchyrav4.bkt.clouddn.com/ModuleFirstExplore_cocoaPods01.jpeg" alt="创建模板工程"></p>
<p>按照提示，填写完以上信息后， Xcode 会自动打开创建的测试工程，在测试工程的文件夹下，可以看到的路径如下，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/ModuleFirstExplore_cocoaPods02.png" alt="模板工程文件路径"></p>
<p>其中，将抽离出的基础组件<em>LZBasisComponents</em>托至 <em>Classes</em> 文件夹下，此时，<em>cd</em> 到模板工程 <em>Example</em> 所在目录，执行</p>
<blockquote>
<p>$ pod install</p>
</blockquote>
<p>我们就可以在测试组件的模板工程中修改文件了。</p>
<h3 id="2-在-GitLab-上创建一个用来存放基础组件的仓库LZBasisComponents"><a href="#2-在-GitLab-上创建一个用来存放基础组件的仓库LZBasisComponents" class="headerlink" title="2.在 GitLab 上创建一个用来存放基础组件的仓库LZBasisComponents"></a>2.在 GitLab 上创建一个用来存放基础组件的仓库LZBasisComponents</h3><p>这里使用开源的 <em>GitLab</em> 作为代码托管的 <em>git</em> 服务器，安装完成后可以在上面新建组件。当然也可以付费使用基于 GitHub 托管，免费的有 <em><a href="https://gitee.com" target="_blank" rel="external">码云</a></em> 和 <em><a href="https://coding.net" target="_blank" rel="external">码市</a></em>。</p>
<h3 id="3-配置私有库的-podspec-文件"><a href="#3-配置私有库的-podspec-文件" class="headerlink" title="3.配置私有库的 .podspec 文件"></a>3.配置私有库的 .podspec 文件</h3><p>在上文中生成模板工程的同时，也会生成一个 <em>. podspec</em> 的文件。我们需要单独设置该文件，之所以配置 <em>.podspec</em> 文件，是为了将本地私有库与 <em>GitLab</em> 上远程私有库进行关联，多人开发时通过远程私有组件库进行代码的同步。远程索引库 <em>. podspec</em> 即，组件描述文件，里面描述了组件文件的源码地址，框架简介，私有库作者，版本号，资源文件路径等信息。我们使用 <strong>$ pod search</strong> 检索索引文件，找到 <em>. podspec</em> 中的源码地址，然后将项目down到本地。其主要配置如下，</p>
<pre><code class="js">s.name         = &quot;LZBasisComponents&quot;
s.version      = &quot;1.2.2.1&quot;
s.summary      = &quot;LZBasisComponents.&quot;

s.homepage     = &quot;http://192.168.11.11/CloudOfficeModulization/LZBasisComponents&quot;
s.license      = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; }
s.author       = &quot;xibHe&quot;
s.platform     = :ios, &quot;8.4&quot;

s.source       = { :git =&gt; &quot;http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git&quot;, :tag =&gt; s.version.to_s }
s.source_files  = &quot;LZBasisComponents/LZBasisComponents/Classes/**/*.{h,m}&quot;

s.resource_bundles = {
&#39;LZBasisComponents&#39; =&gt; [&#39;LZBasisComponents/LZBasisComponents/Assets/*.{png,plist}&#39;]
}

s.requires_arc = true

s.dependency &quot;Masonry&quot;, &#39;~&gt; 1.1.0&#39;
s.dependency &quot;YYKit&quot;, &#39;~&gt; 1.0.9&#39;
s.dependency &quot;ReactiveObjC&quot;
</code></pre>
<p>具体的配置如下：</p>
<ul>
<li><em>s.homepage</em> 组件在 <em>GitLab</em> 的主页面</li>
<li><em>s.source</em> 真实组件的地址，在 <em>GitLab</em> 中新建库时会生成该地址</li>
<li><em>s.source_files</em> 组件中对应目录下的文件夹</li>
<li><em>s.resource_bundles</em> 存放资源文件的类型</li>
<li><em>s.dependency</em> 依赖其他的框架或组件</li>
</ul>
<p>这里是组件中用到的主要的配置，还有其它的与私有 <em>pod</em> 相关的配置。</p>
<p>注意: 组件的依赖关系，各个组件中的 <em>.podspec</em> 文件中通过 <em>s.dependency</em> 设置了该组件与其他三方框架或者其他业务组件的依赖关系，这里各个组件前期可以暂时依赖其他业务组件，但后期当所有组件抽出后，需要解除与其他业务组件的依赖关系。即，将 <em>s.dependency</em> 下的依赖注释掉。</p>
<h3 id="4-将上面创建的模板工程，提交到-GitLab-上创建的远程代码仓库中"><a href="#4-将上面创建的模板工程，提交到-GitLab-上创建的远程代码仓库中" class="headerlink" title="4.将上面创建的模板工程，提交到 GitLab 上创建的远程代码仓库中"></a>4.将上面创建的模板工程，提交到 GitLab 上创建的远程代码仓库中</h3><p>主要是通过 <em>git</em> 命令上传，如下</p>
<h4 id="1-cd-到-模板工程所在的-Example-对应的私有库目录"><a href="#1-cd-到-模板工程所在的-Example-对应的私有库目录" class="headerlink" title="1. cd 到 模板工程所在的 Example 对应的私有库目录"></a>1. cd 到 模板工程所在的 <em>Example</em> 对应的私有库目录</h4><h4 id="2-可以先查看当前工程文件的状态，红色为未提交"><a href="#2-可以先查看当前工程文件的状态，红色为未提交" class="headerlink" title="2. 可以先查看当前工程文件的状态，红色为未提交"></a>2. 可以先查看当前工程文件的状态，红色为未提交</h4><blockquote>
<p>git status </p>
</blockquote>
<h4 id="3-提交到暂缓区"><a href="#3-提交到暂缓区" class="headerlink" title="3. 提交到暂缓区"></a>3. 提交到暂缓区</h4><blockquote>
<p>git add .</p>
</blockquote>
<h4 id="4-将本地库与远程代码仓库进行关联"><a href="#4-将本地库与远程代码仓库进行关联" class="headerlink" title="4. 将本地库与远程代码仓库进行关联"></a>4. 将本地库与远程代码仓库进行关联</h4><blockquote>
<p>git remote add origin <a href="http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git" target="_blank" rel="external">http://192.168.11.11/CloudOfficeModulization/LZBasisComponents.git</a></p>
</blockquote>
<h4 id="5-初始化提交"><a href="#5-初始化提交" class="headerlink" title="5. 初始化提交"></a>5. 初始化提交</h4><blockquote>
<p>git commit -m “Initial commit”</p>
</blockquote>
<h4 id="6-将本地分支的更新，推送到远程主机"><a href="#6-将本地分支的更新，推送到远程主机" class="headerlink" title="6. 将本地分支的更新，推送到远程主机"></a>6. 将本地分支的更新，推送到远程主机</h4><blockquote>
<p>git push -u origin master</p>
</blockquote>
<h4 id="7-给远程组件库打-tag"><a href="#7-给远程组件库打-tag" class="headerlink" title="7. 给远程组件库打 tag"></a>7. 给远程组件库打 tag</h4><blockquote>
<p>git tag -a 1.2.2.1 -m ‘v1.2.2.1’</p>
<p>git push origin master</p>
</blockquote>
<p>保持 <em>s.version</em> = “1.2.2.1” 的版本与远程私有库的 <em>tag</em> 一致。</p>
<h3 id="5-主工程中使用-CoCoaPods-导入私有组件库"><a href="#5-主工程中使用-CoCoaPods-导入私有组件库" class="headerlink" title="5.主工程中使用 CoCoaPods 导入私有组件库"></a>5.主工程中使用 CoCoaPods 导入私有组件库</h3><p>打开并编辑主工程中的 <em>Podfile</em> 文件，如下，</p>
<pre><code class="js">platform :ios, &#39;8.4&#39;

source &#39;http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git&#39;
source &#39;https://github.com/CocoaPods/Specs.git&#39;

workspace &#39;CloudOffice.xcworkspace&#39;
#use_frameworks!
inhibit_all_warnings!

def common_pods
    pod &#39;LZBasisComponents&#39;, :path =&gt; &#39;/Users/huahua/Documents/Module/LZBasisComponents&#39;

end

target  ‘CloudOffice’ do

    common_pods

end

target  ‘CloudOfficeTest’ do

    common_pods

end

target  ‘CloudOfficeTrial’ do

    common_pods

end
</code></pre>
<p>通过命令 <strong>pod repo</strong> 查看本地已存在的索引库，</p>
<pre><code class="js">14-cloudofficemodulization-cloudofficespec
- Type: git (master)
- URL:  http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git
- Path: /Users/huahua/.cocoapods/repos/14-cloudofficemodulization-cloudofficespec

master
- Type: git (master)
- URL:  https://github.com/CocoaPods/Specs.git
- Path: /Users/huahua/.cocoapods/repos/master
</code></pre>
<p><em>GitLab</em> 中远程私有库的地址：</p>
<pre><code class="js">source &#39;http://192.168.11.11/CloudOfficeModulization/CloudOfficeSpec.git&#39;
</code></pre>
<p>公有库的地址：</p>
<pre><code class="js">source &#39;https://github.com/CocoaPods/Specs.git&#39;
</code></pre>
<p>cd 到主工程 <em>Podfile</em> 文件所在目录，执行 <strong>pod instal</strong> 命令，再次打开项目就可以在 <em>Pods</em> 文件夹下的 <em>Development Pods</em> 文件夹中找到 <em>LZBasisComponents</em> 组件。</p>
<p>注意：pod ‘LZBasisComponents’, :path =&gt;’/Users/huahua/Documents/Module/LZBasisComponents’ 对应的路径可以是存放本地私有库(已update远程私有库)的路径，也可以是 <em>步骤4</em> 中对应的远程私有库，可以通过通过 tag 来导入不同的私有组件库的版本，如下：</p>
<pre><code class="js">pod &#39;LZBasisComponents&#39;, &#39;~&gt; 1.2.2.1&#39;
</code></pre>
<p>也可以通过 <em>SourceTree</em> 或者 <em>GitHub Desktop</em> 等拥有可视化界面的项目版本控制软件，进行 <em>git</em> 项目私有库的管理。</p>
<h2 id="组件之间及各组件与主工程间通讯-中间件"><a href="#组件之间及各组件与主工程间通讯-中间件" class="headerlink" title="组件之间及各组件与主工程间通讯(中间件)"></a>组件之间及各组件与主工程间通讯(中间件)</h2><p>目前市面上有两种组件间的通讯方式：</p>
<ol>
<li>利用 <em>url-scheme</em> 方案</li>
<li>利用 <em>runtime</em> 实现的 <em>target-action</em> 方法</li>
</ol>
<p>两种方式都对应一些开源库，如下</p>
<p><strong>URL-Scheme库：</strong></p>
<ol>
<li><a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="external">JLRoutes</a></li>
<li><a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="external">routable-ios</a></li>
<li><a href="https://github.com/lightory/HHRouter" target="_blank" rel="external">HHRouter</a></li>
<li><a href="https://github.com/mogujie/MGJRouter" target="_blank" rel="external">MGJRouter</a></li>
</ol>
<p><strong>Target-Action库：</strong></p>
<ol>
<li><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a></li>
</ol>
<p>采用 <em>url-scheme</em> 方案，要本地调用和远程调用之间如何相互调用？提供给 <em>url</em> 什么样的参数？如何处理非常规对象与本地组件间的调度？</p>
<blockquote>
<p>在iOS领域里，一定是组件化的中间件为openUrl提供服务，而不是openUrl方式为组件化提供服务。 — casatwy</p>
<p>URL注册对于实施组件化方案是完全不必要的，且通过URL注册的方式形成的组件化方案，拓展性和可维护性都会被打折。 — casatwy</p>
</blockquote>
<p>采用 <em>runtime</em> 实现的 <em>target-action</em> 方法</p>
<blockquote>
<p>注册 <em>URL</em> 的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用 <em>runtime</em> 就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。<em>runtime</em> 由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。</p>
<p>由于通过 <em>runtime</em> 做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。— casatwy</p>
</blockquote>
<p><img src="http://odchyrav4.bkt.clouddn.com/ModuleFirstExplore_target-action.png" alt="target-action"></p>
<p>如图，<em>target-action</em> 模式，即，目标-行为，行为即要调用的方法，目标即消息的接收对象（Objective-C 语言使用消息机制，类似但不同于方法调用）。整个过程为：用户点击按钮，触发某事件发生，该消息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对象，但通常为控制器（<em>Controller</em>）。</p>
<p>组件之间的交互，通过 <em>Action</em> 暴露可调用接口，所有组件都通过组件自带的<em>Target-Action</em> 来响应，也就是说，模块与模块之间的接口被固化在了 <em>Target-Action</em> 这一层，避免了实施组件化的改造过程中，对业务层的侵入，同时也提高了组件化接口的可维护性。 </p>
<p>基于以上原因，这里我推荐 <em>Target-Action</em> 方案。具体操作流程如下，</p>
<h3 id="新增基于-CTMediator-的组件-LZMediator"><a href="#新增基于-CTMediator-的组件-LZMediator" class="headerlink" title="新增基于 CTMediator 的组件 LZMediator"></a>新增基于 CTMediator 的组件 LZMediator</h3><p>基于 <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a> 新建用于传递组件讯息的组件 <em>LZMediator</em>，该组件参考 <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a> 中的 <em>CTMediator</em> 类，做了一些简化处理。具体创建操作参照上文中使用 <em>CoCoaPods</em> 建立私有库，这里就不再赘述了。</p>
<h3 id="新建与其它组件通讯的中间件"><a href="#新建与其它组件通讯的中间件" class="headerlink" title="新建与其它组件通讯的中间件"></a>新建与其它组件通讯的中间件</h3><p>这里的所说的中间件也是以 <em>pod</em> 私有库的形式存在于项目中，其仍是代表不同功能模块的组件。以工作台组件（<em>LZWorkTableComponents</em>）为例，其它组件若想调用工作台组件中的某个控制器时，不能直接调用，而是需要通过工作台中间件（<em>LZWorkTableComponents_Category</em>）暴露的接口调用。同上文中使用<em>CoCoaPods</em> 建立私有库一样，先生成模板工程，然后上传到 <em>GitLab</em> 远程代码厂库中。唯一需要注意的是：需要在工作台中间件的 <em>.podspec</em> 文件中，增加对<em>LZMediator</em> 组件的依赖，如下：</p>
<pre><code class="js">s.dependency &quot;LZMediator&quot;
</code></pre>
<p>通过这种依赖关系，将 <em>LZMediator</em> 引入到工程中。</p>
<h3 id="在中间件中新增用于通讯的-LZMediator-类别"><a href="#在中间件中新增用于通讯的-LZMediator-类别" class="headerlink" title="在中间件中新增用于通讯的 LZMediator 类别"></a>在中间件中新增用于通讯的 LZMediator 类别</h3><p>在上面新建的工作台中间件（<em>LZWorkTableComponents_Category</em>）中新建基于 <em>LZMediator</em> 的类别，注意统一类别的名称，以工作台中间件为例，最终生成的类名为：<em>LZMediator+LZWorkTableComponents.h</em> 和 <em>LZMediator+LZWorkTableComponents.m</em> 接下来就是按照基于 <em>Mediator</em> 的一套逻辑，通过实现 <em>target-action</em> 的方法来进行不同组件间的通讯。例如，某个组件需要调用工作台组件中的某个控制器时，</p>
<p><em>LZMediator+LZWorkTableComponents.h</em> 中声明中间件调用的返回工作台组件中某个控制器的实例方法：</p>
<pre><code class="objectivec">#pragma mark - 患者管理组件调用
/**
 看病开方详情页面
 @return 返回实例
 */
- (UIViewController *)LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic:(NSDictionary *)params;
</code></pre>
<p><em>LZMediator+LZWorkTableComponents.m</em> 中实现该方法：</p>
<pre><code class="objectivec">#pragma mark - 统一前缀
NSString *const kLZMediatorTarget_LZWorkTableComponents = @&quot;LZWorkTableComponents&quot;;

#pragma mark - 方法名称
NSString *const kLZMediatorAction_newDoctorPrescribingViewController = @&quot;newDoctorPrescribingViewController&quot;;  // 看病开方详情页面

- (UIViewController *)LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic:(NSDictionary *)params
{
    UIViewController *viewController = [self performTarget:kLZMediatorTarget_LZWorkTableComponents action:kLZMediatorAction_newDoctorPrescribingViewController params:params shouldCacheTarget:NO];
    if ([viewController isKindOfClass:[UIViewController class]]) {
        return viewController;
    }
    return [UIViewController new];
}
</code></pre>
<p>这里需要注意方法中传递的参数 <em>kLZMediatorTarget_LZWorkTableComponents</em> 和 <em>kLZMediatorAction_newDoctorPrescribingViewController</em> 分别对应工作台组件中 <em>target-action</em> 所在的模块 (也就是提供服务的模块，这也是单独的repo，但无需被其他人依赖，其他人通过category调用这里的功能），这两个参数，前者对应的是 <em>target-action</em> 所在组件中的以 <em>Target_</em> 为前缀的类，后者对应该类里的具体的以 <em>Action_</em> 为前缀声明的某个方法。前面所说的利用 <em>runtime</em> 实现的 <em>target-action</em> 方法，指的正是这个地方。</p>
<p>注意: 这两个参数值，一定要与工作台组件中 <em>Target</em> 目录下的类名相一致!!! 切记！ 切记！ 切记！ </p>
<h3 id="在-target-action-所在的组件中增加提供服务的类"><a href="#在-target-action-所在的组件中增加提供服务的类" class="headerlink" title="在 target-action 所在的组件中增加提供服务的类"></a>在 target-action 所在的组件中增加提供服务的类</h3><p>在工作台组件（<em>LZWorkTableComponents</em>）中 <em>Target</em> 目录下新建名称为： <em>Target_LZWorkTableComponents</em> 继承于 <em>NSObject</em> 的类，这个类的命名规则与上面说的 <em>kLZMediatorTarget_LZWorkTableComponents</em> 参数相一致，然后新增方法，方法名以前缀 <em>Action_</em> 开头，同样需要与上面说的<em>kLZMediatorAction_newDoctorPrescribingViewController</em> 参数相一致。如下：</p>
<p><em>Target_LZWorkTableComponents.h</em> 中声明中间件调用的返回工作台组件中某个控制器的实例方法：</p>
<pre><code class="objectivec">#pragma mark - 患者管理组件调用
/**
 返回LZNewDoctorPrescribingViewController实例
 */
- (UIViewController *)Action_newDoctorPrescribingViewController:(NSDictionary *)param;
</code></pre>
<p><em>Target_LZWorkTableComponents.m</em> 中实现该方法：</p>
<pre><code class="objectivec">#import &lt;LZDataBaseComponents/PationModel.h&gt;
#import &quot;LZNewDoctorPrescribingViewController.h&quot;

/**
 返回LZNewDoctorPrescribingViewController实例

 @param param 患者dictionary
 @return LZNewDoctorPrescribingViewController实例
 */
- (UIViewController *)Action_newDoctorPrescribingViewController:(NSDictionary *)param
{
    PationModel *pationModel = [[PationModel alloc] init];
    [pationModel setValuesForKeysWithDictionary:param];

    LZNewDoctorPrescribingViewController *newDoctorPrescribinVC = [[LZNewDoctorPrescribingViewController alloc] init];
    newDoctorPrescribinVC.model = pationModel;

    return newDoctorPrescribinVC;
}
</code></pre>
<p>这里 <em>PationModel</em> 为数据库组件中的类，需要注意一下这里使用尖括号引入的头文件，<em>LZNewDoctorPrescribingViewController</em> 控制器为工作台组件中的类。</p>
<h3 id="在其它组件中调用中间件的方法进行通讯"><a href="#在其它组件中调用中间件的方法进行通讯" class="headerlink" title="在其它组件中调用中间件的方法进行通讯"></a>在其它组件中调用中间件的方法进行通讯</h3><p>这里仍以工作台组件（<em>LZWorkTableComponents</em>）为例，比如，在患者组件中想跳转至工作台组件中的看病开方详情页（<em>LZNewDoctorPrescribingViewController</em>），需要通过上面的工作台中间件（<em>LZWorkTableComponents_Category</em>）进行通讯，而不是直接导入 <em>#import “LZNewDoctorPrescribingViewController.h”</em> 头文件调用。具体事例，如下：</p>
<p>在患者管理组件中，</p>
<pre><code class="objectivec">#import &lt;LZWorkTableComponents_Category/LZMediator+LZWorkTableComponents.h&gt;

NSDictionary *pationModelDic = model.mj_keyValues;
UIViewController *newDoctorVC = [[LZMediator sharedInstance]  LZWorkTableComponents_newDoctorPrescribingViewControllerWithDic :pationModelDic];
[weakSelf presentViewController: newDoctorVC animated:YES completion:nil];
</code></pre>
<p>这里通过一个 <em>LZMediator</em> 的单例来调用工作台中间件（<em>LZWorkTableComponents_Category</em>）中 <em>LZMediator</em> 的类别(<em>LZMediator+LZWorkTableComponents</em>) 中的方法，获得 <em>view controller</em> 之后，在这种场景下，到底 <em>push</em> 还是 <em>present</em> ，其实是要由使用者决定的，<em>mediator</em> 只要给出 <em>view controller</em> 的实例就好了。</p>
<h2 id="原工程中资源文件的处理"><a href="#原工程中资源文件的处理" class="headerlink" title="原工程中资源文件的处理"></a>原工程中资源文件的处理</h2><p>图片文件的处理以及读取方式</p>
<h2 id="受工期影响"><a href="#受工期影响" class="headerlink" title="受工期影响"></a>受工期影响</h2><ol>
<li>抽取组件前未将项目中冗余的类删除，导致这些类最后被抽到组件中；</li>
<li>在抽取组件时，版本仍在继续迭代，这就造成组件抽取完成后，需要再花时间合并新代码到组件中；</li>
<li>前期为了快速分离功能组件，往往将与该组件关联的其它功能模块的代码也抽到组件中；</li>
</ol>
<p>出现 <em>2</em> 中的情况，就需要记录一下新版本迭代修改了组件中的哪些类，还要记录提测后修改 <em>QA</em> 提出的 bug 时修改了哪些类，最后，再对比 <em>Git</em> 和 <em>svn</em> 的提交日志，查看修改了哪些类。</p>
<h2 id="组件化过程中遇到的问题及解决方式"><a href="#组件化过程中遇到的问题及解决方式" class="headerlink" title="组件化过程中遇到的问题及解决方式"></a>组件化过程中遇到的问题及解决方式</h2><p>抽离业务组件，一般分为四步，这里以抽离患者管理组件为例：</p>
<ol>
<li>将患者管理模块所有代码 <em>copy</em> 到新建的患者管理模板工程中（注意要将复制的代码放到 <em>ReplaceMe.m</em> 所在目录下）；</li>
<li>梳理患者管理中与主工程有交互的功能类，明确使用了哪些三方库和自定义控件，剔除未使用到的类，整理工程目录结构（这一步主要是整理现有的代码逻辑，结构，去除冗余的类）；</li>
<li>将模板工程中患者管理代码中涉及数据库操作，公用模块，全局自定义控件等其它组件的功能抽出来。那些暂时无法划分到其它组件中的类，暂时 <em>copy</em> 一份放到 <em>Redundancy</em> 文件夹下。患者管理组件只能导入其它组件并引用后，才能使用。不能再以直接引入主工程的头文件的方式调用类了（这一步主要是从组件角度斩断组件与主工程单方面的关联）；</li>
<li>将患者管理模块所在的模板工程上传至 <em>GitLab</em>，然后在已集成了基础组件的壳工程中引入该组件并调试。</li>
</ol>
<p>第 <em>4</em> 步建立在壳工程之上，这里所谓的壳工程是指集成了主工程 <em>AppDelegate</em>中初始化功能和基础组件，可以进行登录操作，同步用户的数据。有了数据就可以进行页面展示，就能进一步测试组件功能是否完整。</p>
<h3 id="1-duplicate-symbols-for-architecture-arm64"><a href="#1-duplicate-symbols-for-architecture-arm64" class="headerlink" title="1. duplicate symbols for architecture arm64"></a>1. duplicate symbols for architecture arm64</h3><pre><code class="objectivec">duplicate symbol_LZKanBingHomeViewController._closeImageV in:
    /Users/huahua/Library/Developer/Xcode/DerivedData/CloudOffice-enrpnhjeeqovpuffsdjmigxqovpi/Build/Intermediates.noindex/CloudOffice.build/Debug-iphoneos/CloudOfficeTest.build/Objects-normal/arm64/LZKanBingHomeViewController.o
    /Users/huahua/Library/Developer/Xcode/DerivedData/CloudOffice-enrpnhjeeqovpuffsdjmigxqovpi/Build/Products/Debug-iphoneos/LZWorkTableComponents/libLZWorkTableComponents.a(LZKanBingHomeViewController.o)
ld: 31 duplicate symbols for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<p>根据错误提示，删除主工程中的重复类文件，因为这些类已经抽离到组件中了。这也是集成组件后联调出现最对，最常见的一种错误。</p>
<h3 id="2-OBJC-CLASS-LZKanBingHomeViewController-referenced-from-objc-class-ref-in-libLZWorkTableComponents-a-LZWorkTableMangerController-o-ld-symbol-s-not-found-for-architecture-arm64-clang-error-linker-command-failed-with-exit-code-1-use-v-to-see-invocation"><a href="#2-OBJC-CLASS-LZKanBingHomeViewController-referenced-from-objc-class-ref-in-libLZWorkTableComponents-a-LZWorkTableMangerController-o-ld-symbol-s-not-found-for-architecture-arm64-clang-error-linker-command-failed-with-exit-code-1-use-v-to-see-invocation" class="headerlink" title="2. _OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o) ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation)"></a>2. _OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o) ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation)</h3><pre><code class="objectivec">objc-class-ref in libLZWorkTableComponents.a(LZWorkTableMangerController.o)

ld: symbol(s) not found for architecture arm64
</code></pre>
<p>这个错误是由于向工程中某个组件下导入类时，未将导入类与与组件进行关联导致。根据错误提示 <strong>OBJC_CLASS_LZKanBingHomeViewController, referenced from: objc-class-ref in libLZWorkTableComponents.a</strong> 可以知道是工作台组件（<strong>LZWorkTableComponents</strong>）中的类（<strong>LZKanBingHomeViewController</strong>）未与组件建立关联。解决方式：在工程组件中选中 <strong>LZKanBingHomeViewController.m</strong> 切换到该类的 <strong>“Show the File inspector”</strong> 设置项中，检查文件的设置项。如图，</p>
<p> <img src="http://odchyrav4.bkt.clouddn.com/ModuleFirstExplore_inspector.png" alt="inspector"></p>
<p>设置 <strong>“Target Membership”</strong> 下 <strong>“LZWorkTableComponents”</strong> 为选中状态，重新编译，即可。 </p>
<h3 id="3-Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’"><a href="#3-Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’Property-‘text’-cannot-be-found-in-forward-class-object-‘PlaceholderTextView’" class="headerlink" title="3. Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’"></a>3. Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’Property ‘text’ cannot be found in forward class object ‘PlaceholderTextView’</h3><p>头文件重复引用的问题，可以在各个基础组件中新建 <strong>.h</strong> 头文件，用于存放其他类会用到类的头文件，使用时直接导入。例如：</p>
<pre><code class="objectivec">#import &lt;LZBasisComponents/LZBasisComponents.h&gt;
#import &lt;LZDataBaseComponents/LZDataBaseComponents.h&gt;
</code></pre>
<h3 id="4-GlobalMethod-showName-”请输入正确手机号码”-inView-self-headView-dianhuaView-不执行"><a href="#4-GlobalMethod-showName-”请输入正确手机号码”-inView-self-headView-dianhuaView-不执行" class="headerlink" title="4. [GlobalMethod showName:@”请输入正确手机号码” inView:self.headView.dianhuaView] 不执行"></a>4. [GlobalMethod showName:@”请输入正确手机号码” inView:self.headView.dianhuaView] 不执行</h3><p>这里 <strong>LZBasisComponents</strong> 中已经通过 <strong>GlobalMethod</strong> 类引入了<strong>MBProgressHUD</strong>，若在组件外重复引入新的 <strong>MBProgressHUD</strong> 会导致该代码不执行。</p>
<h3 id="5-暂时注释掉组件中跳转至其它组件控制器的方法"><a href="#5-暂时注释掉组件中跳转至其它组件控制器的方法" class="headerlink" title="5. 暂时注释掉组件中跳转至其它组件控制器的方法"></a>5. 暂时注释掉组件中跳转至其它组件控制器的方法</h3><p>由于组件间不能直接进行通讯，当用于处理组件间交互的中间件没有完成时，为了编译成功，可以先注释掉跳转到其它组件控制器的代码。</p>
<h3 id="6-Reference-to-‘LZHttpRequestPost’-is-ambiguous"><a href="#6-Reference-to-‘LZHttpRequestPost’-is-ambiguous" class="headerlink" title="6. Reference to ‘LZHttpRequestPost’ is ambiguous"></a>6. Reference to ‘LZHttpRequestPost’ is ambiguous</h3><pre><code class="objectivec">+ (void)hasNewRemoteConsulationWithParam:(NSDictionary *)param
  success:(void(^)(LZHttpResponseModel *responseModel))success
  failure:(void(^)(NSError *error))failure{

[self baseRequestWithParam:param path:[LZHttpDomainManage sharedInstance].YCHZ method:LZHttpRequestPost success:success failure:failure];
}
</code></pre>
<p>很奇怪的一个问题，项目中顶一个一个网络请求类型的枚举 — <strong>LZHttpRequestType</strong>，项目中很多用到 <strong>LZHttpRequestPost</strong> 这个枚举类型就会报这个错误，但只要将该参数换成枚举所对应的整数值就行。暂时先这样解决，后来再看这个错误，觉得是头文件重复引用造成的，之前的老项目中有有一个叫 <strong>Foundation.h</strong> 的头文件，里面引用的是一些基本的配置类，工具类，还有一个很奇怪的引用，每个项目开发者都会在这个头文件里引入自己所编写功能的头文件。例如，</p>
<pre><code class="objectivec">/*************此.h 文件是用来导入公用的头文件的***************/
#import &quot;GlobalMacro.h&quot;
#import &quot;URLMacro.h&quot;
#import &quot;GlobalMethod.h&quot;
#import &quot;PlaceholderTextView.h&quot;
#import &quot;UIImageView+WebCache.h&quot;

#import &quot;UIView+Frame.h&quot;
#import &quot;MJRefresh.h&quot;
#import &quot;HLNavigationController.h&quot;
#import &lt;AdSupport/ASIdentifierManager.h&gt;
#import &quot;NSString+MD5.h&quot;
#import &quot;Masonry.h&quot;
#import &quot;UILabel+LZLabel.h&quot;
#import &quot;NSArray+LZAddition.h&quot;

//多人开发，避免冲突
#import &quot;LWB.h&quot;
#import &quot;DLN.h&quot;
#import &quot;LYY.h&quot;
#import &quot;XXL.h&quot;
</code></pre>
<p>注释是为了避免多人开发的冲突，在这些每个人姓名首字母缩写的头文件中，引入的是这个人所开发功能类的头文件，就这样一层套一层。在组件中如果引用了这个<strong>Foundation.h</strong> 头文件，很大几率会造成重复重复引用。而且还有一点需要注意：组件中若要引入其它组件类的头文件，最好以尖括号引入。例如，引入基本组件中的某个类，</p>
<pre><code class="objectivec">#import &lt;LZBasisComponents/LZHttpDomainManage.h&gt;
</code></pre>
<p>一些基本的配置类的引入，工具类的引入，则可以用包含这些类的所有头文件的一个总的 <strong>.h</strong> 头文件的形式引入，</p>
<pre><code class="objectivec">#import &lt;LZBasisComponents/LZBasisComponents.h&gt;
</code></pre>
<p>就这样一步步的将那些多余的头文件和姓名首字母缩写的头文件从 <strong>Foundation.h</strong> 中移除，去除重复引入的头文件。</p>
<h3 id="7-iOS-9-3-5-系统下，页面布局错乱的问题"><a href="#7-iOS-9-3-5-系统下，页面布局错乱的问题" class="headerlink" title="7. iOS 9.3.5 系统下，页面布局错乱的问题"></a>7. iOS 9.3.5 系统下，页面布局错乱的问题</h3><p>组件拆分中遇到的一个很棘手的问题，在 <strong>iOS 9.3.5</strong> 的 <strong>ipad</strong> 上，左侧切换视图的选项显示不出来，同时，右侧页面布局错乱无法点击。运行项目， 点击<strong>Debug View Hierarchy</strong> 查看视图层级，发现左侧菜单所有切换按钮的布局都乱掉了，挤在一起了。主视图控制器中的 <strong>MainView</strong> 的 <strong>Frame</strong> 获取的一直都是错的，工程中 <strong>Frame</strong> 坐标的获取都是通过 <strong>UIView</strong> 的类别计算获取的，如果不通过类别获取是可以得到正确的值的。但即使将主视图和菜单中所有获取坐标的方式都通过系统方法获取，还是加载不出完整的视图。</p>
<p>最后搜索项目中所有与计算视图布局有关的类，发现了真相。主工程中有很多计算坐标的类别，这些类别重复定义了视图的坐标，需要移除未使用的类别。同时，将组件中计算坐标的 <strong>UIView+Frame</strong> 类移至主工程中，从 <strong>podFile</strong> 中移除 <strong>HandyFrame</strong>, 移除主工程中未使用到的 <strong>UIView+AutoLayout</strong>， <strong>UIView+TXFrame</strong> 等计算页面布局的类别。 </p>
<h3 id="8-Include-of-non-modular-header-inside-framework-module-‘LZBasisComponents-LZHttpClient’-‘-Users-zyjk-imac-penghe-Library-Developer-Xcode-DerivedData-CloudOffice-ffqipmpyrmrjqmevvpibbskoycre-Build-Products-Debug-iphoneos-AFNetworking-AFNetworking-framework-Headers-AFURLRequestSerialization-h’"><a href="#8-Include-of-non-modular-header-inside-framework-module-‘LZBasisComponents-LZHttpClient’-‘-Users-zyjk-imac-penghe-Library-Developer-Xcode-DerivedData-CloudOffice-ffqipmpyrmrjqmevvpibbskoycre-Build-Products-Debug-iphoneos-AFNetworking-AFNetworking-framework-Headers-AFURLRequestSerialization-h’" class="headerlink" title="8. Include of non-modular header inside framework module ‘LZBasisComponents.LZHttpClient’: ‘/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFURLRequestSerialization.h’"></a>8. Include of non-modular header inside framework module ‘LZBasisComponents.LZHttpClient’: ‘/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFURLRequestSerialization.h’</h3><pre><code class="objectivec">Include of non-modular header inside framework module &#39;LZBasisComponents.AFHTTPRequestOperationManager_Synchronous&#39;: &#39;/Users/zyjk_imac-penghe/Library/Developer/Xcode/DerivedData/CloudOffice-ffqipmpyrmrjqmevvpibbskoycre/Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/AFHTTPRequestOperationManager.h&#39;
</code></pre>
<p>AFN中头文件引用的包含了同一个头文件，删除报错类 <strong>.h</strong> 中一些重复的引用，改为 <strong>&lt; &gt;</strong> 引入。</p>
<ul>
<li><strong>AFHTTPRequestOperationManager+Synchronous.h</strong> 中引入             <strong>#import <afnetworking afhttprequestoperationmanager.h=""></afnetworking></strong></li>
<li><strong>AFHTTPRequestOperationManager+Synchronous.m</strong> 中引入 <strong>#import <afnetworking afnetworking.h=""></afnetworking></strong></li>
<li><strong>LZHttpClient.h</strong> 中引入 <strong>#import <afnetworking afurlrequestserialization.h=""></afnetworking></strong></li>
<li><strong>LZHttpClient.m</strong> 中引入 <strong>#import <afnetworking afnetworking.h=""></afnetworking></strong>         </li>
</ul>
<h3 id="9-组件间的依赖关系"><a href="#9-组件间的依赖关系" class="headerlink" title="9. 组件间的依赖关系"></a>9. 组件间的依赖关系</h3><p>组件间的依赖关系，若两个组件间存在依赖，则依赖于某个组件的另一个组件可以直接引用所依赖组件的头文件，而不需要加 <strong>&lt; &gt;</strong> 导入。<br>同理，若两个组件间不存在依赖关系，即使，使用了 <strong>&lt; &gt;</strong> 引用也无法引入该组件的任何文件。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>壳工程</li>
<li>去除主工程 <em>Assets.xcassets</em> 目录下的多余资源文件(这些文件已抽到各个业务功能组件中)</li>
<li>组件化方案中的去model设计</li>
<li>将各个功能模块中涉及到数据库组件，<em>SQLite</em> 的查询语句都移动到数据库组件中</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="external">iOS应用架构谈 开篇 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">iOS应用架构谈 view层的组织和调用方案 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="external">iOS应用架构谈 网络层设计方案 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html" target="_blank" rel="external">iOS应用架构谈 本地持久化方案及动态部署 - Casa Taloyum</a></p>
<p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">iOS应用架构谈 组件化方案 - Casa Taloyum</a></p>
<p><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a></p>
<p><a href="http://www.ximublog.cn/modularization/" target="_blank" rel="external">组件化方案调研</a></p>
<p><a href="https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/" target="_blank" rel="external">模块化与解耦</a></p>
<p><a href="https://git-scm.com/book/zh/v2/服务器上的-Git-GitLab" target="_blank" rel="external">服务器上的 Git - GitLab</a></p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/4420" target="_blank" rel="external">XCode 7.1 - Include of non-modular header inside framework</a></p>
<p><a href="https://forums.developer.apple.com/thread/23554" target="_blank" rel="external">Include of non-modular header inside framework module</a></p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/3511" target="_blank" rel="external">Reference to ‘enum_value’ is ambiguous</a></p>
<p><a href="https://github.com/AFNetworking/AFNetworking/issues/2205" target="_blank" rel="external">Make AFNetworking compatible for an iOS 8 Cocoa Touch Framework</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目经过三年多的迭代，总共有三拨人接手，代码整体风格各异，迭代后的旧代码与新代码揉在一起，难解难分。各功能模块间相互依赖，头文件多次重复引用，编译一次大概花费5分钟。不得不进行代码组件化后重构。关于应用架构以及组件化的方案 &lt;a href=&quot;https://casatwy.
    
    </summary>
    
      <category term="架构" scheme="http://XibHe.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="组件化" scheme="http://XibHe.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>从一个蓝牙打印说起</title>
    <link href="http://XibHe.github.io/2018/05/28/Compiling/"/>
    <id>http://XibHe.github.io/2018/05/28/Compiling/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-07-21T07:48:14.246Z</updated>
    
    <content type="html"><![CDATA[<p>遇到在 <strong>Release</strong> 模式下 <strong>80mm蓝牙打印机</strong> 无法打印的问题，最终的解决方式都是围绕 <strong>Debug</strong> 和 <strong>Release</strong> 这两种模式展开的。</p>
<h3 id="可能打造无法打印的原因"><a href="#可能打造无法打印的原因" class="headerlink" title="可能打造无法打印的原因"></a>可能打造无法打印的原因</h3><h4 id="1-需要打印的处方药品过多，排列太过复杂造成"><a href="#1-需要打印的处方药品过多，排列太过复杂造成" class="headerlink" title="1.需要打印的处方药品过多，排列太过复杂造成"></a>1.需要打印的处方药品过多，排列太过复杂造成</h4><p>于是，构建一个最简单的打印模板，打印一行最简单的日期，将打印功能尽可能的简单化，看是否是由打印功能本身引起的。结果，仍然无法打印。</p>
<h4 id="2-线程问题，未在主线程刷新UI导致"><a href="#2-线程问题，未在主线程刷新UI导致" class="headerlink" title="2.线程问题，未在主线程刷新UI导致"></a>2.线程问题，未在主线程刷新UI导致</h4><p>每次选择蓝牙打印机打印处方单时，控制台就会输出线程相关的错误，如下：</p>
<pre><code class="objectivec">2018-05-18 15:52:30.568985+0800 CloudOfficeTest[3340:1191905] [reports] Main Thread Checker: UI API called on a background thread: -[UIApplication windows]
PID: 3340, TID: 1191905, Thread name: (none), Queue name: com.apple.root.default-qos.overcommit, QoS: 21
Backtrace:
4   LZBasisComponents                   0x0000000101baad4c +[MBProgressHUD hideHUDForView:animated:] + 132
5   LZBasisComponents                   0x0000000101baab9c +[MBProgressHUD(MJ) hideHUDForView:] + 72
6   LZBasisComponents                   0x0000000101baabf0 +[MBProgressHUD(MJ) hideHUD] + 48
7   CloudOfficeTest                     0x0000000100aee2c8 -[LZBluetoothPrintView startPrint] + 300
8   Foundation                          0x00000001828de860 &lt;redacted&gt; + 996
9   libsystem_pthread.dylib             0x0000000181b1831c &lt;redacted&gt; + 308
10  libsystem_pthread.dylib             0x0000000181b181e8 &lt;redacted&gt; + 0
11  libsystem_pthread.dylib             0x0000000181b16c28 thread_start + 4
</code></pre>
<pre><code class="objectivec">2018-05-18 15:52:38.876328+0800 CloudOfficeTest[3340:1191725] This application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes.
 Stack:(
    0   Foundation                          0x00000001829f266c &lt;redacted&gt; + 96
    1   Foundation                          0x00000001829f2350 &lt;redacted&gt; + 76
    2   Foundation                          0x0000000182822da0 &lt;redacted&gt; + 132
    3   Foundation                          0x00000001829f0458 &lt;redacted&gt; + 112
    4   UIKit                               0x000000018b610b18 &lt;redacted&gt; + 172
    5   UIKit                               0x000000018b32234c &lt;redacted&gt; + 1348
    6   QuartzCore                          0x0000000185edbec8 &lt;redacted&gt; + 184
    7   QuartzCore                          0x0000000185edffa8 &lt;redacted&gt; + 332
    8   QuartzCore                          0x0000000185e4ea98 &lt;redacted&gt; + 336
    9   QuartzCore                          0x0000000185e74eb4 &lt;redacted&gt; + 540
    10  QuartzCore                          0x0000000185e7559c &lt;redacted&gt; + 244
    11  libsystem_pthread.dylib             0x0000000181b17680 &lt;redacted&gt; + 572
    12  libsystem_pthread.dylib             0x0000000181b173d0 &lt;redacted&gt; + 88
    13  libsystem_pthread.dylib             0x0000000181b17168 _pthread_wqthread + 1340
    14  libsystem_pthread.dylib             0x0000000181b16c20 start_wqthread + 4
)
</code></pre>
<p>这里报错是由于 <strong>MBProgressHUD</strong> 导致的，将打印时的 <strong>MBProgressHUD</strong> 都注释掉，仍然无法打印。 又因为在打印时使用了 <strong>NSThread</strong> 去更新打印状态，就怀疑是 <strong>NSThread</strong> 导致的问题。</p>
<pre><code class="objectivec">    if (thread == NULL) {
        [GlobalMethod showName:@&quot;正在打印中&quot; inView:_contentView delay:3];
        thread = [[NSThread alloc] initWithTarget:self selector:@selector(startPrint) object:nil];
        [thread start];
    } else {
        [GlobalMethod showName:@&quot;正在打印中&quot; inView:_contentView delay:3];
    }
</code></pre>
<p>这里索性就把 <strong>NSThread</strong> 的代码也注释掉。此时，编译后再次调用打印<br>功能，后台虽然不会输出线程相关的错误了，但连接上的蓝牙打印机仍然没有任何反应。</p>
<h4 id="3-当-Edit-Scheme-中-Build-Configuration-为-Debug-时，就可以调用蓝牙打印机进行打印。"><a href="#3-当-Edit-Scheme-中-Build-Configuration-为-Debug-时，就可以调用蓝牙打印机进行打印。" class="headerlink" title="3.当 Edit Scheme 中 Build Configuration 为 Debug 时，就可以调用蓝牙打印机进行打印。"></a>3.当 <strong>Edit Scheme</strong> 中 <strong>Build Configuration</strong> 为 <strong>Debug</strong> 时，就可以调用蓝牙打印机进行打印。</h4><p>选择Xcode中，<strong>Product -&gt; Scheme -&gt; Edit Scheme</strong>，注意 <strong>Run</strong> 和 <strong>Archive</strong> 这两种编译方式，选择 <strong>Build Configuration</strong> 就可以切换 <strong>Debug</strong> 和 <strong>Release</strong> 这两种不同的模式。</p>
<p>这就需要对比 <strong>release</strong> 与 <strong>debug</strong> 两种模式的不同，尤其是在调用 <strong>CoreBluetooth</strong> 时的不同。</p>
<p><strong>Release</strong> 是发行版本，比 <strong>Debug</strong> 版本多一些优化，文件比 <strong>Debug</strong> 文件小。 <strong>Debug</strong> 是调试版本，<strong>Debug</strong> 和 <strong>Release</strong> 调用两个不同的底层库。通俗点讲，我们开发者自己内部真机或模拟器调试时，使用 <strong>Debug</strong> 模式就好，等到想要发布时，也就是说需要大众客户使用时，需要构建 <strong>Release</strong> 版本，具体区别如下：</p>
<ol>
<li><strong>Debug</strong> 是调试版本，包括的程序信息更多；</li>
<li>只有 <strong>Debug</strong> 版的程序才能设置断点、单步执行、使用 <strong>TRACE/ASSERT</strong> 等调试输出语句；</li>
<li><strong>Release</strong> 不包含任何调试信息，所以体积小、运行速度快。</li>
</ol>
<p>简而言之，<strong>Release</strong> 版本会对最终发布的项目做优化，以提高 <strong>App</strong> 的运行速度。</p>
<pre><code class="objectivec">//读取特征中的数据
- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {

    NSLog(@&quot;enter didUpdateValueForCharacteristic!&quot;);
    NSLog(@&quot;read data=%@!&quot;,characteristic.value);
}
</code></pre>
<p>如果将此处的 <strong>NSLog</strong> 输出注释掉是否也可以打印？</p>
<p>控制台会一直输出打印类 <strong>LZBluetoothPrintView</strong> 的一个方法 </p>
<pre><code class="objectivec">&lt;LZBluetoothPrintView.m : 382&gt; -[LZBluetoothPrintView peripheral:didUpdateValueForCharacteristic:error:]
2018-05-18 15:52:38.778826+0800 CloudOfficeTest[3340:1191349] enter didUpdateValueForCharacteristic!
</code></pre>
<pre><code class="objectivec">- (void)viewDidLoad
{
    [super viewDidLoad];
#ifdef DEBUG
    NSLog(@&quot;Test DEBUG mode&quot;);
#else
    NSLog(@&quot;Test Release mode&quot;);
#endif
}
</code></pre>
<h3 id="不同的解决方案"><a href="#不同的解决方案" class="headerlink" title="不同的解决方案"></a>不同的解决方案</h3><h4 id="方案一：将-Build-Settings-里面的-Apple-LLVM-9-0-Preprocessing-Preprocessor-Macros-这里。在-release-下增加配置项-DEBUG-1，即可打印。"><a href="#方案一：将-Build-Settings-里面的-Apple-LLVM-9-0-Preprocessing-Preprocessor-Macros-这里。在-release-下增加配置项-DEBUG-1，即可打印。" class="headerlink" title="方案一：将 Build Settings 里面的 Apple LLVM 9.0 - Preprocessing - Preprocessor Macros 这里。在 release 下增加配置项 DEBUG = 1，即可打印。"></a>方案一：将 <strong>Build Settings</strong> 里面的 <strong>Apple LLVM 9.0 - Preprocessing - Preprocessor Macros</strong> 这里。在 <strong>release</strong> 下增加配置项 <strong>DEBUG = 1</strong>，即可打印。</h4><p>只是暂时解决了打印问题，慎用！因为默认情况下 <strong>release</strong> 模式是不需要设置为 <strong>DEBUG</strong> 模式的。</p>
<p>这里有一个疑问？当设置 <strong>Edit Scheme</strong> 的 <strong>Archive</strong> 中 <strong>Build Configuration</strong> 为 <strong>Release</strong> 时，此时，<strong>Archive</strong> 后生成一个 <strong>ipa</strong>包，导出并安装后发现程序中调用的仍然 <strong>DEBUG</strong> 模式下的程序。代码如下：</p>
<pre><code class="objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    UIView *backView1 = [[UIView alloc] initWithFrame:CGRectMake(self.view.center.x - 20, self.view.center.y - 20, 40, 40)];
    [self.view addSubview:backView1];

#ifdef DEBUG
    backView1.backgroundColor = [UIColor redColor];
    NSLog(@&quot;Test DEBUG mode&quot;);
#else
    backView1.backgroundColor = [UIColor greenColor];
    NSLog(@&quot;Test Release mode&quot;);
#endif
}
</code></pre>
<p>此时，打开通过 <strong>ipa</strong> 包安装的程序，展示的为红色的视图。</p>
<h4 id="方案二：将-Build-Settings-里面的-Optimization-Level-的-release-对应的配置项改为-None-OO"><a href="#方案二：将-Build-Settings-里面的-Optimization-Level-的-release-对应的配置项改为-None-OO" class="headerlink" title="方案二：将 Build Settings 里面的 Optimization Level 的 release 对应的配置项改为 None[-OO]"></a>方案二：将 <strong>Build Settings</strong> 里面的 <strong>Optimization Level</strong> 的 <strong>release</strong> 对应的配置项改为 <strong>None[-OO]</strong></h4><p>修改 <em>release</em> 模式下的编译策略为 <strong>-OO</strong> 即，不做任何编译优化。编译策略是对代码编译过程的优化（c-&gt;汇编），优化后的代码效率比较高，但是可读性比较差，且编译时间更长。</p>
<p>GCC_OPTIMIZATION_LEVEL = Fastest, Smallest   [-OS] 优化级别：</p>
<ul>
<li>None： 不做优化使用这个设置，编译器的目标是减少编译成本，使调试产生预期的结果。</li>
<li>Fast：优化编译将为大函数占用更多的时间和内存使用这个设置，编译器将尝试减少代码的大小和执行时间，不进行任何优化，需要大量编译时间。</li>
<li>Faster：编译器执行几乎所有支持的优化，它不考虑空间和速度之间的平衡与“Fast”设置相比，该设置会增加编译时间和生成代码的性能。编译器不进行循环展开、内联函数和寄存器变量的重命名。</li>
<li>Fastest：开启“Faster”支持的所有的优化，同时也开启内联函数和寄存器变量的重命名选项</li>
<li>Fastest，smallest：优化代码大小这个设置启用“Faster”所有的优化，一般不增加代码大小，它还执行旨在减小代码大小的进一步优化。</li>
</ul>
<h4 id="方案三：将蓝牙打印页面的预览视图中所有-define-NSLog-format-…-do-对应的-NSLog-注释掉。"><a href="#方案三：将蓝牙打印页面的预览视图中所有-define-NSLog-format-…-do-对应的-NSLog-注释掉。" class="headerlink" title="方案三：将蓝牙打印页面的预览视图中所有 #define NSLog(format, …) do 对应的 NSLog 注释掉。"></a><del>方案三：将蓝牙打印页面的预览视图中所有 <strong>#define NSLog(format, …) do</strong> 对应的 <strong>NSLog</strong> 注释掉。<del></del></del></h4><p>最后发现将打印页面的所有输出语句注释掉不会起到任何作用，因此，只剩下 <strong>方案二</strong> 可行了。</p>
<h4 id="方案四：从源码编译入手，利用-Clang-在编译为可执行文件前，过滤编译过程中影响打印的操作。"><a href="#方案四：从源码编译入手，利用-Clang-在编译为可执行文件前，过滤编译过程中影响打印的操作。" class="headerlink" title="方案四：从源码编译入手，利用 Clang 在编译为可执行文件前，过滤编译过程中影响打印的操作。"></a>方案四：从源码编译入手，利用 <strong>Clang</strong> 在编译为可执行文件前，过滤编译过程中影响打印的操作。</h4><p>相对而言，这种方式是最复杂，最有难度的一种方式。但却能追本溯源，从根本上明白为什么无法打印？</p>
<h3 id="从源码到可执行文件"><a href="#从源码到可执行文件" class="headerlink" title="从源码到可执行文件"></a>从源码到可执行文件</h3><p>Low Level Virtual Machine (LLVM) 是一个开源的编译器架构，Clang 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。</p>
<p>利用<a href="http://www.alonemonkey.com/2016/12/21/learning-llvm/" target="_blank" rel="external">LLVM</a> 将源码编译为可被不同语言识别的中间表示(IR)。</p>
<h4 id="可以用Clang做什么"><a href="#可以用Clang做什么" class="headerlink" title="可以用Clang做什么?"></a>可以用Clang做什么?</h4><h5 id="1-libclang进行语法分析"><a href="#1-libclang进行语法分析" class="headerlink" title="1. libclang进行语法分析"></a>1. libclang进行语法分析</h5><p>可以使用libclang里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。</p>
<h5 id="2-LibTooling"><a href="#2-LibTooling" class="headerlink" title="2. LibTooling"></a>2. LibTooling</h5><p>对语法树有完全的控制权，可以作为一个单独的命令使用，如：clang-format</p>
<h5 id="3-ClangPlugin"><a href="#3-ClangPlugin" class="headerlink" title="3. ClangPlugin"></a>3. ClangPlugin</h5><p>对语法树有完全的控制权，作为插件注入到编译流程中，可以影响build和决定编译过程。目录:llvm/tools/clang/examples</p>
<p>这里蓝牙打印的在release模式下无法打印的问题，涉及到编译器编译至可执行文件时，中间所做的优化处理。可以尝试从编译流程入手，进行相应的语法分析，过滤掉非必须但影响蓝牙打印的优化操作。</p>
<blockquote>
<p>通过遍历语法树，去修改里面的方法名和返回变量名。</p>
</blockquote>
<p>.cpp 文件，在编译源文件时，C++编译器会对符号(函数或变量)名作某些修正，修正后生成目标文件的后缀为.cpp。</p>
<blockquote>
<p>基于 Pass，我们可以做什么？ 我们可以编写自己的 Pass 去混淆代码，以增加他人反编译的难度。</p>
</blockquote>
<ol>
<li>LLVM 编译一个源文件的过程：<br>预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</li>
<li>基于 LLVM，我们可以做什么？<ol>
<li>做语法树分析，实现语言转换 OC 转 Swift、JS or 其它语言，字符串加密。</li>
<li>编写 ClangPlugin，命名规范，代码规范，扩展功能。</li>
<li>编写 Pass，代码混淆优化”</li>
</ol>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://halfrost.github.io/2016/08/手把手教你给一个iOS-app配置多个环境变量/" target="_blank" rel="external">手把手教你给一个iOS app配置多个环境变量</a></p>
<p><a href="https://stackoverflow.com/questions/3784583/xcode-debug-vs-release-build-when-debugging" target="_blank" rel="external">XCode debug vs release build when debugging</a></p>
<p><a href="http://www.alonemonkey.com/2016/12/21/learning-llvm/" target="_blank" rel="external">初识 LLVM</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/" target="_blank" rel="external">结构化编译器前端 Clang 介绍</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到在 &lt;strong&gt;Release&lt;/strong&gt; 模式下 &lt;strong&gt;80mm蓝牙打印机&lt;/strong&gt; 无法打印的问题，最终的解决方式都是围绕 &lt;strong&gt;Debug&lt;/strong&gt; 和 &lt;strong&gt;Release&lt;/strong&gt; 这两种模式展开
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="编译器" scheme="http://XibHe.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="环境变量" scheme="http://XibHe.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>从一个数据量过多的优化说起</title>
    <link href="http://XibHe.github.io/2018/04/18/SQLOptimize/"/>
    <id>http://XibHe.github.io/2018/04/18/SQLOptimize/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-06-28T15:37:39.633Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间遇到一个问题，程序中查询患者信息的功能，当患者数据量超过 <strong>30000</strong> 条时，会出现卡顿，APP 无响应的问题。在处理这个需求时，需要将本地数据库中的全部患者数据查询出来，然后按照从 <strong>A - Z</strong> 的患者首字母进行分组排序。对于不属于 <strong>A - Z</strong> 的数据，将其分为 <strong>#</strong> 组。</p>
<h3 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h3><p>更新记录:</p>
<ul>
<li>2018 年 04 月，第一版。</li>
<li>2018 年 06 月，补充后续的优化方案。</li>
</ul>
<h2 id="卡顿问题的解决"><a href="#卡顿问题的解决" class="headerlink" title="卡顿问题的解决"></a>卡顿问题的解决</h2><p>原来的代码逻辑如下：</p>
<pre><code class="objectivec">// 全部患者数据
_allPatients = [[LZDatabaseHelper sharedInstance] getAllPatient];
NSMutableArray *tempArray = _allPatients.mutableCopy;
    for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) {
        LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
        sectionModel.sectionTitle = [NSString stringWithFormat:@&quot;%c&quot;,a];
        for (int i = 0; i &lt; _allPatients.count; i++) {
            PationMoedl *pationModel = _allPatients[i];
            if (pationModel.userShortName.length &gt; 0) {
                char temp = [pationModel.userShortName characterAtIndex:0];
                if (a == temp) {
                    [sectionModel.patientList addObject:pationModel];
                    [tempArray removeObject:pationModel];
                }
            }
        }
        if (sectionModel.patientList.count &gt;0) {
            [self.patientArray addObject:sectionModel];
        }
    }
    LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
    sectionModel.sectionTitle = @&quot;#&quot;;
    if (tempArray.count &gt; 0) {
        [sectionModel.patientList addObjectsFromArray:tempArray];
        [self.patientArray insertObject:sectionModel atIndex:0];
    }
    [_patientTableView reloadData];
</code></pre>
<p>从上面的代码可以计算出排序的时间复杂度，第一个 <strong>for</strong> 循环执行 <strong>26</strong> 次，嵌套在内的第二个 <strong>for</strong> 循环会执行 <strong>30000</strong> 次。时间复杂度用大写字母 <strong>O</strong> 来表示，因此该排序的时间复杂度是:</p>
<font color="#e5622" size="5"> O(26 * 30000) </font>

<p>也就是说当点击对应的按钮查看患者后，会执行 <strong>780000</strong> 次 <strong>for</strong> 去遍历全部患者，并将符合首字母符合 <strong>A - Z</strong> 的患者添加到 <strong>sectionModel.patientList</strong> 数组中，然后刷新列表展示排好序的数据。这也是为什么会出现患者量少时没有问题，一但患者量达到上万条时就会出现点击对应按钮后，就会出现卡顿的问题。要解决这样的问题，需要从如何降低时间复杂度着手。</p>
<p>尝试了 <strong>4</strong> 种不同的方案，如下：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一:"></a>方案一:</h3><p>算法角度上，以空间换时间，一下子就创建好 26 个存放 A - Z 首字母排序的数组，以减少循环次数为目的，循环一次，找到对应首字母序列的数据，从数据源中移除这些数据；然后，继续开始下一次遍历，以此类推，直到查询出所有排序数组。（时间复杂度，空间复杂度）</p>
<ul>
<li><p>桶排序算法</p>
</li>
<li><p>快速排序算法</p>
</li>
</ul>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二:"></a>方案二:</h3><p>几种不同遍历方式的比较，试图通过比较查询效率，找到最快的遍历方式。</p>
<ul>
<li>经典 for 循环</li>
<li>for in (NSFastEnumeration)</li>
<li>KVC 集合运算符 </li>
<li>enumerateObjectsUsingBlock</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent) </li>
</ul>
<p>初始化 <strong>100</strong> 个对象的遍历操作所消耗的时间(毫秒级): </p>
<ul>
<li>经典for循环 — 0.0023</li>
<li>for in (NSFastEnumeration) — 0.003090</li>
<li>makeObjectsPerformSelector — 0.001120</li>
<li>kvc集合运算符 — 0.004272</li>
<li>enumerateObjectsUsingBlock — 0.001145</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent) — 0.001605</li>
</ul>
<p>这样并不能看出什么结论，当初始化 <strong>1000000</strong> 个对象时就会有很大差距</p>
<ul>
<li>经典for循环 — 1.246721</li>
<li>for in (NSFastEnumeration) — 0.025955</li>
<li>makeObjectsPerformSelector — 0.068234</li>
<li>kvc集合运算符 — 21.677246</li>
<li>enumerateObjectsUsingBlock — 0.586034</li>
<li>enumerateObjectsWithOptions(NSEnumerationConcurrent) — 0.722548</li>
</ul>
<p>可以看出当数据量少时，<strong>for in</strong> 的速度并不突出，但当数量达到一定量级后，<strong>for in</strong> 的遍历速度就体现出来了。</p>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三:"></a>方案三:</h3><p>折中方案，为了避免查询时卡死主线程，将查询方法放在 <strong>异步线程</strong> 里，然后在 <strong>主线程</strong> 中刷新数据源。如下：</p>
<pre><code class="objectivec">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{

        for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) {
            LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
            sectionModel.sectionTitle = [NSString stringWithFormat:@&quot;%c&quot;,a];

            for (PationMoedl *pationModel in _allPatients) {
                // 根据数据库中的患者简称，将对应简称的model存入sectionModel.patientList中
                if (pationModel.userShortName.length &gt; 0) {
                    char temp = [pationModel.userShortName characterAtIndex:0];
                    if (a == temp) {
                        [sectionModel.patientList addObject:pationModel];
                        [tempArray removeObject:pationModel];
                    }
                }
            }
            if (sectionModel.patientList.count &gt;0) {
                [self.patientArray addObject:sectionModel];
            }
        }

        LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
        sectionModel.sectionTitle = @&quot;#&quot;;
        if (tempArray.count &gt; 0) {
            [sectionModel.patientList addObjectsFromArray:tempArray];
            [self.patientArray insertObject:sectionModel atIndex:0];
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            [_patientTableView reloadData];
            [MBProgressHUD hideHUDForView:self];
        });

});
</code></pre>
<h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><p>方案4也是最终采用的方案，主要时间排序的功能用 <strong>SQL</strong> 语句去实现，在每次遍历时，传入一个当前的序列，通过执行数据库查询语句得到一个分好的序列数组，这样就大大减少了 <strong>for</strong> 循环的次数，提高了速度。但为了不卡死线程，仍然需要与 <strong>GCD</strong> 结合起来使用。如下：</p>
<pre><code class="objectivec">[MBProgressHUD showMessag:@&quot;加载中&quot; toView:self];
// 1. 将整个查询的耗时操作放到 GCD 中
dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
//  查询出所有患者数据，为搜索功能提供数据源
     _allPatients = [[LZDatabaseHelper sharedInstance] getAllPatientForIndexes];
     // 2. 从 A - Z 进行 26 次遍历
    for (char a = &#39;A&#39;; a &lt;=&#39;Z&#39;; a ++) {
        NSString *orderNumber = [NSString stringWithFormat:@&quot;%c&quot;,a];
        // 3. 通过 SQL 语句查出对应首字母序列的返回的数组
        NSArray *patientRankArray = [[LZDatabaseHelper sharedInstance] getPatientGroup:orderNumber];
        // 4. 将查询到的某一序列数组与分组名称进行绑定
        if (patientRankArray &amp;&amp; patientRankArray.count &gt; 0) {
            LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
            sectionModel.sectionTitle = orderNumber;
            [sectionModel.patientList addObjectsFromArray:patientRankArray];
            [self.patientArray addObject:sectionModel];
        }
    }

        // 5. 通过 SQL 语句查出其他非 A-Z 的数据
        NSArray *otherArray = [[LZDatabaseHelper sharedInstance] getPatientMistakeGroup];

        // 6. 将查询到的非 A-Z 插入到患者数据源中
        if (otherArray &amp;&amp; otherArray.count &gt; 0) {
            LZPatientListSectionModel *sectionModel = [[LZPatientListSectionModel alloc] init];
            sectionModel.sectionTitle = @&quot;#&quot;;
            [sectionModel.patientList addObjectsFromArray:otherArray];
            [self.patientArray insertObject:sectionModel atIndex:0];
        }

        // 7. 主线程中刷新列表
        dispatch_async(dispatch_get_main_queue(), ^{
            [_patientTableView reloadData];
            [MBProgressHUD hideHUDForView:self];
        });

    });
</code></pre>
<p>具体步骤如下：</p>
<ol>
<li>将整个查询的耗时操作放到 GCD 中；</li>
<li>从 A - Z 进行 26 次遍历；</li>
<li>通过 SQL 语句查出对应首字母序列的返回的数组；</li>
<li>将查询到的某一序列数组与分组名称进行绑定；</li>
<li>通过 SQL 语句查出其他非 A-Z 的数据；</li>
<li>将查询到的非 A-Z 插入到患者数据源中；</li>
<li>主线程中刷新列表。</li>
</ol>
<p>这里将最为耗时的对应首字母遍历数据操作，通过 <strong>SQL</strong> 查询语句来实现。那么 <strong>SQL</strong> 语句的查询速度究竟如何呢？可以在处理 <strong>SQL</strong> 查询的方法里增加计算方法执行耗时的代码：</p>
<pre><code class="objectivec">// 记录开始时间，放在方法执行的最前面
NSDate *startDate = [NSDate date];

// 记录结束时间，放到方法执行结束的位置
NSDate *finishDate = [NSDate date];
NSTimeInterval interval = [finishDate timeIntervalSinceDate:startDate];
NSLog(@&quot;查询全部患者数据耗时: %f&quot;,interval);
</code></pre>
<p>返回的时间戳大概为 <strong>0.45</strong> 毫秒。</p>
<h2 id="关于数据库查询语句的优化"><a href="#关于数据库查询语句的优化" class="headerlink" title="关于数据库查询语句的优化"></a>关于数据库查询语句的优化</h2><ol>
<li>建立索引</li>
<li>不要把SQL语句写得太复杂</li>
<li>避免过度使用 Select * 查询所有数据 （实际使用时只需要某一个或几个字段）</li>
<li>统一 <strong>SQL</strong> 语句的写法 (主要区分大小写)</li>
<li><strong>REPLACE INTO</strong> 语句的使用<ul>
<li><em>REPLACE</em> 作用与 <em>INSERT</em> 完全一致，但如果旧表中的行具有相同的值作为一个新行 <em>PRIMARY KEY</em> 或 <em>UNIQUE</em> 索引，旧行插入新行之前删除。</li>
<li><em>REPLACE</em> 是一个 <em>MySQL</em> 扩展 <em>SQL</em> 标准。它要么插入要么先删除再插入。</li>
<li>注意，除非表有一个 <em>PRIMARY KEY</em> 或 <em>UNIQUE</em> 索引，否则使用 <em>REPLACE</em> 语句是没有意义的。</li>
</ul>
</li>
<li><p><strong>SQL</strong> 语句的拓展</p>
<ul>
<li><em>sqlite</em> 截取字符串前几位后再进行查询</li>
<li>在 <em>sqlite</em> 中使用 <em>regex</em> 进行查询</li>
<li><p>SUBSTR()，SQL 中的 substring 函数是用来抓出一个栏位资料中的其中一部分。这个函数的名称在不同的数据库中不完全一样：</p>
<blockquote>
<p>MySQL: SUBSTR( ), SUBSTRING( )<br>Oracle: SUBSTR( )<br>SQL Server: SUBSTRING( )</p>
</blockquote>
</li>
<li><p>upper()函数，将小写转化为大写；lower()函数，将大写转化为小写。</p>
</li>
</ul>
</li>
</ol>
<pre><code class="objectivec">// 根据 A - Z 进行分组查询
NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, userName, userShortName, birthday, sex, phone, address FROM table_sickPerson WHERE clinicId = &#39;%@&#39; AND status like &#39;0&#39; AND isDelete like &#39;0&#39; AND SUBSTR(upper(userShortName),1,1) = &#39;%@&#39; &quot;,clinkId,orderNumber];
</code></pre>
<ul>
<li>GLOB 用来连接正则表达式的关键字</li>
</ul>
<pre><code class="objectivec">// 查询非 A - Z 的数据
NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, userName, userShortName, birthday, sex, phone, address FROM table_sickPerson WHERE clinicId = &#39;%@&#39; AND status like &#39;0&#39; AND isDelete like &#39;0&#39; AND SUBSTR(upper(userShortName),1,1) GLOB &#39;[^A-Z]&#39; &quot;,clinkId];
</code></pre>
<p>之前没有在 <strong>SQLite</strong> 中使用过 <strong>regex</strong> 还以为不支持呢，最后几经波折，在官网上找到了对应的文档！</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/SQLDataOptimize_thumbnail01.png" alt="SQLite官网"></p>
<h2 id="ONE-PIECE"><a href="#ONE-PIECE" class="headerlink" title="ONE PIECE"></a>ONE PIECE</h2><h3 id="一个关于-CoreData-的问题"><a href="#一个关于-CoreData-的问题" class="headerlink" title="一个关于 CoreData 的问题"></a>一个关于 CoreData 的问题</h3><p><strong>Core Data</strong> 是 <strong>iOS5</strong> 之后才出现的一个框架，本质上是对 <strong>SQLite</strong> 的一个封装，它允许按照实体-属性-值模型组织数据，并以 <strong>XML</strong>，二进制文件或<strong>SQLite</strong> 数据文件的格式将其序列化。<strong>Core Data</strong> 允许用户使用代表实体和实体间关系的高层对象来操作数据。它也可以管理序列化的数据，提供对象生存期管理与 <strong>object graph</strong> 管理，包括存储。<strong>Core Data</strong> 直接与 <strong>SQLite</strong> 交互，避免开发者使用原本的 <strong>SQL</strong> 语句。</p>
<p>这里在尝试使用 <strong>Core Data</strong> 时遇到一个问题，在获取模型路径，创建模型对象时，一直报错：</p>
<pre><code class="objectivec">    NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@&quot;testModel&quot; withExtension:@&quot;momd&quot;];
    _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    return _managedObjectModel;
</code></pre>
<pre><code class="objectivec"> *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;CoreData: Cannot load NSManagedObjectModel.  nil is an illegal URL parameter&#39;
</code></pre>
<p><strong>Core Data</strong> 数据库的名字和封装类里的名字是一致的。</p>
<h3 id="使用Blob存储NSData遇到的问题"><a href="#使用Blob存储NSData遇到的问题" class="headerlink" title="使用Blob存储NSData遇到的问题"></a>使用Blob存储NSData遇到的问题</h3><p>先通过 <em>UPDATE</em> 语句更新数据，</p>
<pre><code class="objectivec">// 更新faceFeatureData
+ (void)updateFaceFeatureData:(NSData *)faceFeatureData
{
    FMDatabase *dataBase = [ConfigurateDB open];
    [dataBase beginTransaction];

    NSString *sql = [NSString stringWithFormat:@&quot;UPDATE Register SET faceFeatureData = &#39;%@&#39; WHERE id = &#39;1&#39;&quot;,faceFeatureData];
    [dataBase executeUpdate:sql];

    [dataBase commit];
}
</code></pre>
<p>再通过 <em>SELECT</em> 获取更新的值。</p>
<pre><code class="objectivec">// 获取个人信息
+ (AFRPerson *)getInformationWithUserID:(NSInteger)Id
{
    FMDatabase *dataBase = [ConfigurateDB open];
    NSString *sql = [NSString stringWithFormat:@&quot;SELECT * FROM Register WHERE id = &#39;%ld&#39;&quot;,Id];
    FMResultSet * resultSet = [dataBase executeQuery:sql];
    AFRPerson *person = nil;
    while ([resultSet next]) {
        person = [[AFRPerson alloc] init];

        person.Id = [resultSet intForColumn:@&quot;id&quot;];
        person.faceID  = [resultSet intForColumn:@&quot;faceID&quot;];
        person.faceFeatureData = [resultSet dataForColumn:@&quot;faceFeatureData&quot;];
        person.name = [resultSet stringForColumn:@&quot;name&quot;];
        person.attendanceStatus = [resultSet stringForColumn:@&quot;attendanceStatus&quot;];
    }

    [resultSet close];

    return person;
}
</code></pre>
<p>发现 <em>person.faceFeatureData</em> 这个 <em>NSData</em> 类型的属性值，更新前与更新后再次获取的字节长度不一致，前者为：22020 bytes，后者为：48096 bytes。正常结果二者应是一致的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>第一手资料永远是官方文档！！！</li>
<li>算法真的真的很重要! ! !</li>
<li>很多性能问题，首先可以先从算法角度进行思考；</li>
<li>使用 <strong>GCD</strong> 多线程技术来处理耗时任务；</li>
<li>算法，不同遍历方式进行比较，<strong>SQL</strong>查询语句的优化，<strong>GCD</strong> 这几种方式相结合总能给人意想不到的惊喜，没有一种解决方案是孤立存在的。</li>
</ul>
<p>对症下药吧！将提高查询效率和减少遍历次数二者相结合。做完这次优化后，还是想问一句：这是最优的方案吗？还可以进一步优化吗? </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后，这种方式虽然可以缓解数据量达到 <em>30000</em> 条时的卡顿状况。但打开列表页面时，仍然会 <em>loading</em> 两三秒， 最终处理方案是：当数据量大于 <em>5000</em> 条时，进行分页加载，一次加载 <em>200</em> 条，此时就没有必要将数据按首字母缩写排序了，可通过搜索框搜索出对应患者；当数据量小于 <em>5000</em> 时，仍保持之前的逻辑。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.sqlite.org/search?s=d&amp;q=regexp" target="_blank" rel="external">sqlite.org Documentation</a></p>
<p><a href="https://www.w3cschool.cn/sql/7vn4tfq0.html" target="_blank" rel="external">w3cschool SQL</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html" target="_blank" rel="external">13.2.9 REPLACE Syntax</a></p>
<p><a href="https://stackoverflow.com/questions/7793488/regex-in-sqlite-and-objectivec" target="_blank" rel="external">Regex in SQLite and ObjectiveC</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Core_Data" target="_blank" rel="external">Core Data</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间遇到一个问题，程序中查询患者信息的功能，当患者数据量超过 &lt;strong&gt;30000&lt;/strong&gt; 条时，会出现卡顿，APP 无响应的问题。在处理这个需求时，需要将本地数据库中的全部患者数据查询出来，然后按照从 &lt;strong&gt;A - Z&lt;/strong&gt; 的患
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="SQLite" scheme="http://XibHe.github.io/tags/SQLite/"/>
    
      <category term="性能优化" scheme="http://XibHe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解RunLoop</title>
    <link href="http://XibHe.github.io/2018/03/18/RunLoopAnalysis/"/>
    <id>http://XibHe.github.io/2018/03/18/RunLoopAnalysis/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-05-14T15:06:57.739Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客介绍了使用 <em>WKWebView</em> 进行性能调优，以及使用中遇到的问题。当在弱网环境下频繁切换 <em>H5</em> 页面时，就会出现应用卡死的情况。<a href="http://xibhe.com/2018/02/03/WKWebView-disabuse/" target="_blank" rel="external">使用WKWebView进行性能调优</a>，控制台会报三个错误，其中一个错误是：</p>
<pre><code class="objectivec">2018-02-01 11:09:01.952689+0800 CloudOfficeTest[614:68129] void SendDelegateMessage(NSInvocation *): delegate (webView:decidePolicyForNavigationAction:request:frame:decisionListener:) failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode
</code></pre>
<p>错误中出现了 <em>main run loop mode: kCFRunLoopDefaultMode</em> 的信息提示，最后虽然将项目中的 <em>UIWebView</em> 替换为 <em>WKWebView</em> ( <em>WKWebView</em>的内存消耗相比 <em>UIWebView</em> 低了一个数量级)。但却没有将这个报 <em>RunLoop</em> 的错误解释清楚，今天就结合一些实例叙述一下自己对 <em>RunLoop</em> 的浅见。</p>
<h3 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h3><p>更新记录:</p>
<ul>
<li>2018 年 03 月，第一版。</li>
<li>2018 年 04 月，补充利用 RunLoop 解决一些问题的 Demo。</li>
</ul>
<h3 id="RunLoop-是什么"><a href="#RunLoop-是什么" class="headerlink" title="RunLoop 是什么"></a>RunLoop 是什么</h3><p><em>Runloop</em> 是 <em>iOS</em> 底层机制，就是一个运行循环，确切的说是为了保证程序会一直运行不退出的死循环。</p>
<p>在 <em>iOS</em> 中的入口函数执行类似逻辑，这里打印只会输出 <em>执行了!!!</em>，并不会输出 <em>有没有执行???</em>，这里开启了一个和主线程相关的 <em>RunLoop</em>，导致 <em>UIApplicationMain</em> 不会返回，一直处在运行中。</p>
<pre><code class="objectivec">int main(int argc, char * argv[]) {
    @autoreleasepool {
        NSLog(@&quot;执行了!!!&quot;);
        // 主线程死循环 --- RunLoop
        int a = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
        NSLog(@&quot;有没有执行???&quot;);
        return a;
    }
}
</code></pre>
<font color="#DC143C" size="3">下面这段内容摘抄自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 中 <em>RunLoop的概念</em> 中的叙述。</font>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常代码逻辑是这样的：</p>
<pre><code class="c">function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code></pre>
<p>这种模型通常被称作<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event loop</a>。<em>Event Loop</em> 在很多系统和框架里都有实现，比如：</p>
<ul>
<li><em>Node.js</em> 的事件处理</li>
<li><em>Windows</em> 程序的消息循环</li>
<li><em>OSX/iOS</em> 的 <em>RunLoop</em></li>
</ul>
<p>实现这种模型的关键的在于：</p>
<blockquote>
<p>如何管理事件/消息，如何让线程在没有处理消息时休眠，以避免资源占用；在有消息到来时立刻被唤醒。</p>
</blockquote>
<p>所以，<em>RunLoop</em> 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的 <em>Event Loop</em> 逻辑。线程执行了这个函数后，就会一直处于这个函数内部 <em>接受消息 –&gt; 等待 –&gt; 处理</em> 的循环中，直到这个循环结束（比如，传入 <em>quit</em> 消息），函数返回。</p>
<p><em>OSX/iOS</em> 系统中，提供了两个这样的对象：<em>NSRunLoop</em> 和 <em>CFRunLoopRef</em>。<em>NSRunLoop</em> 是基于 <em>CFRunLoopRef</em> 的封装，提供了面向对象的 <em>API</em>，但这些 <em>API</em> 不是线程安全的。<em>CFRunLoopRef</em> 是在 <em>CoreFoundation</em> 框架内的，它提供了纯 <em>C函数</em> 的 <em>API</em>，所以这些 <em>API</em> 都是线程安全的。</p>
<h3 id="RunLoop-的作用"><a href="#RunLoop-的作用" class="headerlink" title="RunLoop 的作用"></a>RunLoop 的作用</h3><ol>
<li>保住程序不退出，持续运行；</li>
<li>负责监听程序中的各种事件，如：网络，触摸，定时器等；</li>
<li>渲染 <em>UI</em>；</li>
<li>节省 <em>CPU</em> 资源，提高程序性能；</li>
<li>线程间的通讯。</li>
</ol>
<h3 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h3><font color="#DC143C" size="3">下面这段内容摘抄自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 中 <em>RunLoop 与线程的关系</em> 中的叙述。</font>

<p>苹果不允许直接创建 <em>RunLoop</em>，它只提供了两个自动获取的函数：<em>CFRunLoopGetMain()</em> 和 <em>CFRunLoopGetCurrent()</em>。 这两个函数内部的逻辑大概是下面这样:</p>
<pre><code class="c">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;

/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&amp;loopsLock);

    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }

    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));

    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }

    OSSpinLockUnLock(&amp;loopsLock);
    return loop;
}

CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}

CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
</code></pre>
<ol>
<li>线程和 <em>RunLoop</em> 是一一对应的；</li>
<li>线程刚刚创建时并没有 <em>RunLoop</em>，如果你不主动获取，那它一直不会有；</li>
<li><em>RunLoop</em> 的创建发生在第一次获取时，<em>RunLoop</em> 的销毁发生在线程结束时；</li>
<li>只能在一个线程的内部获取其 <em>RunLoop</em> (主线程除外)。</li>
</ol>
<h3 id="CoreFoundation-中-RunLoop-的组成结构"><a href="#CoreFoundation-中-RunLoop-的组成结构" class="headerlink" title="CoreFoundation 中 RunLoop 的组成结构"></a>CoreFoundation 中 RunLoop 的组成结构</h3><p><em>CoreFoundation</em> 中关于 <em>RunLoop</em> 有5个类：</p>
<ul>
<li><em>CFRunLoopModeRef</em> // 运行模式，每次调用时只能选择一种，在不同模式中做不同的操作。</li>
<li>__CFRunLoop <em> </em>CFRunLoopRef<em>; // 获得当前 </em>RunLoop*</li>
<li>__CFRunLoopSource <em> </em>CFRunLoopSourceRef*; // 事件源</li>
<li>__CFRunLoopObserver <em> </em>CFRunLoopObserverRef*; // 观察者</li>
<li>__CFRunLoopTimer <em> </em>CFRunLoopTimerRef*; // 定时器时间</li>
</ul>
<font color="#DC143C" size="3">下面这段内容摘抄自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 中 <em>RunLoop 对外接口</em> 中的叙述。</font>

<p>其中 <em>CFRunLoopModeRef</em> 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/RunLoopAnalysis_01.png?imageView/4/w/300" alt="CFRunLoopModeRef的关系"></p>
<ol>
<li><strong>CFRunLoopModeRef</strong>，一个 <strong>RunLoop</strong> 包含若干个 <strong>Mode</strong><br>，每个 <strong>Mode</strong> 又包含若干个 <strong>Source/Timer/Observer</strong>。每次调用 RunLoop的主函数时，只能指定其中一个 <strong>Mode</strong>，这个 <strong>Mode</strong> 被称为 <strong>CurrentMode</strong>。如果需要切换 <strong>Mode</strong>，只能退出 <strong>RunLoop</strong>，再重新指定一个 <strong>Mode</strong> 进入。这样做主要是为了分隔开不同组的 <strong>Source/Timer/Observer</strong>，让其互不影响。</li>
<li><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。<strong>source</strong> 有两个版本：<strong>source0</strong> 和 <strong>source1</strong>。<ol>
<li><strong>Source0</strong> 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <strong>CFRunLoopSourceSignal(source)</strong>，将这个 <strong>Source</strong> 标记为待处理，然后手动调用 <strong>CFRunLoopWakeUp(runloop)</strong> 来唤醒 <strong>RunLoop</strong>，让其处理这个事件。</li>
<li><strong>Source1</strong> 包含了一个 <strong>mach_port</strong> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 <strong>Source</strong> 能主动唤醒 <strong>RunLoop</strong> 的线程。</li>
</ol>
</li>
<li><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 <strong>NSTimer</strong> 是 <strong>toll-free bridged</strong> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 <strong>RunLoop</strong> 时，<strong>RunLoop</strong> 会注册对应的时间点，当时间点到期时，<strong>RunLoop</strong> 会被唤醒一执行那个回调。</li>
<li><strong>CFRunLoopObserverRef</strong> 是观察者，每个 <strong>Observer</strong> 都包含了一个回调（函数指针），当 <strong>RunLoop</strong> 的状态发生变化时，观察者就能通过回调接受这个变化。可以观察的时间点有以下几个：</li>
</ol>
<pre><code class="objectivec">/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 即将进入休眠
    kCFRunLoopExit         = (1UL &lt;&lt; 7), // 即将退出Loop
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};
</code></pre>
<blockquote>
<p>上面的 <em>Source/Timer/Observer</em> 被统称为 <em>mode item</em>，一个 <em>item</em> 可以同时加入多个 <em>mode</em>。但一个 <em>item</em> 被重复加入同一个 <em>mode</em> 时，是不会有效果的。如果一个 <em>mode</em> 中一个 <em>item</em> 都没有，则 <em>RunLoop</em> 会直接退出，不进入循环。</p>
</blockquote>
<h3 id="RunLoop的-Mode"><a href="#RunLoop的-Mode" class="headerlink" title="RunLoop的 Mode"></a>RunLoop的 Mode</h3><p>关于 <em>RunLoop</em> 的 <em>Mode</em> 可以通过下面的例子，展开来说，</p>
<pre><code class="objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerCurrentThread) userInfo:nil repeats:YES];
    // 将timer加入到RunLoop中
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
}

- (void)timerCurrentThread
{
    static int a = 0;
    NSLog(@&quot;当前线程%@---%d&quot;,[NSThread currentThread],a++);
}
</code></pre>
<p>这里将 <em>timer</em> 加入到 <em>RunLoop</em> 中，通过当前运行的 <em>RunLoop</em><br>观察事件的执行。这里需要注意给 <em>timer</em> 添加的是 <em>NSDefaultRunLoopMode</em> 模式。</p>
<p>那么，在上面例子的基础上，我再添加一个 <em>UITextView</em> 控件，编译运行后，当滑动控件时，发现控制台不会继续输出 <em>timerCurrentThread</em> 方法中的打印。是因为阻塞了主线程导致的吗？不是的，这里 <em>RunLoop</em> 无法同时处理屏幕触摸事件和 <em>timer</em> 回调。此时，试着将模式替换为 <em>UITrackingRunLoopMode</em>，</p>
<pre><code class="objectivec">[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];
</code></pre>
<p>再滑动 <em>UITextView</em> 控件，控制台会继续输出。结合上面的所说的一个 <em>RunLoop</em> 包含若干个 <em>Mode</em>，每个 <em>Mode</em> 又包含若干个 <em>Source/Timer/Observer</em>，例子中的关系可以这样表示，如图所示，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/RunLoopAnalysis_02.png" alt=""></p>
<p>这里在 <em>UITrackingRunLoopMode</em>（UI模式）下的优先级最高，当通过触摸事件唤醒该模式时，当前 <em>RunLoop</em> 会忽落掉其它模式，优先处理UI模式下的事件。 同样在UI模式下，没有触摸手机屏幕时，即使有 <em>timer</em> 回调也不会继续处理，因此，当不再滑动控件时，控制台就不会再有任何输出了。如果想要兼顾默认模式和UI模式，可以这样做：</p>
<pre><code class="objectivec">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];
</code></pre>
<p>将 <em>timer</em> 同时添加到两种模式中，在触摸屏幕时(UI模式)，会处理 <em>timer</em> 回调，当不在触摸屏幕时(默认模式)，也会处理 <em>timer</em> 回调。那么有没有一种模式可以兼顾这两种模式呢？答案是肯定的。如下，</p>
<pre><code class="objectivec">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>
<p>这里的 <em>NSRunLoopCommonModes</em> (占位模式)，相当于前两种模式的叠加。</p>
<blockquote>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>— 摘录自 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
</blockquote>
<p>系统默认注册了5个Mode，如下：</p>
<ol>
<li><em>NSDefaultRunLoopMode</em> 默认模式</li>
<li><em>UITrackingRunLoopMode</em> UI模式</li>
<li><em>NSRunLoopCommonModes</em> 占位模式</li>
<li>初始化模式</li>
<li>系统内核模式</li>
</ol>
<p>经常用到的是前三种模式。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><h3 id="利用-RunLoop-解决一些问题"><a href="#利用-RunLoop-解决一些问题" class="headerlink" title="利用 RunLoop 解决一些问题"></a>利用 RunLoop 解决一些问题</h3><h4 id="1-RunLoop-渲染UI-—-减少滑动卡顿"><a href="#1-RunLoop-渲染UI-—-减少滑动卡顿" class="headerlink" title="1. RunLoop 渲染UI — 减少滑动卡顿"></a>1. RunLoop 渲染UI — 减少滑动卡顿</h4><p>在 <em>tableView</em> 上加载多张高清大图时，在拖拽很快的时候，所有的图片渲染都交给 <em>RunLoop</em> 一次循环中处理掉，这样就会导致滑动时卡顿的问题。那么该如何解决呢？这里以 <em>iPhone 6s</em> 为例，<em>tableView</em> 最多一次显示18张图片，分为18次加入到 <em>RunLoop</em> 中，而不是一次。</p>
<p>具体怎么做呢？通过监听 <em>RunLoop</em> 的循环！通过 <em>observer</em> 观察活动的不同状态。具体步骤：</p>
<ul>
<li>添加观察者，观察 Runloop 循环；</li>
<li>观察状态变化；</li>
<li>将原来添加图片的代码加入到数组中</li>
<li>在 Runloop 的回调方法中，拿出数组中加载图片的代码，执行。</li>
</ul>
<p>关键代码如下：</p>
<pre><code class="objectivec">- (void)addRunloopObserver
{
    // 1. 得到runloop
    CFRunLoopRef runloop = CFRunLoopGetCurrent();
    // 2. 获取上下文
    CFRunLoopObserverContext context = {
        0,
        (__bridge void *)self,
        &amp;CFRetain,
        &amp;CFRelease,
        NULL
    };
    // 3. 创建观察者
    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(NULL, kCFRunLoopBeforeWaiting, YES, 0, &amp;callback, &amp;context);
    // 4. 添加观察者
    CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);
    // 5. 释放
    CFRelease(observer);
}

#pragma mark - 在回调里面加载图片（Runloop循环一次加载一次）
void callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){

    NSLog(@&quot;%@&quot;,info);
    LoadImageViewController *vc = (__bridge LoadImageViewController *)info;
    if (vc.tasks.count == 0) {
        return;
    }

    runloopBlock taskBlock = vc.tasks.firstObject;
    taskBlock();
    [vc.tasks removeObjectAtIndex:0];
}
</code></pre>
<h4 id="2-通过-RunLoop-让-Crash-的-App-回光返照"><a href="#2-通过-RunLoop-让-Crash-的-App-回光返照" class="headerlink" title="2. 通过 RunLoop 让 Crash 的 App 回光返照"></a>2. 通过 RunLoop 让 Crash 的 App 回光返照</h4><p>由 <em>SIGABRT</em> 引起的 <em>crash</em> 是系统发这个 <em>SIGABRT</em> 给 App，程序收到这个<em>SIGABRT</em> 后，就会把主线程的 <em>RunLoop</em> 杀死，程序就挂掉了。这个例子只针对 <em>SIGABRT</em> 引起的 <em>Crash</em> 有效。</p>
<pre><code class="objectivec">CFRunLoopRef runloop = CFRunLoopGetCurrent();  
    //获取所有Mode，因为可能有很多Mode，每个Mode都需要跑，此处可以选择提交下崩溃信息之类的  
    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;程序崩溃了&quot; message:@&quot;崩溃信息&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil];  
    [alertView show];  
    NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(runloop));  
    while (1) {  
        //快速切换Mode  
        for (NSString *mode in allModes) {  
            CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);  
        }  
    }
</code></pre>
<font size="4"> 未完善Demo： <a href="https://github.com/XibHe/RunLoopCase" target="_blank" rel="external">https://github.com/XibHe/RunLoopCase</a></font>

<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>在准备写这篇博客前，第一反应就是一定要参考 <a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 两年前写的 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 这篇文章，但当花了一天时间看完 <a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 的文章后，又不知道该如何下手了？脑子里满是 <a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 博客的影子。<a href="https://blog.ibireme.com" target="_blank" rel="external">ibireme</a> 的这篇文章简直就是 iOS 开发界的 <strong>《春江花月夜》</strong>，给人一种 <strong>“孤篇压全唐”</strong> 的感觉。</p>
<p>自己起的调太高了，为了不跑调，就只能假唱了。这篇文章中有一半内容是<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> 的原话。写到最后，才发现这哪里是自己对 <strong>RunLoop</strong> 的深入理解？写的明明是自己的挣扎与不甘啊！从事 iOS 开发四年的我，又该何去何从呢？愿与诸君共勉：</p>
<blockquote>
<p>心之所向，身之所往；道阻且长，行则将至。</p>
</blockquote>
<p>最后，得知 <a href="https://blog.ibireme.com/2017/09/01/diary/#more-42043" target="_blank" rel="external">ibireme</a> 去岁身体有恙，想来现在早已康复。祝：一切安好！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
<p><a href="https://github.com/diwu/RunLoopWorkDistribution" target="_blank" rel="external">RunLoopWorkDistribution</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客介绍了使用 &lt;em&gt;WKWebView&lt;/em&gt; 进行性能调优，以及使用中遇到的问题。当在弱网环境下频繁切换 &lt;em&gt;H5&lt;/em&gt; 页面时，就会出现应用卡死的情况。&lt;a href=&quot;http://xibhe.com/2018/02/03/WKWebView-di
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="RunLoop" scheme="http://XibHe.github.io/tags/RunLoop/"/>
    
      <category term="CFRunLoopObserverRef" scheme="http://XibHe.github.io/tags/CFRunLoopObserverRef/"/>
    
  </entry>
  
  <entry>
    <title>使用WKWebView进行性能调优</title>
    <link href="http://XibHe.github.io/2018/02/03/WKWebView-disabuse/"/>
    <id>http://XibHe.github.io/2018/02/03/WKWebView-disabuse/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2018-03-30T03:52:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周，用户频繁反应一个问题：切换到某个功能页面后，加载H5页面相应时间过长，当H5页面未展示出来时，此时，再切换到其他页面，App会卡死。我们试着在公司的网络环境下复现这个问题，但并未复现。</p>
<h2 id="错误的尝试"><a href="#错误的尝试" class="headerlink" title="错误的尝试"></a>错误的尝试</h2><p>最开始时并没有意识到是webView的原因，反而因为前几天刚解决了一个UI线程的bug，将这个卡顿问题主观上当做线程问题去解决。基于此做了以下操作：</p>
<ol>
<li>增加webView加载失败的代理方法；</li>
<li>在加载完成和加载失败时，取消加载进度动画的展示；</li>
<li>在将项目中的页面替换为 <strong>WKWebView</strong> 后，发现在访问下个H5页面时，无法共享 <strong>Cookie</strong> 的问题（下面会详细说下这个问题是如何解决的），导致无法获取到已经验证成功的用户登录信息。</li>
</ol>
<p>先期采用方法1和方法2，但测试时还是会造成卡顿。后期替换为 <strong>WKWebView</strong> 后，亟待解决 <strong>Cookie</strong> 无法共享的问题，想着能不能在每次加载H5页面时，都在请求链接后面拼上用户信息的各种参数，经测试，这样做仍然无法解决页面跳转后读取用户信息的bug。而且还因每次访问页面频繁与服务器进行验证，给服务器带来了性能压力。</p>
<h2 id="问题的复现"><a href="#问题的复现" class="headerlink" title="问题的复现"></a>问题的复现</h2><p>这时考虑到用户应该是在弱网环境下进行操作，遇到的问题。于是，使用网络封包分析工具Charles模拟慢速网络。选择Throttle present：56 kbps Modem。此时，再切换页面，先切换到那个加载H5的页面，然后再来回切换其他几个页面，就会出现APP卡死的情况。(这里需要说明的是其他切换的页面有4个同样是加载H5页面，一共有8个主界面)。</p>
<p>现在问题基本可以明确了，每次加载H5页面时都要初始化webView导致了程序内存消耗过大，造成APP卡死。</p>
<h2 id="控制台报错"><a href="#控制台报错" class="headerlink" title="控制台报错"></a>控制台报错</h2><p>调试时，在程序频繁切换刷新页面直至卡死阶段，控制台一直报错，主要报错如下：</p>
<h3 id="1-Domain-NSURLErrorDomain-Code-999"><a href="#1-Domain-NSURLErrorDomain-Code-999" class="headerlink" title="1. Domain=NSURLErrorDomain Code=-999"></a>1. <strong>Domain=NSURLErrorDomain Code=-999</strong></h3><pre><code class="objectivec">&lt;LZoutsourceViewController.m : 226&gt; -[LZoutsourceViewController webView:didFailProvisionalNavigation:withError:]
2018-01-31 21:02:22.084257+0800 CloudOfficeTest[9230:4603782] error:Error Domain=NSURLErrorDomain Code=-999 &quot;(null)&quot; UserInfo={NSErrorFailingURLStringKey=http://test.net/h5/zskt/spkt.html? _WKRecoveryAttempterErrorKey=&lt;WKReloadFrameErrorRecoveryAttempter: 0x1c0822d20&gt;}
</code></pre>
<h3 id="2-NSURLConnection-finished-with-error-code-1002"><a href="#2-NSURLConnection-finished-with-error-code-1002" class="headerlink" title="2. NSURLConnection finished with error - code -1002"></a>2. <strong>NSURLConnection finished with error - code -1002</strong></h3><pre><code class="objectivec">2018-01-31 21:35:56.144596+0800 CloudOfficeTest[9301:4618465] NSURLConnection finished with error - code -1002
2018-01-31 21:36:02.742996+0800 CloudOfficeTest[9301:4618815] TIC TCP Conn Failed [14:0x1c41702c0]: 3:-9802 Err(-9802)
</code></pre>
<h3 id="3-failed-to-return-after-waiting-10-seconds-main-run-loop-mode-kCFRunLoopDefaultMode"><a href="#3-failed-to-return-after-waiting-10-seconds-main-run-loop-mode-kCFRunLoopDefaultMode" class="headerlink" title="3. failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode"></a>3. <strong>failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode</strong></h3><pre><code class="objectivec">2018-02-01 11:09:01.952689+0800 CloudOfficeTest[614:68129] void SendDelegateMessage(NSInvocation *): delegate (webView:decidePolicyForNavigationAction:request:frame:decisionListener:) failed to return after waiting 10 seconds. main run loop mode: kCFRunLoopDefaultMode
</code></pre>
<p>其中，前两个错误都有错误码，分别对应</p>
<blockquote>
<p>Code=-999，NSURLErrorCancelled</p>
<p>code -1002，NSURLErrorUnsupportedURL</p>
</blockquote>
<p>-999的错误，是因为webView在之前的请求还没有加载完成，就发起了下一个请求，此时webView会取消之前的请求，因此会回调的请求失败这里。</p>
<p>这里使用的是WKWebView，因此，需要在WKWebView加载失败的代理方法里拦截掉被取消的请求。</p>
<pre><code class="objectivec">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error
{
    // code = -999，被取消什么也不干
    if ([error code] == NSURLErrorCancelled) {
        return;
    }
    NSLog(@&quot;error:%@&quot;,error);

    // 失败后的后续处理.....
}
</code></pre>
<p>第3个错误中看到了<strong>main run loop</strong>的字样，感觉很有可能是造成卡顿的元凶了。又在项目中全局搜了一下报错的这个方法，发现是使用的js与oc交互框架—<strong>WebViewJavaScriptBridge</strong>中的方法。</p>
<pre><code class="objectivec">// WebViewJavascriptBridge.m

- (void)webView:(WebView *)webView decidePolicyForNavigationAction:(NSDictionary *)actionInformation request:(NSURLRequest *)request frame:(WebFrame *)frame decisionListener:(id&lt;WebPolicyDecisionListener&gt;)listener
</code></pre>
<p>这个方法是框架<strong><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a></strong>中的方法，主要用于处理UIWebView与JS交互。到目前为止，仍然不能定位到究竟是UIWebView与JS交互时发生了什么？才导致报这个错误。只是隐隐的感觉到可能和初始化UIWebView时的内存消耗有关，毕竟WKWebView的内存消耗相比UIWebView低了一个数量级。于是，将加载会卡顿的页面替换为<strong>WKWebView</strong>来加载H5页面，通过降低频繁初始化消耗的内存，减少页面卡死的概率。但在替换后遇到一些比较棘手的问题。</p>
<h2 id="具体替换步骤"><a href="#具体替换步骤" class="headerlink" title="具体替换步骤"></a>具体替换步骤</h2><ul>
<li>引入WKWebView的代理，生成<strong>WKWebViewJavascriptBridge</strong>桥接对象</li>
</ul>
<pre><code class="objectivec">#import &quot;WKWebViewJavascriptBridge.h&quot;
#import &quot;LZWKWebKitSupport.h&quot;

@interface LZPartnerMainViewController ()&lt;WKNavigationDelegate&gt;

@property WKWebViewJavascriptBridge *jsBridge;
/**WKWebView**/
@property (nonatomic, strong) WKWebView *wkWebView;
</code></pre>
<ul>
<li>初始化WKWebView</li>
</ul>
<pre><code class="objectivec">- (void)viewDidLoad 
{
_wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:YES];
[_wkWebView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];
[self.view addSubview:_wkWebView];

self.jsBridge = [WKWebViewJavascriptBridge bridgeForWebView:_wkWebView];
[self.jsBridge setWebViewDelegate:self];

// 使用WKWebViewJavascriptBridge进行桥接，OC端注册方法，由js端进行调用
    [_jsBridge registerHandler:@&quot;testObjcCallback&quot; handler:^(id data, WVJBResponseCallback responseCallback) {
        NSLog(@&quot;data:%@&quot;,data);
        NSString *urlStr = nil;
        NSString *processIsTop = nil;
        if ([data isKindOfClass:[NSString class]]) {
            urlStr = data;
        }else{
            NSDictionary *dic = data;
            urlStr = dic[@&quot;url&quot;];
            processIsTop = dic[@&quot;processIsTop&quot;];
        }
        responseCallback(@&quot;Response from testObjcCallback&quot;);
    }];
}
</code></pre>
<p>注意，这里通过<strong>LZWKWebKitSupport</strong>来初始化一个<strong>WkWebView</strong>是为了同步Cookie，后面会具体说到为什么要同步Cookie及如何同步。</p>
<ul>
<li>设置WkWebView的代理方法</li>
</ul>
<pre><code class="objectivec">#pragma mark - WKNavigationDelegate
// 开始加载
- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation
{
    self.loadingView.hidden = NO;
    NSLog(@&quot;didCommitNavigation&quot;);
}

// 加载完成
- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation
{
    self.loadingView.hidden = YES;
    NSLog(@&quot;didFinishNavigation&quot;);
}

// 加载失败
- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error
{
    // code = -999
    if ([error code] == NSURLErrorCancelled) {
        return;
    }
    NSLog(@&quot;didFailProvisionalNavigation error.code = %ld&quot;,error.code);
}

#pragma mark - wkwebviewDelegate
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler
{
    decisionHandler(WKNavigationActionPolicyAllow);
}

//接收到服务器响应 后决定是否允许跳转，主要用来处理请求失败的情况。
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler
{
    decisionHandler(WKNavigationResponsePolicyAllow);
    NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response;

    // 读取cookies
    NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];
    for (NSHTTPCookie *cookie in cookies) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
    }

    if (response.statusCode &amp;&amp; response.statusCode != 200) {
        LZErrorHintType type = LZErrorHintType404;
        if (![[Singleton shareInstance] hasNet]) {
            type = LZErrorHintTypeNet;
        }
        __weak typeof(self) weakSelf = self;
        if (!_errorView) {
            //弹出错误界面，点击刷新按钮刷新界面
            LZErrorHintView *errorView = [[LZErrorHintView alloc] initWithFrame:self.view.bounds type:type refreshBlock:^{
                [weakSelf loadHTMLPage];
            }];
            weakSelf.errorView = errorView;
            [self.view addSubview:errorView];
        }
        return;
    }
    if ([[Singleton shareInstance] hasNet]) {
        if (_errorView) {
            [_errorView removeFromSuperview];
            _errorView = nil;
        }
    }else{
        if(!_errorView){
            __weak typeof(self) weakSelf = self;
            LZErrorHintView *errorView = [[LZErrorHintView alloc] initWithFrame:self.view.bounds type:LZErrorHintTypeNet refreshBlock:^{
                [weakSelf viewWillAppear:YES];
            }];
            _errorView = errorView;
            errorView.tag = 2200;
            [self.view addSubview:errorView];
        }
    }
}
</code></pre>
<h2 id="替换UIWebView为WKWebView后遇到的问题及解决方法"><a href="#替换UIWebView为WKWebView后遇到的问题及解决方法" class="headerlink" title="替换UIWebView为WKWebView后遇到的问题及解决方法"></a>替换UIWebView为WKWebView后遇到的问题及解决方法</h2><h3 id="1-使用WKWebViewJavascriptBridge进行桥接时，加载H5页面闪退。"><a href="#1-使用WKWebViewJavascriptBridge进行桥接时，加载H5页面闪退。" class="headerlink" title="1. 使用WKWebViewJavascriptBridge进行桥接时，加载H5页面闪退。"></a>1. 使用<strong>WKWebViewJavascriptBridge</strong>进行桥接时，加载H5页面闪退。</h3><p>这里需要更新<strong>WebViewJavaScriptBridge</strong>桥接框架中WKWebView的桥接方法，</p>
<pre><code class="objectivec">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    if (webView != _webView) { return; }
    NSURL *url = navigationAction.request.URL;
    __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate;

    if ([_base isWebViewJavascriptBridgeURL:url]) {
        if ([_base isBridgeLoadedURL:url]) {
            [_base injectJavascriptFile];
        } else if ([_base isQueueMessageURL:url]) {
            [self WKFlushMessageQueue];
        } else {
            [_base logUnkownMessage:url];
        }
        decisionHandler(WKNavigationActionPolicyCancel);
        return; 
        // 对比之前的方法，这个地方多了一个return
    }

    if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:decidePolicyForNavigationAction:decisionHandler:)]) {
        [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];
    } else {
        decisionHandler(WKNavigationActionPolicyAllow);
    }
}
</code></pre>
<h3 id="2-WKWebView加载完网页后，点击里面的按钮，不跳转的问题。"><a href="#2-WKWebView加载完网页后，点击里面的按钮，不跳转的问题。" class="headerlink" title="2. WKWebView加载完网页后，点击里面的按钮，不跳转的问题。"></a>2. WKWebView加载完网页后，点击里面的按钮，不跳转的问题。</h3><p>设置WKWebView的另一个代理WKUIDelegate，从名称能看出它是webView在user interface上的代理，</p>
<pre><code class="objectivec">// 创建新的webView
// 可以指定配置对象、导航动作对象、window特性。如果没用实现这个方法，不会加载链接，如果返回的是原webview会崩溃。
-(WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures
{
if (!navigationAction.targetFrame.isMainFrame) {
    [webView loadRequest:navigationAction.request];
}
    return nil;
}
</code></pre>
<p>要调用下面的方法是有条件的，WKNavigationDelegate中的该方法是用户点击网页上的链接，需打开新页面时，将先调，是否允许跳转到链接。</p>
<pre><code class="objectivec">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler｛
 WKFrameInfo *sFrame = navigationAction.sourceFrame;//navigationAction的出处
 WKFrameInfo *tFrame = navigationAction.targetFrame;//navigationAction的目标
//只有当  tFrame.mainFrame == NO；时，表明这个 WKNavigationAction 将会新开一个页面。
// 才会调用createWebViewWithConfiguration这个代理方法。
｝
</code></pre>
<p>这样就新开一个webView，如果我们只是显示网页，这样会消耗性能，没有必要。</p>
<h3 id="3-如何同步WKWebView的Cookie"><a href="#3-如何同步WKWebView的Cookie" class="headerlink" title="3. 如何同步WKWebView的Cookie"></a>3. <font color="#FF0000">如何同步WKWebView的Cookie</font></h3><p>在将UIWebView替换为WKWebView后加载速度提高了，页面卡死的问题基本没有再出现过。但遇到了一个更加棘手的问题，之前使用的是UIWebView，它会对首次加载H5页面后的用户登录信息进行同步，这样我由当前的H5页面跳转到一个新的UIWebView进行请求时，会自动找到上个页面同步的用户信息，从而加载当前用户对应的内容。</p>
<blockquote>
<p><strong>WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。</strong></p>
</blockquote>
<p>因此，如何实现多个 <strong>WKWebView</strong> 之间共享 <strong>Cookie</strong>（session Cookie and persistent Cookie）数据。是决定能否继续使用<strong>WKWebView</strong>的关键。如果不能解决这个问题，就只能再继续使用之前的 <strong>UIWebView</strong> 了，之前所做的一切都没有用处了。</p>
<p>解决多个 <strong>WKWebView</strong> 之间共享 <strong>Cookie</strong> 的问题，首先要弄明白三个问题？</p>
<ol>
<li><strong>WKWebView</strong> 与 <strong>webView</strong> 在 <strong>Cookie</strong> 设置，读取上有什么不同？</li>
<li><strong>WKWebView</strong> 会将对应的 <strong>Cookie</strong> 存在什么地方？</li>
<li>如何取到 <strong>WKWebView</strong> 的 <strong>Cookie</strong> 并将其注入到要访问的下一个 <strong>WKWebView</strong> 中？</li>
</ol>
<p>结合以上三个问题，在网上搜索很多关于 <strong>WKWebView</strong> 的 <strong>Cookie</strong> 存储在什么地方？ 这些资料普遍认为 <strong>WKWebView</strong> 拥有自己的私有存储，不会将 <strong>Cookie</strong> 存入到标准的 <strong>Cookie</strong> 容器 <strong>NSHTTPCookieStorage</strong> 中。但在实际项目中，却发现 <strong>WKWebView</strong> 实例可以读取到存储于 <strong>NSHTTPCookieStorage</strong> 中的 <strong>Cookie</strong>。最后，看到了<a href="https://bugly.qq.com/v2/" target="_blank" rel="external">腾讯Bugly</a>的一篇技术文章 —- <a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>，也印证了我的观点。</p>
<blockquote>
<p>实践发现 WKWebView 实例其实也会将 Cookie 存储于 NSHTTPCookieStorage 中，但存储时机有延迟，在iOS 8上，当页面跳转的时候，当前页面的 Cookie 会写入 NSHTTPCookieStorage 中，而在 iOS 10 上，JS 执行 document.cookie 或服务器 set-cookie 注入的 Cookie 会很快同步到 NSHTTPCookieStorage 中。</p>
</blockquote>
<p>看来以后搜索技术文章，不能太片面了，一定要结合一些大厂的权威技术文章来具体分析。</p>
<p>下一步，就是如何在发起请求时注入 通过 <strong>NSHTTPCookieStorage</strong> 获取的<strong>Cookie</strong>。网上关于 <strong>WKWebView</strong> 的 <strong>Cookie</strong> 注入方法有以下几种:</p>
<ol>
<li><strong>JS</strong>注入 —- 在初始化 <strong>WKWebView</strong> 的时候，通过 <strong>WKUserScript</strong> 设置，使用<strong>javascript</strong> 注入 <strong>Cookie</strong>，一开始发送 <strong>NSMutableURLRequest</strong> 请求的时候也要加上 <strong>Cookie</strong>，并且保证两个地方的设置的cookie一致。参考 — <a href="https://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview" target="_blank" rel="external">Can I set the cookies to be used by a WKWebView?</a></li>
<li><strong>WKHTTPCookieStore</strong> —- 利用 <strong>iOS11 API WKHTTPCookieStore</strong> 解决 <strong>WKWebView</strong> 首次请求不携带 <strong>Cookie</strong> 的问题。参考 — <a href="https://helpcdn.aliyun.com/knowledge_detail/60199.html" target="_blank" rel="external">iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明</a></li>
<li>利用 <strong>iOS11</strong> 之前的 API 解决 <strong>WKWebView</strong> 首次请求不携带 <strong>Cookie</strong> 的问题。参考 — <a href="https://helpcdn.aliyun.com/knowledge_detail/60199.html" target="_blank" rel="external">iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明</a></li>
<li>通过让所有 <strong>WKWebView</strong> 共享同一个 <strong>WKProcessPool</strong> 实例，可以实现多个 <strong>WKWebView</strong> 之间共享 <strong>Cookie（session Cookie and persistent Cookie）</strong> 数据。不过 <strong>WKWebView WKProcessPool</strong> 实例在 app 杀进程重启后会被重置，导致 <strong>WKProcessPool</strong> 中的 <strong>Cookie</strong>、<strong>session Cookie</strong> 数据丢失，目前也无法实现 <strong>WKProcessPool</strong> 实例本地化保存。</li>
</ol>
<p>方法1，经过测试行不通，可能是后台读取 <strong>Cookie</strong> 的方式有问题；方法2，是 <strong>iOS 11</strong> 的 <strong>API</strong> ，不具有普适性；方法3，在测试时无法通过 <strong>url</strong> 匹配到 <strong>Cookie</strong>；最后，只剩下方法4了，需要注意在特殊场景下 <strong>Cookie</strong> 丢失的情况：</p>
<blockquote>
<p>app 杀进程重启后会被重置，导致 <strong>WKProcessPool</strong> 中的 <strong>Cookie</strong>、<strong>session Cookie</strong> 数据丢失，目前也无法实现 <strong>WKProcessPool</strong> 实例本地化保存。</p>
</blockquote>
<p>但以我们的应用为例，哪怕是主动杀进程，重新打开应用；还是应用突然闪退，重新打开应用。首次加载某个含有用户登录验证的H5页面时，需要在发起请求的地方拼上用户特定信息的参数，因此，即使之前存储的 <strong>Cookie</strong> 数据丢失了，也会在首次加载时重新获取。如下：</p>
<pre><code class="objectivec">Singleton *sin = [Singleton shareInstance];
NSString *baseIpPort = [LZUserDefaults objectForKey:PreferenceKey_SystemInit_ZyPartnerIPPort];
NSString *urlString = [[NSString stringWithFormat:@&quot;%@/test1/test2?Id=%@&amp;Name=%@&amp;Pid=%@&quot;,baseIpPort,sin.clinicId,[LZUserDefaults objectForKey:PreferenceKey_Name],[LZUserDefaults objectForKey:PreferenceKey_Pid]] stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];
request.HTTPMethod = @&quot;POST&quot;;
request.timeoutInterval = 15.0f;
[_wkWebView loadRequest:request];
</code></pre>
<p>因此，对于 <strong>APP</strong> 重启后 <strong>Cookie</strong> 数据可能丢失的情况，难道不可以在首次加载H5页面时，重新获取一下用户登录信息的 <strong>Cookie</strong> 吗？对我而言，现在的项目就是这样做的。</p>
<h2 id="通过-WKProcessPool-实现多个-WKWebView-之间共享-Cookie"><a href="#通过-WKProcessPool-实现多个-WKWebView-之间共享-Cookie" class="headerlink" title="通过 WKProcessPool 实现多个 WKWebView 之间共享 Cookie"></a>通过 WKProcessPool 实现多个 WKWebView 之间共享 Cookie</h2><h3 id="1-新建一个名为-LZWKWebKitSupport-的类，用于生成一个统一的，全局使用同一个-WKProcessPool-的-WKWebView-对象。"><a href="#1-新建一个名为-LZWKWebKitSupport-的类，用于生成一个统一的，全局使用同一个-WKProcessPool-的-WKWebView-对象。" class="headerlink" title="1. 新建一个名为 LZWKWebKitSupport 的类，用于生成一个统一的，全局使用同一个 WKProcessPool 的 WKWebView 对象。"></a>1. 新建一个名为 <strong>LZWKWebKitSupport</strong> 的类，用于生成一个统一的，全局使用同一个 <strong>WKProcessPool</strong> 的 <strong>WKWebView</strong> 对象。</h3><pre><code class="objectivec">// LZWKWebKitSupport.h

#import &lt;Foundation/Foundation.h&gt;
#import &lt;WebKit/WebKit.h&gt;

@interface LZWKWebKitSupport : NSObject
@property (nonatomic, strong,readonly) WKProcessPool *processPool;
+ (instancetype)sharedSupport;
+ (WKWebView *)createSharableWKWebView:(BOOL)isFullScreen isShowNav:(BOOL)showNav;
@end
</code></pre>
<pre><code class="objectivec">// LZWKWebKitSupport.m
#import &quot;LZWKWebKitSupport.h&quot;
@interface LZWKWebKitSupport()
@end

@implementation LZWKWebKitSupport
+ (instancetype)sharedSupport {
    static LZWKWebKitSupport *_instance;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [LZWKWebKitSupport new];
    });
    return  _instance;
}

- (instancetype)init {
    if (self = [super init]) {
        self.processPool = [WKProcessPool new];
    }
    return self;
}

+ (WKWebView *)createSharableWKWebView:(BOOL)isFullScreen isShowNav:(BOOL)showNav
{
    WKUserContentController* userContentController = [WKUserContentController new];
    NSMutableString *cookies = [NSMutableString string];
    WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:[cookies copy]                                                        injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
    [userContentController addUserScript:cookieScript];    
    WKWebViewConfiguration *configuration = [WKWebViewConfiguration new];
    // 一下两个属性是允许H5视频自动播放,并且全屏,可忽略
    configuration.allowsInlineMediaPlayback = YES;
    configuration.mediaPlaybackRequiresUserAction = NO;
    // 全局使用同一个processPool
    configuration.processPool = [[LZWKWebKitSupport sharedSupport] processPool];
    configuration.userContentController = userContentController;
    // 考虑到左侧菜单栏，需要设置webView的不同frame
    WKWebView *wk_webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, y, width, height) configuration:configuration];

    return wk_webView;
}
@end
</code></pre>
<h3 id="2-在加载H5的地方初始化-LZWKWebKitSupport，并在-WKNavigationDelegate-中获取-cookie，并设置到本地。"><a href="#2-在加载H5的地方初始化-LZWKWebKitSupport，并在-WKNavigationDelegate-中获取-cookie，并设置到本地。" class="headerlink" title="2. 在加载H5的地方初始化 LZWKWebKitSupport，并在 WKNavigationDelegate 中获取 cookie，并设置到本地。"></a>2. 在加载H5的地方初始化 <strong>LZWKWebKitSupport</strong>，并在 <strong>WKNavigationDelegate</strong> 中获取 <strong>cookie</strong>，并设置到本地。</h3><pre><code class="objectivec">// 初始化LZWKWebKitSupport
- (void)viewDidLoad{
_wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:YES];
[self.view addSubview:_wkWebView];
}
</code></pre>
<pre><code class="objectivec">#pragma mark - wkwebviewDelegate
//接收到服务器响应 后决定是否允许跳转
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler
{
    decisionHandler(WKNavigationResponsePolicyAllow);
    NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response;
    // 读取cookie，并设置到本地
    NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL];
    for (NSHTTPCookie *cookie in cookies) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
    }
}
</code></pre>
<h3 id="3-在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。"><a href="#3-在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。" class="headerlink" title="3. 在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。"></a>3. 在从第一个H5页面跳转至第二个H5页面时，在发起请求时注入Cookie。</h3><p>这里以跳转到 <strong>LZDetailViewController</strong> 页面为例，先是通过<strong>LZWKWebKitSupport</strong> 初始化一个 <strong>WKWebView</strong></p>
<pre><code class="objectivec">// LZDetailViewController.m
- (void)viewDidLoad {
    [super viewDidLoad];
    //初始化视图
    [self setUpSubViews];   
}

- (void)setUpSubViews{
    _wkWebView = [LZWKWebKitSupport createSharableWKWebView:YES isShowNav:NO];
    _wkWebView.UIDelegate = self;
    [self.view addSubview:_wkWebView];
    _jsBridge = [WKWebViewJavascriptBridge bridgeForWebView:_wkWebView];
    [_jsBridge setWebViewDelegate:self];
}
</code></pre>
<p>然后在加载请求时，注入之前设置的 <strong>Cookie</strong></p>
<pre><code class="objectivec">- (void)loadUrl{
    if (!_urlStr) {
        return;
    }

    NSURL *url = [NSURL URLWithString:_urlStr];
    NSMutableString *cookies = [NSMutableString string];
    NSMutableURLRequest *requestObj = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15.0];
    // 一般都只需要同步BJSESSIONID,可视不同需求自己做更改
    NSString * BJSESSIONID;
    // 获取本地所有的Cookie
    NSArray *tmp = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];
    for (NSHTTPCookie * cookie in tmp) {
        if ([cookie.name isEqualToString:@&quot;BJSESSIONID&quot;]) {
            BJSESSIONID = cookie.value;
            break;
        }
    }
    if (BJSESSIONID.length) {
        // 格式化Cookie
        [cookies appendFormat:@&quot;BJSESSIONID=%@;&quot;,BJSESSIONID];
    }
    // 注入Cookie
    [requestObj setValue:cookies forHTTPHeaderField:@&quot;Cookie&quot;];
    // 加载请求
    [self.wkWebView loadRequest:requestObj];
}
</code></pre>
<p>通过以上三步就可以达到同步 <strong>Cookie</strong> 的目的，现在看来之前通过 <strong>JS脚本</strong> 注入 <strong>Cookie</strong> 失败，可能是由于后台需要同步 <strong>BJSESSIONID</strong>，而<strong>BJSESSIONID</strong> 是 <strong>HtppOnly</strong>，不允许通过js脚本修改。</p>
<p>最后，需要特别注意的一点是：<font color="#FF0000">考虑在加载H5页前，是否需要清除某些H5页面的 <strong>Cookie</strong> ? </font></p>
<p>这里对于我们的项目而言，加载的需要验证用户身份信息的H5页面，是需要清除 <strong>Cookie</strong> 的，因为用户的权限不同，所看到的界面就不同，在同一台设备下切换不同的用户时，如果不清除之前的 <strong>Cookie</strong>，所展示的就是上一个用户的信息。</p>
<pre><code class="objectivec">- (void)deleteWKCookies
{
    // 清除WKWebView缓存的cookie(根据ip)
    if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 9.0){

        NSString *iPPort = [LZUserDefaults objectForKey:PreferenceKey_SystemInit_ZyIPPort];
        NSArray *iPPortArray = [iPPort componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@&quot;/&quot;]];
        NSString *recordIP;
        if ([iPPortArray count] &gt; 2) {
            recordIP = partnerIPPortArray[2];
        }

        WKWebsiteDataStore *dateStore = [WKWebsiteDataStore defaultDataStore];
        [dateStore fetchDataRecordsOfTypes:[WKWebsiteDataStore allWebsiteDataTypes] completionHandler:^(NSArray&lt;WKWebsiteDataRecord *&gt; * __nonnull records) {
            for (WKWebsiteDataRecord *record  in records)
            {
                // 以www.baidu.com为例，是否包含baidu.com
                if ([recordIP containsString:record.displayName])
                {
                    [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:record.dataTypes forDataRecords:@[record] completionHandler:^{
                        NSLog(@&quot;Cookies for %@ deleted successfully&quot;,record.displayName);
                    }];
                }
            }
        }];
    }
}
</code></pre>
<h2 id="WebView性能优化总结"><a href="#WebView性能优化总结" class="headerlink" title="WebView性能优化总结"></a>WebView性能优化总结</h2><p>一个加载网页的过程中，native、网络、后端处理、CPU都会参与，各自都有必要的工作和依赖关系；让他们相互并行处理而不是相互阻塞才可以让网页加载更快：</p>
<ul>
<li>WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。</li>
<li>后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。</li>
<li>脚本执行慢，就让脚本在最后运行，不阻塞页面解析。</li>
<li>同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。</li>
<li>WebView初始化慢，就随时初始化好一个WebView待用。</li>
<li>DNS和链接慢，想办法复用客户端使用的域名和链接。</li>
<li>脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。</li>
</ul>
<p>上面是美团点评技术团队关于<a href="https://tech.meituan.com/WebViewPerf.html" target="_blank" rel="external">WebView性能优化</a>的总结。</p>
<p>对比我们项目中有哪些页面用到了 <strong>UIWebView</strong>，哪些用到了 <strong>WKWebView</strong>，发现当前程序中一共有8个主要模块，其中，一共有4个主要模块是通过加载H5页面展示的，还有一个模块中部分嵌套了H5页面。这些页面中，有三个页面使用 <strong>WkWebView</strong> 加载，剩下的使用的是 <strong>UIWebView</strong> 加载页面，发生卡顿的页面多是频繁初始化 <strong>UIWebView</strong> 加载H5时发生的。</p>
<p>这里我们的项目中使用<strong>UIWebView</strong> 和 <strong>WKWebView</strong> 的地方有很多，没有一个管理类去居中调控的话，后期维护起来会很耗时，而且很容易出现bug。下一步的优化就是要构建这样一种集构建，配置，分发，操控为一身的通用类。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tech.meituan.com/WebViewPerf.html" target="_blank" rel="external">WebView性能、体验分析与优化</a></p>
<p><a href="https://developer.apple.com/documentation/webkit/wknavigationdelegate/1455641-webview?language=objc" target="_blank" rel="external">webView:decidePolicyForNavigationAction:decisionHandler:</a></p>
<p><a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a></p>
<p><a href="https://helpcdn.aliyun.com/knowledge_detail/60199.html" target="_blank" rel="external">iOS WebView 中的 Cookie 处理业务场景“IP直连”方案说明</a></p>
<p><a href="https://developer.apple.com/documentation/webkit/wknavigationdelegate/1455641-webview?language=objc" target="_blank" rel="external">Developer wknavigationdelegate documentation</a></p>
<p><a href="https://forums.developer.apple.com/thread/50057" target="_blank" rel="external">WKWebView and UIWebView Cookie</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一周，用户频繁反应一个问题：切换到某个功能页面后，加载H5页面相应时间过长，当H5页面未展示出来时，此时，再切换到其他页面，App会卡死。我们试着在公司的网络环境下复现这个问题，但并未复现。&lt;/p&gt;
&lt;h2 id=&quot;错误的尝试&quot;&gt;&lt;a href=&quot;#错误的尝试&quot; cla
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="wkWebView" scheme="http://XibHe.github.io/tags/wkWebView/"/>
    
      <category term="webView性能调优" scheme="http://XibHe.github.io/tags/webView%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>2017年度总结</title>
    <link href="http://XibHe.github.io/2017/12/30/2017deadline/"/>
    <id>http://XibHe.github.io/2017/12/30/2017deadline/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-01-14T12:42:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间2017就要结束了，回首过去的一年，有过彷徨，有过不安，也有收获的感动与喜悦。过完17年我就拥有四年开发经验了，一直觉得四到五年的阶段是区别高级开发与初中级开发的分水岭。但这并不使我感到高兴，我深知这四年时光中一多半是在蹉跎中度过的。往之不谏，来者可追！2018！我来了。</p>
<h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p>对我这个年龄来说，结婚的很少，更别提孩子了。但我已经为人夫，为人父了！似乎用两三年的时间走完了别人十几年的路。太过年轻的我，总会时不时忘记自己身为父亲的责任，我媳妇(花花)总会不厌其烦的唤起我作为父亲该承担的责任。家里的大事小情，在花花的安排下井井有条。孩子的奶粉，尿不湿也不用我来操心，为了分担我的压力，花花早早给儿子断了母乳，离家挣钱。对花花我即心疼又愧疚，我不能一直用年轻作为借口，逃避身为男人的责任。<strong>家庭永远是第一位</strong>！</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/2017deadline_%201.jpg" alt=""></p>
<blockquote>
<p>每个人都有属于自己的人生遥控器，它无时无刻不掌握在你自己的手中，你可以随时按快进键让时间从你的手中逃走，你也可以按回退键，想想自己曾经的错过与失误，你也可以按跳过键，它的另外一个名字叫做逃避…… 从前有个精灵一直在寻找彩虹那端的金罐，但最后，他发现那只是一罐麦片。</p>
</blockquote>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>年初给自己定下了一个目标：每周至少写一篇博客。到目前为止，算上这篇，一共是25篇。这25篇文章中，有5篇是译文，5篇是个人感悟，剩下15篇是技术上的分享。技术上的分享有些很肤浅，和大咖们由浅入深的技术文章比起来有些相形见绌。但我还是会坚持写下去的，须知泰山非一日之功。</p>
<p>写一篇鞭辟入里的爽文真的很费时间，前期需要阅读大量的相关文章，技术文档。最难得还是将所要描述的知识点与实际的代码，产品需求结合起来。因此，当你在自己的项目中解决了一个棘手的bug，或者实现了一个复杂的产品需求时，你再将这些解决问题的方案写成博客，就会有一种“下笔如有神”的感觉。就好比最近写了一篇名为<a href="http://xibhe.com/2017/11/06/JenKins-Continuous-Integration/" target="_blank" rel="external">利用JenKins持续集成iOS项目时遇到的问题</a>博文，通篇写下爱特别顺畅。因为这些流程都是我切身经历过得，在这里也只是再复述一篇操作流程而已。</p>
<p>相比之下这篇文章 — <a href="http://xibhe.com/2017/11/26/AF3.x/" target="_blank" rel="external">AFNetworking到底做了什么？</a> 写起来就不那么顺利，自己没有切实经历过，整个<strong>AFNetworking</strong>的源码，马马虎虎的读了两遍，不能透彻理解其中的精髓。也只能转载别人的观点。</p>
<p>自从给自己定下了一周至少写一篇博客的目标后，每到周末就特纠结，搜肠刮肚的想着如何结合实际开发构思出一篇好博文。有时实在没有好的点子，就翻译<strong>Medium</strong>和<strong>湾区日报</strong>上推荐的英文文章，或者写一些个人心得体会。</p>
<p>今年写的一些技术性文章也有不尽如人意的地方，有些文章，写的很粗浅，没有刨根问底追溯到本质上。有些文章是迫于一周要写一篇博文而拼凑成的，今年不会如此只求量而不求质了。但以文字的形式记录分享开发心得的习惯，一旦养成，就不会轻易舍弃，这算是2017年一个明显的收获吧！</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年看完了<font size="4" face="黑体">《图解HTTP》</font>、<font size="4" face="黑体">《黑客与画家》</font>、<font size="4" face="黑体">《软技能:代码之外的生存指南》</font>。正在看的有<font size="4" face="黑体">《人类简史》</font>、<font size="4" face="黑体">《啊哈!算法》</font>。看<font size="4" face="黑体">《啊哈!算法》</font>时，看的快忘得也快，还是没有结合实践，将书上的算法，用代码实现一遍。</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/hacker-artist.jpg" alt="黑客与画家"></p>
<p>在这些书中，<font size="4" face="黑体">《黑客与画家》</font>这本书书对我启发最大，里面很多论述让我有种醍醐灌顶的感觉。现在回想起来，书中很多内容已经忘得差不多了，唯一记得的是：编程和绘画一样，是需要走心的，需要绞尽脑汁去构思的。</p>
<p>偶然在知乎上看到<strong><a href="https://www.zhihu.com/question/32039257" target="_blank" rel="external">你是怎么看完《JavaScript权威指南》《JavaScript高级程序设计》等这类厚书的？</a></strong>的提问，摘录其中一个赞同数最高的回答：</p>
<blockquote>
<p>与其说看书不如说看目录，从目录里找到感兴趣的章节，看掉，看到中途没兴趣了，就放下下次再看。工作中碰到什么问题不明白需要参考了，还是看目录，才大概会在什么章节里，探索一番，中间如果碰到感兴趣的，看掉，看到中间没兴趣了，放下，下次再看。要不了多久，整本书的70%-80%都翻遍了，其中有20%-30%翻了不止一遍，这些往往是核心的知识；至于剩下的20%没看过的，以后或许有机会的，没机会也不要紧，很多时候自己已经通过各种机缘学到了。</p>
<p>所以看技术厚书不在于多块或多慢，而是从容。</p>
</blockquote>
<p>其中，我认为结合书中知识点，<strong>理论联系实践</strong>是最为有效的掌握知识点的方法。读一些非技术的书籍，最重要的是能够让自己心安。</p>
<blockquote>
<p>此心安处是吾乡</p>
</blockquote>
<p>关于买书，今年没有买一本书。因为去年买的书，大概有七八本吧！只看完了三本，还有向公司申请采购的3本技术书籍，手中库存的书足够我看了。2018年在此立一个flag：<strong>看完6本书！</strong></p>
<h2 id="新部门"><a href="#新部门" class="headerlink" title="新部门"></a>新部门</h2><p>今年12月份时被调到一个新部门，开始接触到公司最为核心的项目。想想就有些小激动啊！因此，也会给自己提出更高的要求，写功能模块时要注意与其他功能的耦合性，兼顾需要考虑程序的性能，容错机制的相应。现有的开发模式，耦合性太高，如何实现高可用的组件化，降低功能模块间的耦合性？将是我们这个团队在18年需要重点考录的问题。希望能为这次项目模块的优化重构尽自己的一份力量。</p>
<h2 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h2><p>9月初接触微信小程序，和部门另外两个H5一起开发公司的一款小程序。中间吃了小程序产品原型还是是基于原生App思维而设计的亏，同时，也由于自己没有完全吃透小程序开发文档，在实现一些功能时踩了<a href="http://xibhe.com/2017/09/25/wx-mini-AppSummary/" target="_blank" rel="external">坑</a>。</p>
<p>这次小程序开发经历使我意识到自己的技术短板，陷入对技术的狂热之中。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。</p>
<blockquote>
<p>请勿陷入对技术的狂热之中</p>
</blockquote>
<p>若是早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不再积极进取，不再学习新技术。这种开发者被称为“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/introspect2.jpg" alt=""></p>
<p>2018年，新的一年，要在原有技术的基础之上找到突破口，将自己以前囫囵吞枣的知识点再好好品味一番。同时，也不能仅仅局限于iOS一方面的技术。</p>
<p>今年最直观的感觉是自己对于新技术的渴望，缺少那种如饥食渴的痴迷感。苹果开发者大会上的ARKit，CoreML，SiriKit这些新技术，对于我这个iOS开发者竟然毫无吸引力可言。这是我身上存在的一个大的缺陷，也是程序员堕落，不思进取的开始。<strong>对于程序员来说，最大的悲哀并不是35岁后被华为辞退，也不是42岁后跳楼。</strong> 而是：</p>
<blockquote>
<p>不再向往新技术。</p>
</blockquote>
<p><img src="http://odchyrav4.bkt.clouddn.com/2017deadline_3.jpg" alt=""></p>
<blockquote>
<p>stay hungry，stay foolish.</p>
</blockquote>
<h2 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h2><p>家人朋友身体健康，自己技术日臻成熟。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间2017就要结束了，回首过去的一年，有过彷徨，有过不安，也有收获的感动与喜悦。过完17年我就拥有四年开发经验了，一直觉得四到五年的阶段是区别高级开发与初中级开发的分水岭。但这并不使我感到高兴，我深知这四年时光中一多半是在蹉跎中度过的。往之不谏，来者可追！2018！我来
    
    </summary>
    
      <category term="随笔" scheme="http://XibHe.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="2017" scheme="http://XibHe.github.io/tags/2017/"/>
    
      <category term="年度总结" scheme="http://XibHe.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>(译)创业就是要发起一场思想运动</title>
    <link href="http://XibHe.github.io/2017/12/09/Build%20a%20Movement/"/>
    <id>http://XibHe.github.io/2017/12/09/Build a Movement/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2017-12-11T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个创业者，我并不喜欢和开发者在午餐时间发生争论。</p>
<p>”这是胡说，“我们的首席技术官回复。“MailChimp的产品并不比其他产品好，这只是另一个发送消息的通讯工具而已。当它竞争对手提供同样的功能只需要花费几块钱时，为什么每月要额外花费200美元呢？“</p>
<p>我想说服他，MailChimp确保我们的电子邮件广告系列投递到顾客的收件箱，而不是他们的垃圾邮件文件夹。</p>
<p>但是他一直用我没有完全明白的技术解释来反驳我。</p>
<p><img src="http://growthsupply.com/wp-content/uploads/2017/10/mailchimp-hp-1.png" alt=""></p>
<p>“看，我们甚至可以建立我们自己的电子邮件机器人，做同样的事情，”他补充说。“你只是因为他们的品牌知名才使用它。”</p>
<p>是的，在一定程度上他说的很对。</p>
<p>在过去的几年中，MailChimp已经建立了一个标志性的品牌以其设计为中心的方法和非传统的营销活动。</p>
<p>猴子吉祥物<a href="https://blog.mailchimp.com/the-story-behind-the-mailchimp-billboards/" target="_blank" rel="external">广告牌</a>没有提到他们的名字…“MailKimp”和参与其他趣味取名活动达到了<a href="https://twitter.com/benchestnut/status/871678778782756864" target="_blank" rel="external">3.34亿人</a>…以设计为中心的<a href="https://mailchimp.com/2016/" target="_blank" rel="external">年度报告</a>与风格…</p>
<p>MailChimp的赠品也是非常规的。为猫咪准备的免费<a href="https://blog.drift.com/how-mailchimp-grew/" target="_blank" rel="external">猴子帽子</a>打动了像我一样准备付更多钱的超级粉丝。</p>
<p><img src="http://growthsupply.com/wp-content/uploads/2017/10/banner-compressor-1.jpg" alt=""></p>
<p>在一个任何人都可以一夜之间复制你的产品的世界里，MailChimp选择为猫咪编织猴子帽子，而不是进行军备竞赛建立更多的功能。</p>
<p>毕竟，公司甚至还接到一些大客户的<a href="https://medium.com/swlh/an-open-letter-to-mailchimp-8497318fc860" target="_blank" rel="external">公开信</a>和<a href="https://tinyletter.com/ben/letters/whale-hunting-or-scale-hunting" target="_blank" rel="external">警告</a>，如果没有更高级的功能，就有可能转向竞争对手。</p>
<p>MailChimp的回答？</p>
<blockquote>
<p>重点打造品牌客户的爱心。</p>
</blockquote>
<p>当我们接近2017年年底时，从未在<a href="https://www.nytimes.com/2016/10/06/technology/mailchimp-and-the-un-silicon-valley-way-to-make-it-as-a-start-up.html" target="_blank" rel="external">外部资金</a>上花费一分钱的电子邮件创业公司正在准备结束令人兴奋的增长达1500万客户的一年。</p>
<p>但是猴子生意足够了。</p>
<p>让我们着眼大局，了解这对初创企业如何在当今混乱的世界取得成功意味着什么：</p>
<ol>
<li><p><strong>你不必扰乱整个行业:</strong>尽管许多企业家正忙于构建下一个Uber或Facebook，但这是一个我们需要消除的神话。MailChimp并没有打乱任何一个行业，但它却在一个日益拥挤的市场上建立起了猴王国。</p>
</li>
<li><p><strong>如果你不打扰或创造一个全新的市场，</strong>你仍然可以在竞争激烈的行业里建立一个帝国:而且它涉及越来越多的超级粉丝，他们虔诚地跟随你的运动，即使你收取溢价，或者拒绝参加建立更多特征的军备竞赛，仍然会推荐你的品牌。</p>
</li>
</ol>
<p>但是，秘密是什么？</p>
<p>你如何接触民众，发展你的粉丝俱乐部，让你按自己的规则玩游戏，而不用担心竞争？</p>
<p><strong>选择各不相同，但一些世界上最成功的创业公司使用两个强大的战略:</strong></p>
<p>首先显然是“MailChimp方式”，即，将您的产品推销为高品质的品牌。正如他的创始人<a href="https://tinyletter.com/ben/letters/whale-hunting-or-scale-hunting" target="_blank" rel="external">Ben Chestnut</a>解释的那样:</p>
<blockquote>
<p>我们为商业客户制作应用程序，使用低价位的零件，然后以高质量，以设计为中心，可爱的B2C品牌推广应用程序。</p>
</blockquote>
<p>但是越来越多的蓬勃发展的创业公司使用另一种策略 - 不一定需要以设计为中心的方法。</p>
<p>它需要反过来影响人的思维：</p>
<p><strong>不要扰乱一个行业，扰乱思想</strong></p>
<p>正如马克·博切克（Mark Bonchek）在他广受欢迎的<a href="https://hbr.org/2014/07/dont-sell-a-product-sell-a-whole-new-way-of-thinking" target="_blank" rel="external">哈佛杂文</a>中所强调的那样：</p>
<blockquote>
<p>成功销售和销售创新的公司能够改变人们，不仅关注他们的产品，而且关心他们自己，市场和世界的想法。</p>
<p>不要销售产品，销售一种全新的思维方式。</p>
</blockquote>
<p>拿<a href="https://www.drift.com/" target="_blank" rel="external">Drift</a>来说，今天科技界的新星之一。</p>
<p><img src="http://growthsupply.com/wp-content/uploads/2017/10/drift-homepage-1.png" alt=""></p>
<p>并不是强迫人们理解他们的产品，像Drift这样的“推动者”<strong>推销思想的根本转变，即，引起他们创新的原始洞察力。</strong></p>
<p>对Drift而言，最初的洞察力导致了营销和销售方式的破旧，仍然依赖网站形式和烦人的销售后续行动。</p>
<p>这就是为什么，他们没有硬去销售或用产品信息淹没<a href="https://blog.drift.com/" target="_blank" rel="external">他们的博客</a>，而是谈论<a href="https://blog.drift.com/introducing-ilya-mirman/" target="_blank" rel="external">今天的营销和销售技巧</a>是怎样的，或者为什么<a href="https://blog.drift.com/why-g-joined-drift/" target="_blank" rel="external">营销自动化</a>和<a href="https://blog.drift.com/why-email-is-broken/" target="_blank" rel="external">电子邮件营销</a>被打破。</p>
<blockquote>
<p>这与你的价值主张不同。这是一个关于世界如何运作的假设（通常是无意识的），“Bonchek补充道。</p>
</blockquote>
<p>当你将其视为模板时，该逻辑很容易应用于任何创业项目：</p>
<blockquote>
<p>我们支持[插入]，并将人们思考[插入]的方式转变为[插入]。</p>
</blockquote>
<p>例如，Drift支持新的营销和销售方式，将人们对营销和销售的看法转变为更多的谈话驱动，个性化和人性化。</p>
<p>另外两家标志性公司–Basecamp和Salesforce也在重新思考现有的心智模式方面处于领先地位。</p>
<ul>
<li><p>Basecamp的创始人通过倡导“非硅谷之路”，改变人们对<a href="https://m.signalvnoise.com/on-being-a-bad-manager-e56e1fb3d9dc" target="_blank" rel="external">管理</a>，<a href="https://m.signalvnoise.com/wait-you-dont-control-your-calendar-3a40f8f642fe" target="_blank" rel="external">生产力</a>，<a href="https://m.signalvnoise.com/whats-an-hour-d5966ee5ad7d" target="_blank" rel="external">时间</a>，<a href="https://m.signalvnoise.com/exponential-growth-devours-and-corrupts-c5562fbf131" target="_blank" rel="external">增长</a>或<a href="https://m.signalvnoise.com/reconsider-41adf356857f" target="_blank" rel="external">创业公司运作方式</a>的看法，来壮大自己的超级粉丝。</p>
</li>
<li><p>Salesforce捍卫“无软件”的口号，将思想从打包的安装软件转移到云计算和软件即服务。</p>
</li>
</ul>
<p><strong>建立一个改变人们思维的引擎</strong></p>
<p>改变人们目前的思维模式不是一朝一夕就能实现的。</p>
<p><img src="http://growthsupply.com/wp-content/uploads/2017/10/dhh.png" alt=""></p>
<p>相反，你将需要一个可持续的引擎，一次又一次地<strong>在不同的环境和情况下向人们展示新的心智模式。</strong></p>
<p>例如，尽管Drift的博客每月已经超过了10万人，他们打开新的渠道，达到他们无法达到的观众，否则他们不会通过：</p>
<ul>
<li><p><strong>他们一年一度的“<a href="https://hypergrowth.drift.com/" target="_blank" rel="external">超级增长</a>”会议</strong>，专门讨论营销和销售的未来;</p>
</li>
<li><p><strong>他们的“<a href="https://itunes.apple.com/us/podcast/seeking-wisdom/id1072506427" target="_blank" rel="external">寻找智慧</a>”播客</strong>，通过音频对话传播他们的信息。</p>
</li>
</ul>
<p>像Drift一样，Basecamp的创始人们建立了一个多渠道的引擎，通过他们的畅销书，如’<a href="https://www.amazon.com/Rework-Jason-Fried/dp/0307463745" target="_blank" rel="external">返工</a>‘，他们的<a href="https://m.signalvnoise.com/" target="_blank" rel="external">流行博客</a>和<a href="https://rework.fm/" target="_blank" rel="external">播客</a>来接触新的人。</p>
<p>尽管如此，建立一个引导人们去思考新的思维方式的方法并不是保留给创业公司的。</p>
<p>像GE这样的大公司已经认识到他们称之为<strong>“市场份额之前的分享”</strong>的重要性。</p>
<p>GE的首席营销官<a href="https://hbr.org/2014/07/innovation-is-marketings-job-too" target="_blank" rel="external">Beth Comstock解释</a>了为什么他们大量投资于内容引擎:</p>
<blockquote>
<p>真正好的创新需要在被接受之前得到解释……这意味着成为一家内容工厂 - 从数据到视频，再到社交媒体，讲述媒体和方法的故事。</p>
</blockquote>
<p><strong>MailChimp的方式，Drift的方式，或着你的方式</strong></p>
<p>从博主到创业创始人，今天的制作者们都越来越关注：</p>
<blockquote>
<p>噪音太大，竞争如此激烈。</p>
</blockquote>
<p>像SaaS这样的空间变得<a href="https://hitenism.com/copycat-competitors-take-market/" target="_blank" rel="external">越来越有竞争力</a>，公司觉得他们差不多是在<a href="https://www.groovehq.com/blog/commoditization" target="_blank" rel="external">出售商品</a>，或者他们的产品可以在一夜之间复制。</p>
<p>这就是为什么在今天这个历史上<a href="https://medium.com/swlh/how-to-start-a-blog-in-the-most-cluttered-marketplace-in-history-ef50db328a09" target="_blank" rel="external">最混乱的市场</a>上，建立一场运动比以往任何时候都重要。</p>
<p>建立它，以MailChimp方式，漂移的方式，或你的方式。不管你采取什么样的路线，在企业中有一个与自己相得益彰的要素是一致的：对自己忠实。</p>
<p>对于MailChimp来说，这意味着推出非常规的营销活动，<a href="https://mailchimp.com/did-you-mean/" target="_blank" rel="external">故意错误地发音</a>他们的名字：</p>
<blockquote>
<p>我们相信与客户建立关系的最好方式就是成为你自己。</p>
<p>对我们来说，这意味着我们的名字有乐趣。</p>
</blockquote>
<p>对于Drift来说，这意味着在他们的首席营销官和首席执行官之间进行诚实的交谈 虽然世界上充斥着假装看起来专业的播客，Drift的非正式播客风格是“<a href="https://itunes.apple.com/us/podcast/seeking-wisdom/id1072506427?mt=2" target="_blank" rel="external">寻求智慧</a>”拥有忠实粉丝的原因之一。</p>
<p>正如Basecamp的创始人所<a href="https://www.amazon.com/Rework-Jason-Fried/dp/0307463745" target="_blank" rel="external">指出</a>的那样，倾注于自己的产品是一种从人群中脱颖而出的有力方式：</p>
<blockquote>
<p>如果你成功了，人们会试着复制你所做的。但是有一个很好的方法来保护自己免受抄袭：</p>
<p>让你成为你的产品或服务的一部分。注入你对销售方式的独特看法。</p>
<p>把自己投入到产品和产品周围：你是如何销售的，你是如何提供产品支持的，你是如何向顾客解释产品的，以及你是如何交付产品的。</p>
<p>竞争者永远不能复制你的产品。</p>
</blockquote>
<p>这对生意有好处。</p>
<p>-</p>
<p>不要建立一个初创公司，而是发起一场运动 - 从第一天开始。</p>
<p>如果你做得对，像我这样的超级粉丝可能会自愿花午餐时间，因采用你提供的方案而与他人进行激烈的讨论。</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="http://growthsupply.com/build-startup-movement/" target="_blank" rel="external">Don’t Build a Startup, Build a Movement</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个创业者，我并不喜欢和开发者在午餐时间发生争论。&lt;/p&gt;
&lt;p&gt;”这是胡说，“我们的首席技术官回复。“MailChimp的产品并不比其他产品好，这只是另一个发送消息的通讯工具而已。当它竞争对手提供同样的功能只需要花费几块钱时，为什么每月要额外花费200美元呢？“&lt;/p
    
    </summary>
    
      <category term="译文" scheme="http://XibHe.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="译文" scheme="http://XibHe.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="创业" scheme="http://XibHe.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking到底做了什么？</title>
    <link href="http://XibHe.github.io/2017/11/26/AF3.x/"/>
    <id>http://XibHe.github.io/2017/11/26/AF3.x/</id>
    <published>2017-11-25T16:00:00.000Z</published>
    <updated>2018-03-22T03:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在对接一个demo，主要是调用一下SDK，实现一些功能。发现这个demo的网络请求部分是基于<strong>NSURLConnection</strong>做的一些简单调用。用起来感觉总是怪怪的，于是就想切换回自己一直在用的<strong>AFNetworking</strong>。结果，和我想的还是不太一致。同时，也暴露出一个严重的问题：对<strong>AFNetworking</strong>实现原理，到底做了什么？可以说是一窍不通。之前一直以为对<strong>AFNetworking</strong>很熟悉了，现在看来，也只是停留在调用<strong>AFHTTPSessionManager</strong>的表面。</p>
<p><strong>NSURLSession</strong>， <strong>NSURLSessionDataTask</strong>这两个类是iOS做网络请求的核心类，而AFNetworking则是对其做了一系列封装，简化了使用系统原生API做网络请求的过程。</p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>更新记录:</p>
<ul>
<li>2017 年 11 月，第一版。</li>
<li>2017 年 12 月，对具体的步骤进行归类整理。</li>
</ul>
<p>对<strong>AFNetworking</strong>调用是做了一层简单的封装，将请求时用到的各种参数在一个继承自NSObject的类中统一配置。如下，</p>
<pre><code class="objectivec">+ (void)postWithUrl:(NSString*)url params:(NSDictionary*)params  success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure
{
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
    [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
    manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间
    manager.responseSerializer = [AFJSONResponseSerializer serializer];
    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@&quot;text/html&quot;];
    [manager POST:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

        NSDictionary *bodyObjDic = [responseObject objectForKey:@&quot;body&quot;];
        CLog(@&quot;bodyObjDic = %@&quot;,bodyObjDic);
        NSString *code = [bodyObjDic objectForKey:@&quot;code&quot;];
        CLog(@&quot;url = %@,code = %@&quot;,url,code);
        if ([code isEqualToString:@&quot;200&quot;]) {
            if(success)
                success ([responseObject objectForKey:@&quot;body&quot;]);
        } else if(code == nil){
            NSError *error = [NSError errorWithDomain:@&quot;请求错误&quot; code:-1 userInfo:nil];
            if(failure)
                failure(error);
        }

    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        if([@&quot;NSURLErrorDomain&quot; isEqualToString:error.domain]){
            error = [NSError errorWithDomain:@&quot;请监测您的网络环境&quot; code:error.code  userInfo:nil];
        }
        if([@&quot;NSCocoaErrorDomain&quot; isEqualToString:error.domain]){
            error = [NSError errorWithDomain:@&quot;服务器繁忙，请稍候重试&quot; code:error.code userInfo:nil];
        }
        if(failure)
            failure(error);
    }];
}
</code></pre>
<p>再将所有用于请求的url都放在这个类的类别中，统一管理。如下，</p>
<pre><code class="objectivec">/**
 注册接口
 */
+ (void)getRegistedWithParams:(NSDictionary*)params success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure
 {
     [self postWithUrl:[NSString stringWithFormat:@&quot;%@&quot;,kILVBHost] params:params success:^(id JSON) {
        if(success){
            success(JSON);
        }
    } failure:^(NSError *error) {
        if(failure){
            failure(error);
        }
    }];
 }
</code></pre>
<p>demo在网络请求时，会将参数转换并设置到<strong>HTTPBody</strong>中，上面那种直接使用<strong>AFHTTPSessionManager</strong>进行POST请求的方式就不行，其无法在请求时将请求的参数设置到request的HTTPBody中。于是，尝试通过新建一个<strong>NSMutableURLRequest</strong>请求，通过设置它的<strong>HTTPBody</strong>到达目的。如下，</p>
<pre><code class="objectivec">+ (void)postWithUrl:(NSString*)url params:(NSDictionary*)params  success:(HttpSuccessBlock)success failure:(HttpFailureBlock)failure
{
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    [manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
    [manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
    manager.requestSerializer.timeoutInterval = 20.f; //设置请求超时时间
    manager.responseSerializer = [AFJSONResponseSerializer serializer];
    NSError *requestError = nil;
    NSMutableURLRequest *request = [manager.requestSerializer requestWithMethod:@&quot;POST&quot; URLString:url parameters:params error:&amp;requestError];
    request.HTTPBody = [NSData data];
    [manager.session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        CLog(@&quot;data = %@,response = %@&quot;,data,response);
    }];
}
</code></pre>
<p>但请求时会报500的错误。看来还需要接着往深了抛，看看<strong>AFNetworking</strong>到底做了什么？</p>
<p>这里之所以会设置<strong>manager.requestSerializer</strong>为：</p>
<pre><code class="objectivec">[manager.requestSerializer setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
[manager.requestSerializer setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
</code></pre>
<p>是将<strong>NSMutableURLRequest</strong>与<strong>manager.requestSerializer</strong>混为一谈了。</p>
<p>demo中通过<strong>NSMutableURLRequest</strong>设置相应的请求头的属性值，如下：</p>
<pre><code class="objectivec">NSURL *URL = [NSURL URLWithString:url];
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];

if (data){
 [request setValue:[NSString stringWithFormat:@&quot;%ld&quot;,(long)[data length]] forHTTPHeaderField:@&quot;Content-Length&quot;];
 [request setHTTPMethod:@&quot;POST&quot;];
 [request setValue:@&quot;application/json; charset=UTF-8&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
 [request setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;];
 [request setHTTPBody:data];        
}
</code></pre>
<p>而<strong>manager.requestSerializer</strong>用于设置<strong>AFHTTPRequestSerializer</strong>(请求参数解析类)的，之所以会报解析或者服务器先关错误，是由于没有设置网络请求的解析方式导致。而<strong>responseSerializer</strong>默认使用了JSON的解析方式，这也是为什么当使用AFN进行网络请求时，JSON会自动进行解析的原因。这里如果想进行默认的request和response序列化，就要在manager的默认设置完成之后，在开始进行网络访问前使用：</p>
<pre><code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
manager.requestSerializer = [AFJSONRequestSerializer serializer];
manager.responseSerializer = [AFJSONResponseSerializer serializer];
</code></pre><p>即可实现返回数据的自动解析。</p>
<h2 id="AFNetworking到底做了什么？"><a href="#AFNetworking到底做了什么？" class="headerlink" title="AFNetworking到底做了什么？"></a>AFNetworking到底做了什么？</h2><h3 id="AFNetworking概述"><a href="#AFNetworking概述" class="headerlink" title="AFNetworking概述"></a>AFNetworking概述</h3><p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-03-21-afnetworking-arch.png" alt=""><br><a href="https://draveness.me/afnetworking1" target="_blank" rel="external">图片所在原文链接</a></p>
<p>AF分为如下5个功能模块：</p>
<ul>
<li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li>
<li>网络通信信息序列化/反序列化模块(Serialization)</li>
<li>网络状态监听模块(Reachability)</li>
<li>网络通信安全策略模块(Security)</li>
<li>对于iOS UIKit库的扩展(UIKit)</li>
</ul>
<p>AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的上层封装。而其余的四个模块，均是为了配合AFURLSessionManager类的网络通信做一些必要的处理工作。如上图，所示。</p>
<p>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager去做。 </p>
<p><a href="https://www.jianshu.com/p/856f0e26279d" target="_blank" rel="external">以上内容原文链接</a></p>
<h3 id="对外接口类AFHTTPSessionManager"><a href="#对外接口类AFHTTPSessionManager" class="headerlink" title="对外接口类AFHTTPSessionManager"></a>对外接口类AFHTTPSessionManager</h3><p>AFHTTPSessionManager不做实事，只是提供了对外调用的接口。</p>
<ul>
<li>调用父类方法进行初始化</li>
</ul>
<pre><code class="objectivec">- (instancetype)initWithBaseURL:(NSURL *)url
           sessionConfiguration:(NSURLSessionConfiguration *)configuration
{
    self = [super initWithSessionConfiguration:configuration];
    if (!self) {
        return nil;
    }
    //....
    return self;
}
</code></pre>
<ul>
<li>类似网络请求方法中，调用父类方法拿到task，这个类仅仅是把得到的task，resume即可</li>
</ul>
<pre><code class="objectivec"> NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;                                                   URLString:URLString parameters:parameters uploadProgress:nil                                             downloadProgress:downloadProgress                                                        success:success                                                       failure:failure];
 // 开始任务
 [dataTask resume];
</code></pre>
<ul>
<li>AFHTTPSessionManager还做了一件很重要的事，就是把传过来的参数，编码成我们请求时需要的<strong>request</strong>，并且传给父类去做网络请求。</li>
</ul>
<p>NSURLSession， NSURLSessionDataTask</p>
<pre><code class="objectivec">NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];
</code></pre>
<h3 id="AFNetworking请求核心类：AFURLSessionManager"><a href="#AFNetworking请求核心类：AFURLSessionManager" class="headerlink" title="AFNetworking请求核心类：AFURLSessionManager"></a>AFNetworking请求核心类：AFURLSessionManager</h3><p><strong>NSURLSessionDataTask,</strong><br>AFHTTPSessionManager的初始化方法，触发了这个类所有的初始化<br>初始化方法：</p>
<pre><code class="objectivec">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration；
</code></pre>
<pre><code class="objectivec">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    self = [super init];
    if (!self) {
        return nil;
    }

    if (!configuration) {
        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    }

    self.sessionConfiguration = configuration;

    self.operationQueue = [[NSOperationQueue alloc] init];
    // queue并发线程数为1，这个是代理回调的queue
    self.operationQueue.maxConcurrentOperationCount = 1;

    // 注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法。
    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    // 各种响应转码
    self.responseSerializer = [AFJSONResponseSerializer serializer];

    // ssl证书，是验证证书，还是公钥，还是不用
    self.securityPolicy = [AFSecurityPolicy defaultPolicy];

#if !TARGET_OS_WATCH
    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
#endif

    // 设置存储NSURL，task与AFURLSessionManagerTaskDelegate的词典（重点，在AF中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理）
    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

    // 设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全
    self.lock = [[NSLock alloc] init];
    self.lock.name = AFURLSessionManagerLockName;

    // 为所管理的session的所有task设置完成块,此方法为生成session之后就调用
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {

    // 置空处理
        for (NSURLSessionDataTask *task in dataTasks) {
            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];
        }

        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
        }

        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
        }
    }];

    return self;
}
</code></pre>
<p>这个方法初始化了一些我们后续需要用到的属性，其他的都很简单，唯一比较费解的两处可能是：</p>
<pre><code class="objectivec">self.operationQueue.maxConcurrentOperationCount = 1;

[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
       //置空处理
 }];
</code></pre>
<p>我们首先来讲讲这两个操作的作用：</p>
<ul>
<li><p>第一是让回调的代理queue是串行的，即请求完成的task只能一个个被回调。</p>
</li>
<li><p>第二是清空了session中所有task。</p>
</li>
</ul>
<pre><code class="objectivec">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {

    // 第一件事，创建NSURLSessionDataTask，里面适配了Ios8以下taskIdentifiers，函数创建task对象。
    __block NSURLSessionDataTask *dataTask = nil;

    // 其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理
    url_session_manager_create_task_safely(^{
        dataTask = [self.session dataTaskWithRequest:request];
    });

    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];

    return dataTask;
}
</code></pre>
<p>类似这个类中很多方法这样的方法，这些方法主要做两件事：</p>
<ol>
<li>调用session的方法，传request过去去生成task。注意这里调用了<strong>url_session_manager_create_task_safely</strong>函数去执行的Block,这个函数实现如下：</li>
</ol>
<pre><code class="objectivec">static void url_session_manager_create_task_safely(dispatch_block_t block) {
    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {
        dispatch_sync(url_session_manager_creation_queue(), block);
    } else {
      block();
    }
}
</code></pre>
<p>简单来讲就是为了适配iOS8以下task创建，其中taskIdentifiers属性不唯一，而这个属性是我们之后添加代理的key，它必须是唯一的。 所以这里做了一个判断，如果是iOS8以下，则用串行同步的方式去执行这个Block，也就是创建session。否则直接执行。</p>
<ol>
<li><strong>给每个task创建并对应一个AF的代理对象，这基本上是这个类的核心所在了</strong>，这个代理对象为其对应的“task做数据拼接及成功回调。</li>
</ol>
<p>方法如下：</p>
<pre><code class="objectivec">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask
                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
{
    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
    // AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系
    delegate.manager = self;
    delegate.completionHandler = completionHandler;
    // 这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应
    dataTask.taskDescription = self.taskDescriptionForSessionTasks;

    // 将AF delegate对象与 dataTask建立关系
    [self setDelegate:delegate forTask:dataTask];

    // 设置AF delegate的上传进度，下载进度块
    delegate.uploadProgressBlock = uploadProgressBlock;
    delegate.downloadProgressBlock = downloadProgressBlock;
}
</code></pre>
<p>将<strong>AF delegate</strong>对象与<strong>dataTask</strong>建立关系</p>
<pre><code class="objectivec">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
            forTask:(NSURLSessionTask *)task
{
    // 断言，如果没有这个参数，debug下crash在这
    NSParameterAssert(task);
    NSParameterAssert(delegate);

    // 加锁保证字典线程安全
    [self.lock lock];

    // 将AF delegate放入以taskIdentifier标记的字典中（同一个NSURLSession中的taskIdentifier是唯一的）
self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;

    // 为AF delegate 设置task 的progress监听
    [delegate setupProgressForTask:task];

    // 添加task开始和暂停的通知
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}
</code></pre>
<p>以上两个方法创建了一个AFURLSessionManagerTaskDelegate的代理，把这个代理和task的taskIdentifier一一对应，放到我们最早初始化的字典里，建立起映射。</p>
<p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，这些代理开始调用了：</p>
<p><strong>NSURLSessionDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
didBecomeInvalidWithError:(NSError *)error；

- (void)URLSession:(NSURLSession *)session
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler;
</code></pre>
<p><strong>NSURLSessionTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
willPerformHTTPRedirection:(NSHTTPURLResponse *)response
        newRequest:(NSURLRequest *)request
 completionHandler:(void (^)(NSURLRequest *))completionHandler；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
 needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend；

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error；
</code></pre>
<p><strong>NSURLSessionDataDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didReceiveResponse:(NSURLResponse *)response
 completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler；

- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask；

- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data；

- (void)URLSession:(NSURLSession *)session
          dataTask:(NSURLSessionDataTask *)dataTask
 willCacheResponse:(NSCachedURLResponse *)proposedResponse
 completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler；
</code></pre>
<p> <strong>NSURLSessionDownloadDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location；

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite；

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 didResumeAtOffset:(int64_t)fileOffset
expectedTotalBytes:(int64_t)expectedTotalBytes；
</code></pre>
<ul>
<li><p>AFURLSessionManager一共实现了如上所列举的一大堆NSUrlSession相关的代理。</p>
</li>
<li><p>而只转发了其中3条到AF自定义的delegate中：</p>
</li>
</ul>
<p><strong>NSURLSessionTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(__unused NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error;
</code></pre>
<p><strong>NSURLSessionDataTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(__unused NSURLSession *)session
          dataTask:(__unused NSURLSessionDataTask *)dataTask
    didReceiveData:(NSData *)data;
</code></pre>
<p><strong>NSURLSessionDownloadTaskDelegate：</strong></p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location;
</code></pre>
<p>AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p>
<p>总结一下，这些代理主要是做了一些额外的处理，并且调用了它的属性Block：</p>
<pre><code class="objectivec">@interface AFURLSessionManager ()
@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;
@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;
@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;
@end
</code></pre>
<p>等属性……</p>
<p>我们可以利用这些Block，做一些自定义的处理，Block会随着代理调用而被调用，这些代理帮我们做了一些类似数据分片、断点续传、https认证等工作</p>
<p>除此之外，有3个代理方法回调了我们的task的AF代理，包括<strong>请求完成</strong>的代理，<strong>收到数据</strong>的代理，以及<strong>下载完成</strong>的代理，以第一个为例：</p>
<pre><code class="objectivec">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
{
   // 根据task去取我们一开始创建绑定的delegate
    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];

    // delegate may be nil when completing a task in the background
    if (delegate) {
    // 把代理转发给我们绑定的delegate
        [delegate URLSession:session task:task didCompleteWithError:error];
    // 转发完移除delegate 
       [self removeDelegateForTask:task];
    }
    // 公用Block回调
    if (self.taskDidComplete) {
        self.taskDidComplete(session, task, error);
    }
}
</code></pre>
<p>通过我们之前设置的task和AF代理映射，去调用AF代理，并且把这个task从映射字典中移除。</p>
<p>接着就调用了AF的代理：(自定义代理3条中的一条)</p>
<pre><code class="objectivec">// AF实现的代理！被从urlsession那转发到这
- (void)URLSession:(__unused NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error
{

 // 强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block 
    __strong AFURLSessionManager *manager = self.manager;

    __block id responseObject = nil;

   // 用来存储一些相关信息，来发送通知用的
    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
   // 存储responseSerializer响应解析对象
    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;

    // Performance Improvement from #2672
    // **注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存** 
    NSData *data = nil;
    if (self.mutableData) {
        data = [self.mutableData copy];
        //We no longer need the reference, so nil it out to gain back some memory.
        self.mutableData = nil;
    }

    // 继续给userinfo填数据
    if (self.downloadFileURL) {
        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
    } else if (data) {
        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;
    }
    // 错误处理
    if (error) {
        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;

    // 可以自己自定义完成组 和自定义完成queue,完成回调
        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
            if (self.completionHandler) {
                self.completionHandler(task.response, responseObject, error);
            }
     // 主线程中完成通知
            dispatch_async(dispatch_get_main_queue(), ^{
                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
            });
        });
    } else {
        dispatch_async(url_session_manager_processing_queue(), ^{
            NSError *serializationError = nil;

            // 解析数据
            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];

            // 如果是下载文件，那么responseObject为下载的路径
            if (self.downloadFileURL) {
                responseObject = self.downloadFileURL;
            }

            // 写入userInfo
            if (responseObject) {
         userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
            }
           // 如果解析错误
            if (serializationError) {
                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
            }
           // 回调结果
            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
                if (self.completionHandler) {
                    self.completionHandler(task.response, responseObject, serializationError);
                }

                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
                });
            });
        });
    }
}
</code></pre>
<p>虽然这个方法有点长，但是它主要做了两件事：</p>
<ol>
<li><p>调用responseSerializer按照我们设置的格式，解析请求到的数据。</p>
</li>
<li><p>用completionHandler把数据回调出去，至此数据回到了用户手中。</p>
</li>
</ol>
<p>到这里，AF的整个主线流程就完了，当然，我们跳过了很多细节没有讲，比如responseSerializer的各种格式的解析过程，还有为了监听task的开始和挂起通知，所做的<strong>method swizzling</strong>，这里对iOS7的兼容问题的处理，算是相当精彩了。</p>
<p><a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="external">以上内容原文链接</a></p>
<h3 id="处理请求和响应：AFURLSerialization"><a href="#处理请求和响应：AFURLSerialization" class="headerlink" title="处理请求和响应：AFURLSerialization"></a>处理请求和响应：AFURLSerialization</h3><p>对发出请求以及接收响应的过程进行序列化，这涉及到两个模块：</p>
<ul>
<li>AFURLResponseSerialization</li>
<li>AFURLRequestSerialization</li>
</ul>
<p>前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。<br>我们首先会对 <strong>AFURLResponseSerialization</strong> 进行简单的介绍，因为这个模块使用在 <strong>AFURLSessionManager</strong> 也就是核心类中，而后者 <strong>AFURLRequestSerialization* 主要用于 </strong>AFHTTPSessionManager** 中，因为它主要用于修改 HTTP 头部。</p>
<p>有关解析类的详情见原文：</p>
<p><a href="https://draveness.me/afnetworking3#AFURLRequestSerialization" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三)</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本来想自己写关于AFN的使用心得，但发现自己的水平有限，不能把AFN主要做了什么？它是如何实现网络请求和解析的？这些问题说明白。只能将大牛文章中的精彩内容粘贴出来，做了一个简短的整理。这里引述<a href="https://www.jianshu.com/u/14431e509ae8" target="_blank" rel="external">涂耀辉</a>在<a href="https://www.jianshu.com/p/7ed7c0be15b4" target="_blank" rel="external">AFNetworking到底做了什么? (终)</a>一文中所说的一句话：</p>
<blockquote>
<p>AFNetworking中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.v2ex.com/amp/t/358780" target="_blank" rel="external">如何使用 AFNetworking 3.0 设置 Request.HttpBody</a> </p>
<p><a href="http://www.jianshu.com/p/856f0e26279d" target="_blank" rel="external">AFNetworking到底做了什么？</a> </p>
<p><a href="https://www.jianshu.com/p/f32bd79233da" target="_blank" rel="external">AFNetworking到底做了什么？(二)</a></p>
<p><a href="https://draveness.me/afnetworking1" target="_blank" rel="external">AFNetworking 概述（一）</a></p>
<p><a href="https://draveness.me/afnetworking3#AFURLRequestSerialization" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在对接一个demo，主要是调用一下SDK，实现一些功能。发现这个demo的网络请求部分是基于&lt;strong&gt;NSURLConnection&lt;/strong&gt;做的一些简单调用。用起来感觉总是怪怪的，于是就想切换回自己一直在用的&lt;strong&gt;AFNetworking&lt;/s
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="AFNetworking" scheme="http://XibHe.github.io/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>(译)软件开发这份工作到了35岁之后就是尽头了吗</title>
    <link href="http://XibHe.github.io/2017/11/19/dead-end%20job%20/"/>
    <id>http://XibHe.github.io/2017/11/19/dead-end job /</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2017-11-19T08:23:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>我想你会问3个不同的问题，也许应该修改一下这个问题。我们来分解一下吧：</p>
<ol>
<li>年龄歧视是软件开发行业中的问题吗？</li>
<li>你应该把自己的职业转向管理角色，而不是个人开发者角色吗？</li>
<li>软件开发个人开发者是一个死胡同吗？</li>
</ol>
<p>在Quora上关于这些问题的提问，每个问题都有详细的回答，其中细节如上所述，所以我将简要地讨论每个问题。</p>
<p>对于年龄歧视，我不认为有人会否认这个行业有一定的年龄歧视。你可以看看几乎所有硅谷公司的新员工的平均年龄。我怀疑，大多数中等雇佣年龄远低于30。然而，这并不一定意味着官方的公司政策不会雇用超过一定年龄，种族，性别，性别偏好或其他特征的候选人。</p>
<p>为什么在高科技产业中存在年龄歧视，原因是多方面的，并非是所有公司一起商量好不雇用年长员工。一方面，许多公司发现，使用新的大学毕业生（麻省理工学院和斯坦福大学等）作为招聘的主要对象是最容易的。新毕业生便宜。他们有一个稳定的质量。他们不受其他公司经验的束缚。他们是一张白纸，比较容易教他们企业文化，软件方法论，最佳实践，并与参与其他业务的新毕业相互配合工作。</p>
<p>我认为，硅谷的任何人都不会认为，如果你有一个在相关技术方面拥有3年扎实编程经验的候选人（加上也是有名望的毕业生），不是一个好的候选人。事实上，我甚至可以说N年开发经验并不重要，没有确切的说明，有N年相关经验的候选人比N + 1年经验的候选人要好，所有其他因素是平等的，技能 以及与公司正在进行的业务相关的经验。</p>
<p>对于工程师来说，保持相关性的技术变化太快的说法可能是一回事，但是构建网络的核心技术已经存在了几十年了。C语言早在七十年代末就出现了，已近有将近四十多年的历史了。Javascript语言，第一次出现在1997年，大概是20年前。这意味着几十年开发经验的工程师，他们的工作已经接近退休年龄，整个职业生涯一直专注于C和运行Unix服务器。这样的工程师非常少，有这么多的经验，但是我怀疑有谁会试图宣称刚刚毕业的22岁的人肯定比60岁的人好，相比之下，他们的一些人已近专研了40多年技术。当然，这些类型的工程师很少。</p>
<p>因此，对于问题的另一方面，我不认为软件工程是一个死胡同的事业。我想说的是，在薪酬增长方面，在一定的时间之后，它会趋于稳定。部分原因就是工程师本质上是人为的商品。除非你是一个非常特别的工程师，事实上，你总是可以被其他人取代。与其他竞争性行业相比，我认为这有助于保持软件工程工资水平。不过，我几乎可以保证，对软件工程师的需求将超过应聘者中新毕业生或其他人的供应，所以你总能找到工作。不过，你可能不会每年收到那些10％的指数提升，就像你两三年前那样。</p>
<p>最后，关于转为管理者是否是一个更好的选择，我想问为什么只考虑这个选项？当然有许多职业道路可供选择。你可以转换到另一个工程领域。例如，许多不喜欢创造产品的软件工程师会转移到其他角色，有时在同一个公司，例如运营，产品管理，项目管理，质量保证，或者更少的技术，如销售或行政职位。我也有一些完全改变职业的朋友，比如全职教学。</p>
<p>最后让我说，以为自己为例，在和那些具有扎实工程背景的经理人员一起工作时，我很欣赏他们，最好是与公司相关技术的软件工程，所以请不要急于进入工程管理的职业道路。对于我们这些将来可能不得不与你打交道的人，作为开发者，可以获得5年或6年的良好工程实践经验。了解这个行业是如何运作的，作为一个经验丰富的开发者。只有这样，才能考虑把你的职业转向管理方向。就像你不会雇用花店来建造布鲁克林大桥。同样也不会聘请没有任何开发经验的人担任项目经理。</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://www.quora.com/Is-software-development-really-a-dead-end-job-after-age-35-40/answer/Jeff-Nelson-32?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website" target="_blank" rel="external">Is software development really a dead-end job after age 35-40?</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我想你会问3个不同的问题，也许应该修改一下这个问题。我们来分解一下吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;年龄歧视是软件开发行业中的问题吗？&lt;/li&gt;
&lt;li&gt;你应该把自己的职业转向管理角色，而不是个人开发者角色吗？&lt;/li&gt;
&lt;li&gt;软件开发个人开发者是一个死胡同吗？&lt;/li&gt;

    
    </summary>
    
      <category term="译文" scheme="http://XibHe.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="译文" scheme="http://XibHe.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="职业生涯" scheme="http://XibHe.github.io/tags/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title>凌冬将至</title>
    <link href="http://XibHe.github.io/2017/11/11/introspect/"/>
    <id>http://XibHe.github.io/2017/11/11/introspect/</id>
    <published>2017-11-10T16:00:00.000Z</published>
    <updated>2017-11-26T05:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>至此光棍节来临之际，祝各位光棍们节日快乐，年年无今日，岁岁无今朝，早日脱单。最近一个月不是很忙，之前做的项目在8月中旬停了下来，项目是停了下来，但整个项目组却闲不下来。九月份接手了一个新需求，为公司的另一个项目开发录入药品的小程序。工期算上测试、发布大概是二十天。这中间虽然是第一次接触小程序开发，最后，跌跌撞撞的总算是顺利上线了。</p>
<p>开发小程序的这段时间，总是有些难熬，自己之前并没有HTML、CSS、JavaScript的基础，在w3cschool上看了两天的HTML、CSS基础，就硬着头皮上了。不过还好有一个前端老司机带着，一起踩踩小程序的坑。在前两年前端很火的时候，我就很想跟风学习一下了，但总是给自己找各种理由。最后，学习计划就不了了之了。这次的学习动机来的如此强烈，看来只有<strong>将自己的学习动力与工作中的业务需求捆绑起来，才能迈出这第一步</strong>。</p>
<p>随着开发的深入，不得不惊讶于小程序<strong>“用完即走”</strong>的设计理念。与移动端APP相比，小程序真的很小，开发成本小的多。不得不感慨，移动开发的凌冬将至，或许早已来临了。苹果的光环正在消退，不只是iOS开发，没有哪种技术是长盛不衰的，对所有的与技术相关的开发者而言:</p>
<blockquote>
<p>请勿陷入对技术的狂热之中</p>
</blockquote>
<p>自从今年以来，发现了自己的技术短板。因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。因此陷入了对自己熟悉技术的狂热之中而无法自拔。这样只会使我们变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。</p>
<p>最近两年以来，互联网的发展不再像早期那样粗放了，对各种技术人员的需求趋于稳定。<strong>“一招鲜，吃遍天”</strong>的时代终会落幕，全栈会成为一种趋势。不只贫穷会限制我们的想象力，作为一名开发者，我们因对某项技术的狂热崇拜也会限制我们在业务需求上的想象力。应戒之，慎之。</p>
<p>但无论如何增加知识广度的同时，先扪心自问自己所擅长技术是否全面掌握了。拿我自己来说，也有四年多 iOS 开发经验了，但做的项目都是很普通的那种。这里并不是说普通项目不能提高开发水平，相对于那些业务逻辑复杂的项目，其复杂的关联业务、交互设计会早早的暴露出性能方面的问题，因此，开发者不得不从各方面考虑，最终深入研究这些技术点，并形成最终的优化方案。而普通应用很少遇到性能上的瓶颈，开发者也早已习惯了这种堆代码、堆逻辑的开发流程，渐渐麻木，在技术上不在积极进取。我管这种开发者叫“码农”，“搬砖工”。很不幸，我自己就是这样的“码农”。</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/introspect1.png" alt=""></p>
<p>这也是很多初级中级 iOS 开发者的共性，没有深入某一具体的方向解决对应的问题，没有自己的技术深度。当我们被全栈开发这种趋势追赶着拼命向前奔命，花费时间、精力学习那些新技术时，需要反思自己有没有达到所擅长领域的技术深度，对掌握的知识，是肤浅还是真正的精通。</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/introspect2.jpg" alt=""></p>
<p>互联网发展非常快，每天每个月都有很多的新技术面世。在我们朝着全栈一路狂奔时，需要思考为什么要用这个技术？它能解决什么问题？有什么弊端吗？为了技术而技术，考虑问题的全面性就会差很多。裹足不前不行，盲目追新亦是不行，这里很考验我们对新技术的判断，最终这些技术都要对应业务场景，或许多经历几次因业务需求变化而导致的通宵加班，彻夜上线才会让开发者有所反思，经历几次痛苦的重构才会刻骨铭心吧！</p>
<p>但无论如何，凌冬将至，大家过冬的粮食都储备充足了吗？</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;至此光棍节来临之际，祝各位光棍们节日快乐，年年无今日，岁岁无今朝，早日脱单。最近一个月不是很忙，之前做的项目在8月中旬停了下来，项目是停了下来，但整个项目组却闲不下来。九月份接手了一个新需求，为公司的另一个项目开发录入药品的小程序。工期算上测试、发布大概是二十天。这中间虽然
    
    </summary>
    
      <category term="随笔" scheme="http://XibHe.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="自省" scheme="http://XibHe.github.io/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
  <entry>
    <title>利用JenKins持续集成iOS项目时遇到的问题</title>
    <link href="http://XibHe.github.io/2017/11/06/JenKins-Continuous-Integration/"/>
    <id>http://XibHe.github.io/2017/11/06/JenKins-Continuous-Integration/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2018-07-26T04:40:47.403Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成(Continuous Integration，简称CI)是一种软件开发实践：许多团队频繁地集成他们的工作，每位成员通常进行日常集成，进而每天会有多种集成。每个集成会由自动的构建（包括测试）来尽可能快地检测错误。许多团队发现这种方法可以显著的减少集成问题并且可以使团队开发更加快捷。</p>
<p>CI是一种开发实践。实践应该包含3个基本模块，一个可以自动构建的过程，自动编译代码，可以自动分发，部署和测试。一个代码仓库，SVN或者Git。最后一个是一个持续集成的服务器。通过持续集成，可以让我们通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。</p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>更新记录:</p>
<ul>
<li>2017 年 11 月，第一版。</li>
<li>2018 年 01 月，替换一些图片，增加上传ipa包到FTP。</li>
</ul>
<h2 id="持续集成的优点"><a href="#持续集成的优点" class="headerlink" title="持续集成的优点"></a>持续集成的优点</h2><ol>
<li>缩减开发周期，快速迭代版本</li>
<li>自动化流水线操作带来的高效</li>
<li>随时可部署</li>
<li>极大程度避免低级错误</li>
</ol>
<h2 id="持续化集成工具—JenKins"><a href="#持续化集成工具—JenKins" class="headerlink" title="持续化集成工具—JenKins"></a>持续化集成工具—JenKins</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<p>JenKins的用途:</p>
<ol>
<li>构建项目自动化打包可以省去开发人员好多时间，重要的是，Jenkins为我们维护了一套高质量可用的代码，而且保证了一个纯净的环境。</li>
<li>可以用来自动化测试，在本地生成大批的测试用例，每天利用服务器不断的跑这些用例。</li>
<li>静态代码分析，可以检测出很多代码的问题，比如潜在的内存泄露的问题。</li>
<li>随时部署，Jenkins在打包完成之后可以设定之后的操作，这个时候往往就是提交app到跑测试用例的系统，或者部署到内测平台生成二维码。</li>
</ol>
<h3 id="开始安装JenKins"><a href="#开始安装JenKins" class="headerlink" title="开始安装JenKins"></a>开始安装JenKins</h3><p>方法一: <a href="https://jenkins.io" target="_blank" rel="external">直接下载安装包</a></p>
<p>注意：此时有两种安装方式是</p>
<ul>
<li>标准安装，如下图</li>
</ul>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration11.png" alt=""></p>
<ul>
<li>自定义安装，此时应该取消<strong>Start at boot as “jenkins”</strong>勾选，如下图</li>
</ul>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration12.png" alt=""></p>
<p>安装完成后在Terminal中输入,</p>
<blockquote>
<p>open /Applications/Jenkins/jenkins.war</p>
</blockquote>
<p>即可打开Jenkins</p>
<p>方法二: 使用命令行安装<br>安装JenKins，</p>
<blockquote>
<p>$ brew install jenkins</p>
</blockquote>
<p>若brew无效？则需要安装homebrew，</p>
<blockquote>
<p>$ ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>
</blockquote>
<p>启动JenKins，</p>
<blockquote>
<p>$ jenkins</p>
</blockquote>
<p>启动JenKins后使用浏览器访问JenKins，</p>
<p>地址为: <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a></p>
<p>使用安装包安装后会自动打开，如果端口冲突那么请修改端口</p>
<blockquote>
<p>defaults write /Library/Preferences/org.jenkins-ci httpPort 7070</p>
</blockquote>
<font color="ff6d55"><strong>强烈推荐使用方法二安装JenKins，使用命令行可以避免后面构建项目时，报一些莫名其妙的权限错误。</strong> </font>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>若使用git做源码管理，则需要安装</p>
<ul>
<li>GIT plugin</li>
<li>GitHub plugin</li>
</ul>
<p>这两个插件，为了方便管理打包证书，需要安装插件</p>
<ul>
<li>Keychains and Provisioning Profiles Management</li>
</ul>
<p>由于需要使用Xcode编译环境，因此必须要安装插件 (<strong>当然，也可以不安装Xcode integration插件，使用shell脚本命令进行打包</strong>)</p>
<ul>
<li>Xcode integration</li>
</ul>
<p>若最后构建生成的ipa包，需要上传到FTP，则需要安装上传FTP的插件</p>
<ul>
<li>FTP publisher plugin</li>
</ul>
<p>我们需要依次选择 <strong>系统管理-&gt;管理插件</strong>，在<strong>“可选插件”</strong>中选中<strong>“Keychains and Provisioning Profiles Management”</strong>和<strong>“FTP publisher plugin”</strong>这两项，然后安装。如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration13.png" alt=""></p>
<h2 id="配置构建环境"><a href="#配置构建环境" class="headerlink" title="配置构建环境"></a>配置构建环境</h2><p>在配置构建环境前，我们先来导入一下打包证书，点击系统管理，找到刚才添加的插件<font color="ff6d55">Keychains and Provisioning Profiles Management</font>，点击选取文件，导入名为<font color="ff6d55">login.keychain</font>的钥匙串文件。</p>
<blockquote>
<p>这个Keychain其实在<strong>/Users/管理员用户名/Library/keychains/login.keychain</strong>,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到<strong>/Users/管理员用户名/.jenkins/workspace/项目目录名称</strong>，(.jenkins是隐藏文件)。</p>
</blockquote>
<p>如图所示，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration1.png" alt=""></p>
<p>其中，Keychains中的Identities输入项，对应的是刚才点击<font color="ff6d55">Upload</font>后钥匙串中的测试证书名称，发布证书名称(需要输入证书名称)。</p>
<p>Provisioning Profiles中对应的是刚才上传的证书配置文件。这些配置文件的存放路径为:<font color="ff6d55">/Users/管理员用户名/Library/MobileDevice/Provisioning Profiles</font></p>
<p>这样Adhoc证书和签名文件就在Jenkins中配置好了，接下来我们只需要在项目的构建配置中指定相关文件即可。</p>
<p><font color="ff6d55" size="4">注意</font>: 有些升级了最新的Mac OS系统后，<font color="ff6d55">/Users/管理员用户名/Library/keychains</font>目录下没有<strong>login.keychain</strong>文件，有的是一个名为<strong>login.keychain-db</strong>的文件，这是需要将login.keychain-db文件copy到桌面，修改成文件名为<strong>login.keychain</strong>。点击”<strong>选取文件</strong>“，选取并上传这个修改名称后的<strong>login.keychain</strong>文件。</p>
<p>导入证书后需要在”<strong>系统管理</strong>“–&gt;”<strong>系统设置</strong>“里再设置”<strong>Xcode Builder</strong>“时，访问证书的全局路径。如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration6.png" alt=""></p>
<p>“<strong>Keychain path</strong>“为钥匙串的本地路径，”<strong>Keychain password</strong>“为访问钥匙串的密码。设置完成后不要忘记点击”<strong>保存</strong>“。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>新建 -&gt; 输入项目名称 -&gt; 选择“<strong>构建一个自由风格的软件项目</strong>” -&gt; 点击ok就行了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-b52d3d102c21f004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h3><p>如图所示，<br><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration2.png" alt=""></p>
<p>其中，Repository URL对应的是svn的路径，Credentials为登录svn时的用户账号密码，点击”Add”按钮添加即可。Check-out Strategy最好选择每次update最新代码前都revert下，而不是“Use ‘svn update’ as much as possible” ，因为我使用的是CocoaPods管理的第三方，每次打包运行pod install会修改了工程配置文件，如果下次自动打包前不先revert再update的话会出现冲突。</p>
<h3 id="构建触发器"><a href="#构建触发器" class="headerlink" title="构建触发器"></a>构建触发器</h3><p>这里是设置自动化测试的地方。涉及的内容很多，暂不做深入研究，这里先不设置，有自动化测试需求的可以好好研究这里的设置。</p>
<ul>
<li><p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 <em> </em> <em> </em> 每5分钟轮询一次</p>
</li>
<li><p>Build periodically (定时build)<br>一般设置为类似： 00 20 <em> </em> * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>
</li>
</ul>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration14.png" alt=""></p>
<h3 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h3><p>勾选“<strong>Keychains andProvisioning Profiles Management</strong>”和“<strong>Mobile Provisioning Profiles</strong>”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2367707-b8668d49ff828810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2367707-e86675d8dc8c675e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这里的<strong>Code Signing Identity</strong>和<strong>Provisioning Profile</strong>选项中对应上文<font color="ff6d55">Keychains and Provisioning Profiles Management</font>插件中导入的钥匙串文件中的证书及证书的配置文件。当然也可以不勾选Mobile Provisioning Profiles。</p>
<h3 id="构建-构建步骤"><a href="#构建-构建步骤" class="headerlink" title="构建(构建步骤)"></a>构建(构建步骤)</h3><p>点击”增加构建步骤”选项，因为我使用的是CocoaPods管理的第三方，打包前先运行<br><strong>pod install –verbose –no-repo-update</strong>安装下第三方库。</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration3.png" alt=""></p>
<p><font color="ff6d55" size="5">注意:</font>执行pod install命令时，需要cd到pod文件所在的目录，<font color="ff6d55">${WORKSPACE}</font>是项目在JenKins中的工作目录，而我的项目由于多套了一层目录BusinessMall，因此需要加上这层目录<font color="ff6d55">${WORKSPACE}/BusinessMall</font>，否则，在构建时就会报:</p>
<blockquote>
<p>[!] No `Podfile’ found in the project directory.</p>
<p>Build step ‘Execute shell’ marked build as failure</p>
</blockquote>
<p>的错误。在执行完<strong>pod install</strong>后，就可以使用Xcode构建项目打包环境了。</p>
<p><strong>添加构建步骤</strong>-&gt; <strong>Xcode</strong></p>
<p>在”<strong>General build settings</strong>“中，点击”<strong>Settings</strong>“按钮设置相关参数。</p>
<blockquote>
<p>Target要与Xcode项目中Target的名字对应</p>
<p>Clean before build设置为YES</p>
</blockquote>
<p>勾选”<strong>Pack application，build and sign .ipa？</strong>“的复选框，会弹出设置生成ipa包的几个参数项。如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration7.png" alt=""></p>
<blockquote>
<p>Export method，ipa的类型(‘development’, ‘ad-hoc’, ‘enterprise’ or ‘app-store’) </p>
<p>.ipa filename pattern，ipa的名称。</p>
<p>Output directory，输出ipa的文件路径。</p>
</blockquote>
<p><font color="ff6d55">注意:</font>这里如果<strong>Xcode的版本低于9.0</strong>，就可以正常输出ipa包。如果<strong>Xcode版本不低于9.0</strong>，就会由于<font color="ff6d55">Xcode 9.0不在允许你访问钥匙串里的内容</font>，而输出ipa失败。具体的解决方法请参照后面”<strong>构建项目时遇到的几个问题</strong>“中具体的解决方法。</p>
<p>继续设置”<strong>Code signing &amp; OS X keychain options</strong>“证书信息，如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration4.png" alt=""></p>
<p>其中，Development Team ID为开发团队ID,可以在钥匙串中的证书详情里查看。勾选Unlock Keychain，显示为之前上传的login.keychain文件。</p>
<p>如果项目使用了<strong>cocoaPods</strong>,需要配置<strong>Advanced Xcode build options</strong>,设置</p>
<ol>
<li>Xcode Schema File，设为Xcode项目中的schema</li>
<li>Xcode Workspace File，这里设置绝对路径，不需要带上.xcworkspace后缀。如果项目中没有workspace后缀，那就在“Xcode Project File”上填.xcodeproj文件的路径。</li>
<li>Build output directory，设为<strong>${WORKSPACE}/build/</strong></li>
</ol>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration5.png" alt=""></p>
<p><font color="ff6d55">注意:</font>Xcode Workspace File为绝对路径，也就是Jenkins用于构建项目的workspace目录中，.xcworkspace文件所在目录的路径。</p>
<p>如果路径不正确，则在构建项目时，会报:</p>
<blockquote>
<p>open BusinessMall.xcworkspace</p>
<p>The file /Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall.xcworkspace does not exist.</p>
<p>Build step ‘Execute shell’ marked build as failure</p>
</blockquote>
<p>的错误。</p>
<h3 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h3><ul>
<li>添加构建后操作步骤，使用脚本将生成的ipa包上传到fir或者蒲公英等三方平台，扫码下载安装。</li>
</ul>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration10.png" alt=""></p>
<p>参考<a href="http://blog.fir.im/jenkins/" target="_blank" rel="external">http://blog.fir.im/jenkins/</a>使用官方工具<a href="http://7xju1s.com1.z0.glb.clouddn.com/fir-plugin-1.9.5.hpi" target="_blank" rel="external">fir-plugin-1.9.5.hpi</a>插件上传ipa包到fir。</p>
<ul>
<li>将ipa包上传到FTP服务器</li>
</ul>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration15.png" alt=""></p>
<p>如图，选择<strong>“Publish artiffacts to FTP”</strong>，其中，<strong>FTP site</strong>就是在<strong>系统管理-&gt;系统设置</strong>中，增加的一项名为<strong>“FTP repository hosts”</strong>的配置里已经设置好的host和端口。<strong>Source</strong>为构建生成的ipa包的存放路径。</p>
<h2 id="构建项目时遇到的几个问题"><a href="#构建项目时遇到的几个问题" class="headerlink" title="构建项目时遇到的几个问题"></a>构建项目时遇到的几个问题</h2><h3 id="1-pod-command-not-found"><a href="#1-pod-command-not-found" class="headerlink" title="1. pod: command not found"></a>1. pod: command not found</h3><blockquote>
<p>pod install<br>/var/folders/gn/rqsybgtn7f50w67111kj1hhw0000gn/T/hudson3821369083140563198.sh: line 2: pod: command not found<br>Build step ‘Execute shell’ marked build as failure</p>
</blockquote>
<p>解决方法: 在系统管理–&gt;系统设置，增加”全局属性”，勾选Environment variables，增加键值对列表。如图，</p>
<p><img src="http://img.blog.csdn.net/20160816160405862?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>其中，PATH是固定的，值是在终端输入:</p>
<blockquote>
<p>$echo $PATH</p>
</blockquote>
<p>命令获取，将输入命令后得到的值粘贴过来就可以了。</p>
<h3 id="2-ruby-executable-hooks-No-such-file-or-directory"><a href="#2-ruby-executable-hooks-No-such-file-or-directory" class="headerlink" title="2. ruby_executable_hooks: No such file or directory"></a>2. ruby_executable_hooks: No such file or directory</h3><blockquote>
<p>Pod: env: ruby_executable_hooks: No such file or directory<br>Build step ‘Execute shell’ marked build as failure</p>
</blockquote>
<p>从jekyll有时也会报这个错误得到启示，可能是由于执行pod命令的路径粗存在问题。在终端使用命令:</p>
<blockquote>
<p>$ which pod</p>
</blockquote>
<p>查看pod的安装路径为: <font color="ff6d55">/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod</font>，而执行pod install的shell的环境变量中可能没有该路径。于是使用命令:</p>
<blockquote>
<p>$ gem env</p>
</blockquote>
<p>查看SHELL PATH:，发现列表中没有<font color="ff6d55">/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod</font>这条路径。查阅了一些资料(<a href="https://coolestguidesontheplanet.com/add-shell-path-osx/" target="_blank" rel="external">What it is and How to Modify the Shell Path in macOS Sierra and OSX using Terminal</a>)后，发现可以在根目录的.bash_profile中增加永久的路径。在终端输入命令:</p>
<blockquote>
<p>$ sudo vi ~/.bash_profile</p>
</blockquote>
<p>打开根目录下的.bash_profile文件，将路径<font color="ff6d55">/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod</font>插入:</p>
<blockquote>
<p>export PATH:”/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod:$PATH”<br>结束编辑esc后，输入:wq保存。在终端输入命令:</p>
<p>$ source ～/.bash_profile </p>
</blockquote>
<p>让这个配置文件在修改后立即生效。此时，再查看gem env发现SHELL PATH:列表中，增加了<font color="ff6d55">/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod</font>这条路径。</p>
<h3 id="3-find-spec-for-exe’-can’t-find-gem-cocoapods-gt-0-a-Gem-GemNotFoundException"><a href="#3-find-spec-for-exe’-can’t-find-gem-cocoapods-gt-0-a-Gem-GemNotFoundException" class="headerlink" title="3. `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)"></a>3. `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)</h3><blockquote>
<p> /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/lib/ruby/         site_ruby/2.2.0/rubygems.rb:271:in <code>find_spec_for_exe&#39;: can&#39;t  find gem cocoapods (&gt;= 0.a) (Gem::GemNotFoundException)
    from /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/lib/  ruby/site_ruby/2.2.0/rubygems.rb:299:in</code>activate_bin_path’<br>    from /Users/zyjk_imac-penghe/.rvm/rubies/ruby-2.2.0/bin/pod:  23:in <code>&lt;main&gt;&#39;
    from /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in</code>eval’<br>    from /Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in `<main>‘<br> Build step ‘Execute shell’ marked build as failure</main></p>
</blockquote>
<p>子所以在构建项目时出现这个错误，是因为看到一篇文章(<a href="http://www.jianshu.com/p/d64f12577be8" target="_blank" rel="external">cocoapods插件GEM_PATH的配置</a>)，说是修改Xcode中CocoaPods插件的GEM_PATH:中的路径与SHELL PATH:中路径一致就能解决:</p>
<blockquote>
<p>env: ruby_executable_hooks: No such file or directory</p>
</blockquote>
<p>这个错误。于是就在~/.bash_profile文件中增加了一条GEM路径</p>
<blockquote>
<p>export GEM_PATH=”/Users/zyjk_imac-penghe/.rvm/gems/ruby-2.2.0/bin/pod”</p>
</blockquote>
<p>构建项目后就会报上面的错误，仔细看看，觉得是多了一条无效的执行路径导致的。于是，就删除了那条新添的GEM_PATH，再次构建就不报这个错误了。</p>
<h3 id="4-in-find-spec-for-exe’-can’t-find-gem-cocoapods-gt-0-a"><a href="#4-in-find-spec-for-exe’-can’t-find-gem-cocoapods-gt-0-a" class="headerlink" title="4. in `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a)"></a>4. in `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a)</h3><blockquote>
<p>in `find_spec_for_exe’: can’t find gem cocoapods (&gt;= 0.a) </p>
</blockquote>
<p>更新一下gem版本，终端命令如下；</p>
<blockquote>
<p>$ sudo gem update –system</p>
</blockquote>
<p>有时在输入命令后会出现ssh相关的网络错误提示，可以在终端输入命令:</p>
<blockquote>
<p>gem sources -a <a href="http://gems.ruby-china.org/" target="_blank" rel="external">http://gems.ruby-china.org/</a></p>
</blockquote>
<p>将源地址换为ruby-china。</p>
<h3 id="5-报xcodebuild-error-The-workspace-‘Project’-does-not-contain-a-scheme-named-‘Project’-的错误"><a href="#5-报xcodebuild-error-The-workspace-‘Project’-does-not-contain-a-scheme-named-‘Project’-的错误" class="headerlink" title="5. 报xcodebuild: error: The workspace ‘Project’ does not contain a scheme named ‘Project’.的错误"></a>5. 报xcodebuild: error: The workspace ‘Project’ does not contain a scheme named ‘Project’.的错误</h3><blockquote>
<p>Going to invoke xcodebuild:, scheme: Project, sdk: DEFAULT, workspace: Project, configuration: Debug, clean: YES, archive:NO, symRoot: DEFAULT, configurationBuildDir: /Users/ignat/.jenkins/workspace/Project/build, codeSignIdentity: DEFAULT<br>[Project] $ /usr/bin/xcodebuild -scheme Project -workspace Project.xcworkspace -configuration Debug clean build CONFIGURATION_BUILD_DIR=/Users/ignat/.jenkins/workspace/Project/build<br>Build settings from command line:<br>    CONFIGURATION_BUILD_DIR = /Users/ignat/.jenkins/workspace/Project/build</p>
<p>xcodebuild: error: The workspace ‘Project’ does not contain a scheme named ‘Project’.<br>FATAL: Build directory does not exist at /Users/ignat/.jenkins/workspace/Project/build. Potential configuration issue.<br>Build step ‘Xcode’ marked build as failure<br>Finished: FAILURE</p>
</blockquote>
<p>在Xcode中，选择Manage Scheme，勾选对应的<font color="ff6d55">Shared</font>。</p>
<h3 id="6-构建时报-NSLocalizedRecoverySuggestion-Add-a-profile-to-the-“provisioningProfiles”-dictionary-in-your-Export-Options-property-list"><a href="#6-构建时报-NSLocalizedRecoverySuggestion-Add-a-profile-to-the-“provisioningProfiles”-dictionary-in-your-Export-Options-property-list" class="headerlink" title="6. 构建时报 NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list."></a>6. 构建时报 NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list.</h3><blockquote>
<p>Error Domain=IDEProvisioningErrorDomain Code=9 “”BusinessMall.app” requires a provisioning profile with the Push Notifications feature.” UserInfo={NSLocalizedDescription=”BusinessMall.app” requires a provisioning profile with the Push Notifications feature., NSLocalizedRecoverySuggestion=Add a profile to the “provisioningProfiles” dictionary in your Export Options property list.}</p>
<p><strong> EXPORT FAILED </strong></p>
</blockquote>
<p>最后错误提示，<strong>EXPORT FAILED</strong>，可知是导出ipa包时出的错。根据提示”<strong>provisioningProfiles” dictionary in your Export Options property list.</strong>在网上搜了一下这个plist文件的用处，发现原来新版的<strong>Xcode 9</strong>将不会允许你访问钥匙串里的内容，除非设置<strong>allowProvisioningUpdates</strong>。</p>
<p>具体的<a href="http://www.jianshu.com/p/b3f883b51be3" target="_blank" rel="external">解决方式</a>是: 自己动手写脚本替代插件（插件本质是帮助我们生成打包脚本代码）。于是，在JenKins里，点击项目的”<strong>配置</strong>“选项，在”<strong>构建</strong>“中，添加xcodebuild -archivePath，<br>xcodebuild -exportArchive -archivePath的脚本命令，输出ipa包。如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration8.png" alt=""></p>
<p>具体的脚本命令如下:</p>
<pre><code>xcodebuild -archivePath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/output/debug/BusinessMall.xcarchive&quot; -workspace BusinessMall.xcworkspace -sdk iphoneos -scheme &quot;BusinessMall&quot; -configuration &quot;Release&quot; archive
xcodebuild -exportArchive -archivePath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/output/debug/BusinessMall.xcarchive&quot; -exportPath &quot;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/ipa/debug/&quot; -exportOptionsPlist &#39;/Users/zyjk_imac-penghe/.jenkins/workspace/BusinessMall/BusinessMall/ipa/debug/ExportOptions.plist&#39; -allowProvisioningUpdates
</code></pre><p>脚本中的构建路径为JenKins下对应的archivePath，ipa包的输出路径。其中，需要特别注意的是<font color="ff6d55">ExportOptions.plist</font>的存放路径。手写ExportOptions.plist文件过于麻烦，不如让XCode帮我们生成。使用XCode 9打包并导出后的文件夹里就有这样一份文件可以直接拿过来用。修改后的plist文件，如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/JenKins-Continuous-Integration9.png" alt=""></p>
<p>之后就在项目所在的目录下，新建一个名为ipa/debug/的目录，将修改后的<strong>ExportOptions.plist</strong>文件放在这个目录下。在Jenkins中使用SVN管理源码，因此，我需要将这个新增的文件上传SVN，这样在我每次构建项目，输出ipa时就能直接从SVN上拉取这个plist文件，通过设置<strong>ExportOptions.plist’ -allowProvisioningUpdates</strong>就能访问钥匙串中的打包证书，输出ipa包了。</p>
<p><font color="ff6d55">注意:</font>设置了<strong>allowProvisioningUpdates</strong>字段后，在打包过程中会弹出是否允许访问钥匙串内容的弹窗，这时需要多次点击“<strong>始终允许</strong>”按钮。</p>
<h3 id="7-构建时报error-exportArchive-The-data-couldn’t-be-read-because-it-isn’t-in-the-correct-format"><a href="#7-构建时报error-exportArchive-The-data-couldn’t-be-read-because-it-isn’t-in-the-correct-format" class="headerlink" title="7. 构建时报error: exportArchive: The data couldn’t be read because it isn’t in the correct format."></a>7. 构建时报error: exportArchive: The data couldn’t be read because it isn’t in the correct format.</h3><blockquote>
<p>error: exportArchive: The data couldn’t be read because it isn’t in the correct format.<br><strong> EXPORT FAILED </strong></p>
</blockquote>
<p>关掉bitcode重新打包就可以了……</p>
<p>参考<a href="https://forums.developer.apple.com/thread/21193" target="_blank" rel="external">https://forums.developer.apple.com/thread/21193</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>中间使用过命令:</p>
<blockquote>
<p>sudo gem install -n /usr/local/bin cocoapods –pre</p>
</blockquote>
<p>重装过CocoaPods，目前CocoaPods的版本为: <font color="ff6d55">1.4.0.beta.2</font>。也可以输入命令:</p>
<blockquote>
<p>$ sudo gem install cocoapods -v 0.39.0</p>
</blockquote>
<p>安装特定版本的CocoaPods。</p>
<p>由于给iOS项目构建版本时必须依赖于xcodebuild环境。现在是在一台Windows上部署Jenkins环境，可以配置节点，在另一台Mac电脑上打包。具体操作，可以参考这篇文章—<a href="http://blog.csdn.net/syg90178aw/article/details/52221765" target="_blank" rel="external">Jenkins自动打包 配置mac slave节点</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.w3cschool.cn/jenkins/" target="_blank" rel="external">w3cschool Jenkins</a></p>
<p><a href="https://stackoverflow.com/questions/26247926/how-to-solve-usr-bin-env-ruby-executable-hooks-no-such-file-or-directory" target="_blank" rel="external">How to solve “/usr/bin/env: ruby_executable_hooks: No such file or directory”?
</a></p>
<p><a href="https://github.com/openbakery/gradle-xcodePlugin/issues/308" target="_blank" rel="external">/usr/local/bin/pod No such file or directory</a></p>
<p><a href="https://stackoverflow.com/questions/2975206/how-to-delete-a-gem-path" target="_blank" rel="external">How to delete a gem path?</a></p>
<p><a href="https://coolestguidesontheplanet.com/add-shell-path-osx/" target="_blank" rel="external">What it is and How to Modify the Shell Path in macOS Sierra and OSX using Terminal</a></p>
<p><a href="http://www.jianshu.com/p/41ecb06ae95f" target="_blank" rel="external">手把手教你利用Jenkins持续集成iOS项目</a></p>
<p><a href="http://www.jianshu.com/p/d64f12577be8" target="_blank" rel="external">cocoapods插件GEM_PATH的配置</a></p>
<p><a href="http://blog.csdn.net/hong1595/article/details/74010620" target="_blank" rel="external">cocoaPods安装2017 以及遇到的坑</a></p>
<p><a href="https://stackoverflow.com/questions/25689967/xcodebuild-fails-in-jenkins-with-cocoapods" target="_blank" rel="external">Xcodebuild fails in jenkins with cocoapods
</a></p>
<p><a href="https://stackoverflow.com/questions/13500793/xcodebuild-commands-give-different-results-when-run-from-the-command-line-than-w" target="_blank" rel="external">xcodebuild commands give different results when run from the command line than when run from within Jenkins</a></p>
<p><a href="http://blog.csdn.net/syg90178aw/article/details/52221765" target="_blank" rel="external">Jenkins自动打包 配置mac slave节点</a></p>
<p><a href="http://www.jianshu.com/p/b3f883b51be3" target="_blank" rel="external">Jenkins+XCode9自动打包错误处理</a></p>
<p><a href="https://github.com/fastlane/fastlane/issues/9589" target="_blank" rel="external">xcode 9 beta export options not working #9589</a></p>
<p><a href="https://forums.developer.apple.com/thread/21193" target="_blank" rel="external">Xcode 7 Enterprise Distribution not working</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成(Continuous Integration，简称CI)是一种软件开发实践：许多团队频繁地集成他们的工作，每位成员通常进行日常集成，进而每天会有多种集成。每个集成会由自动的构建（包括测试）来尽可能快地检测错误。许多团队发现这种方法可以显著的减少集成问题并且可以使团
    
    </summary>
    
      <category term="解惑" scheme="http://XibHe.github.io/categories/%E8%A7%A3%E6%83%91/"/>
    
    
      <category term="持续化集成" scheme="http://XibHe.github.io/tags/%E6%8C%81%E7%BB%AD%E5%8C%96%E9%9B%86%E6%88%90/"/>
    
      <category term="JenKins" scheme="http://XibHe.github.io/tags/JenKins/"/>
    
  </entry>
  
  <entry>
    <title>直播那些事</title>
    <link href="http://XibHe.github.io/2017/10/31/live/"/>
    <id>http://XibHe.github.io/2017/10/31/live/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2017-11-13T08:45:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>直播技术经过近两年的迅速发展，已经很成熟了。从十月份开始接触与直播相关的技术，中间花了一周左右的时间，对市面上几种流行的三方直播SDK做了调研和对比。今天是月末最后一天，就做一个阶段性的总结吧！</p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>更新记录:</p>
<ul>
<li>2017 年 10 月，第一版。</li>
<li>2017 年 11 月 11 日，增加相关说明。</li>
<li>2017 年 11 月 13 日，增加直播原理。</li>
</ul>
<h2 id="直播原理"><a href="#直播原理" class="headerlink" title="直播原理"></a>直播原理</h2><h3 id="1-一个完整直播app实现流程"><a href="#1-一个完整直播app实现流程" class="headerlink" title="1. 一个完整直播app实现流程"></a>1. 一个完整直播app实现流程</h3><p>1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动</p>
<p><img src="http://upload-images.jianshu.io/upload_images/304825-5481594e6e2a9d56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="2-一个完整直播app架构"><a href="#2-一个完整直播app架构" class="headerlink" title="2. 一个完整直播app架构"></a>2. 一个完整直播app架构</h3><p><img src="http://upload-images.jianshu.io/upload_images/304825-54974199408c0cc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-一个完整直播app技术点"><a href="#3-一个完整直播app技术点" class="headerlink" title="3. 一个完整直播app技术点"></a>3. 一个完整直播app技术点</h3><p><img src="http://upload-images.jianshu.io/upload_images/304825-9b64e9596f3ccdce.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="4-流媒体相关参数"><a href="#4-流媒体相关参数" class="headerlink" title="4. 流媒体相关参数"></a>4. 流媒体相关参数</h3><p><strong>帧:</strong> 每帧代表一副静止的图像。</p>
<p><strong>帧率:</strong> 每秒显示的图片数。影响画面流畅度，与画面流畅度成正比:帧率越大，画面越流畅；帧率越小，画面越有跳动感。</p>
<p>由于人类眼睛的特殊生理结构，如果所看画面之帧率高于16的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。</p>
<p><strong>码率：</strong>图片进行压缩后每秒显示的数据量。</p>
<p><strong>分辨率：</strong>（矩形）图片的长度和宽度，即图片的尺寸<br>压缩前的每秒数据量: 帧率X分辨率(单位应该是若干个字节)<br>压缩比: 压缩前的每秒数据量/码率 （对于同一个视频源并采用同一种视频编码算法，则：压缩比越高，画面质量越差。）　</p>
<p><strong>视频文件格式：</strong>文件的后缀，比如.wmv,.mov,.mp4,.mp3,.avi,<br>主要用处，根据文件格式，系统会自动判断用什么软件打开,<br>注意: 随意修改文件格式，对文件的本身不会造成太大的影响，比如把avi改成mp4,文件还是avi.</p>
<p><strong>视频封装格式：</strong>一种储存视频信息的容器，流式封装可以有TS、FLV等，索引式的封装有MP4,MOV,AVI等，<br><strong>主要作用：</strong>一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、封装起来.<br>注意：会发现封装格式跟文件格式一样，因为一般视频文件格式的后缀名即采用相应的视频封装格式的名称,所以视频文件格式就是视频封装格式。</p>
<p><strong>视频封装格式和视频压缩编码标准：</strong>就好像项目工程和编程语言，封装格式就是一个项目的工程，视频编码方式就是编程语言，一个项目工程可以用不同语言开发。</p>
<h2 id="对比几种不同的直播SDK"><a href="#对比几种不同的直播SDK" class="headerlink" title="对比几种不同的直播SDK"></a>对比几种不同的直播SDK</h2><p>对比市面上常用的直播平台，这里分别是：阿里云、zego、七牛云、腾讯云。<br>这里根据业务需求，对比以上四个平台的指标为：支持的最大连麦上限，是否提供实时视频通话的解决方案，是否提供聊天室功能(IM)，可拓展性等。</p>
<h3 id="阿里云直播"><a href="#阿里云直播" class="headerlink" title="阿里云直播"></a><a href="https://www.aliyun.com/product/live?spm=5176.8413026.765261.324.1M5955" target="_blank" rel="external">阿里云直播</a></h3><p>阿里云直播中有提供连麦功能，但连麦上限最终确认4人（不能添加上限），不符合公司功能需求。视同阿里云提供的连麦demo，如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/live1.png" alt="1"><br>超过三个连麦观众时会提示：连麦观众不能超过3个。</p>
<p>在阿里云提交工单后，得到了最终的反馈，如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/live2.png" alt="2"></p>
<p>最后，联系了技术支持，连麦上限最终为4人。</p>
<h3 id="zego直播"><a href="#zego直播" class="headerlink" title="zego直播"></a><a href="https://www.zego.im" target="_blank" rel="external">zego直播</a></h3><p>zego直播中提供实时视频通话、连麦互动直播和即时通讯功能，实时视频场景的典型使用案例是同一房间内的成员（如微信群视屏），进行实时视频对话同一房间中的用户均可发起视频通话。连麦功能支持20个连麦观众。</p>
<p>提供了实时视频通话的解决方案，如图<br><img src="http://odchyrav4.bkt.clouddn.com/live3.png" alt="3"></p>
<h3 id="七牛云直播"><a href="#七牛云直播" class="headerlink" title="七牛云直播"></a><a href="https://www.qiniu.com/?hmsr=biaoti&amp;hmpl=pinzhuan&amp;hmcu=biaoti&amp;hmkw=&amp;hmci=" target="_blank" rel="external">七牛云直播</a></h3><p>七牛云提供强大的直播以及连麦服务，有提供强大的连麦功能，且无上限，受限于客户端的总体带宽，建议8路以下。</p>
<h3 id="腾讯云直播"><a href="#腾讯云直播" class="headerlink" title="腾讯云直播"></a><a href="https://cloud.tencent.com/product/LVB" target="_blank" rel="external">腾讯云直播</a></h3><p>腾讯云分为直播、互动直播、移动直播多种视频服务，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/live4.png" alt="4"></p>
<p>互动直播(ILVB)多对多连麦，最多支持8人同时连麦。移动直播(MLVB)提供即时通讯等一体化直播的解决方案，但最多同时支持3人连麦(见工单)。这二者都是在直播(LVB)基础之上做的延伸拓展。</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/live5.png" alt="5"></p>
<p>最后，对比以上四种直播，单从技术上考虑，zego以其一体化的解决方案，超出20路的连麦数，做工精良并频繁更新的Demo被重点考虑。从价格上考虑，阿里云和腾讯云的价格比较有优势。最后暂时选择了阿里云，原因可能是公司的云服务器用的是阿里云吧！</p>
<h2 id="关于demo"><a href="#关于demo" class="headerlink" title="关于demo"></a>关于demo</h2><p>该demo为整理后的阿里云直播连麦demo，添加了一些注释，为了突出直播所需的主功能，demo只集成直播所需的基本的API。通过对demo添加Tag，区别不同的功能。其中，Tag为<strong>V0.1</strong>的版本集成最基本的直播推拉流功能，Tag为<strong>V0.2</strong>的版本集成连麦功能。<a href="https://github.com/XibHe/AliyunLiveDemo" target="_blank" rel="external">点击下载链接</a></p>
<p><font color="ff6d55">注意:</font>阿里云的连麦demo中并未集成聊天室功能，在引入的SDK中，有一个名为<strong>AlivcLiveChatRoom.framework</strong>。该SDK暴露的AlivcLiveClient.h文件中，注明了聊天室相关的API，但创建聊天室和发送聊天消息的方法都加了__deprecated_msg的注释：</p>
<pre><code class="objectivec">- (void)createChatRoomWithName:(NSString *)chatRoomName success:(void(^)())successBlock error:(void (^)(NSError *error))errorBlock
__deprecated_msg(&quot;暂未开放,请勿使用,参考Demo与appServer交互&quot;);

- (AlivcLiveChatMessage *)sendMessage:(AlivcLiveConversationType)conversationType content:(NSString *)content success:(void (^)(long messageId))successBlock error:(void (^)(NSError *error, long messageId))errorBlock
__deprecated_msg(&quot;暂未开放,请勿使用,参考Demo与appServer交互&quot;);
</code></pre>
<p>在阿里云提交工单，工程师回复目前阿里云直播SDK不再提供聊天室功能了。不过通过阿里云DEMO接口文档中所列出的错误码，其中，有返回2040，2050的错误码，</p>
<blockquote>
<p>2040 创建环信聊天室失败</p>
<p>2050 消息发送到环信失败</p>
</blockquote>
<p>可见，阿里云聊天室之前是环信即时通讯方案，只是现在移除了。接口详情见:</p>
<p><a href="https://help.aliyun.com/document_detail/56125.html?spm=5176.doc55703.6.743.2DsJze" target="_blank" rel="external">DEMO接口文档</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这篇关于直播的文章写得很粗浅，只是记录了阿里云直播SDK的使用。没有详细系统的描述直播原理、主要直播技术及其实现。下面几篇文章对直播做了系统的介绍:</p>
<ul>
<li><a href="http://www.jianshu.com/p/ed9eb96afa78" target="_blank" rel="external">如何开发出一款仿映客直播APP项目实践篇 -【服务器搭建+推流】</a></li>
<li><a href="http://www.jianshu.com/p/b2674fc2ac35" target="_blank" rel="external">如何开发出一款仿映客直播APP项目实践篇 -【原理篇】</a></li>
<li><a href="http://www.jianshu.com/p/099c2c875524" target="_blank" rel="external">如何开发出一款仿映客直播APP项目实践篇 -【采集篇 】</a></li>
<li><a href="http://www.jianshu.com/p/f5a41b9ec05f" target="_blank" rel="external">如何开发出一款仿映客直播APP项目实践篇 -【播放篇】</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.jianshu.com/p/bd42bacbe4cc" target="_blank" rel="external">【如何快速的开发一个完整的iOS直播app】(原理篇)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直播技术经过近两年的迅速发展，已经很成熟了。从十月份开始接触与直播相关的技术，中间花了一周左右的时间，对市面上几种流行的三方直播SDK做了调研和对比。今天是月末最后一天，就做一个阶段性的总结吧！&lt;/p&gt;
&lt;h2 id=&quot;更新说明&quot;&gt;&lt;a href=&quot;#更新说明&quot; class
    
    </summary>
    
      <category term="Objective-C" scheme="http://XibHe.github.io/categories/Objective-C/"/>
    
    
      <category term="直播" scheme="http://XibHe.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>(译)为何许多开发者仍然喜欢用Objective-C，而不是Swift</title>
    <link href="http://XibHe.github.io/2017/10/10/SwiftUsageRate/"/>
    <id>http://XibHe.github.io/2017/10/10/SwiftUsageRate/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2017-10-14T02:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS SDK已经发布很多年了，开发人员纷纷涌向Objective-C，他们力图通过开发会大卖应用程序而获得丰厚的回报。但那样的时代如今已不复存在了：Swift已经面世三年多了，与Objective-C相比，大大地获取了大家的关注度。</p>
<p>Objective-C - 从应用程序开发世界冉冉升起的明星 - 沦为苹果生态系统中的二等公民。即使OC仍然会在WWDC的一两个板块中被提及，但世界各地的大部分会议都在谈论Swift，苹果正努力推动Swift在教育领域的应用，使用Swift作为主要的语言。</p>
<p>但是如果你仍然在使用Objective-C，你并不孤单 - 许多开发者仍然喜欢使用Objective-C相对于Swift，并且有很好的理由。我与一些Objective-C开发者联系，询问他们是否感觉继续使用Objective-C开发会受到指责，下面的内容就是他们不得不说的…</p>
<p>注意：这里表达的意见是个人意见，可能不代表雇主的意见; 人们按照他们回应的顺序列出; 一些回答在长度上进行了变更。</p>
<h2 id="阻止你将Swift作为开发语言的主要原因是什么？"><a href="#阻止你将Swift作为开发语言的主要原因是什么？" class="headerlink" title="阻止你将Swift作为开发语言的主要原因是什么？"></a>阻止你将Swift作为开发语言的主要原因是什么？</h2><p><strong>史蒂夫·特劳顿 - 史密斯</strong>：我有几个原因避免了Swift。 首先，我不喜欢使用它 - 我发现这个语言比ObjC更难阅读和解析，尤其是在循环和switch语句中的if-let变量赋值（这在Apple的体例中是混乱的，像ARKit一样)。我不是尝试各种不同语言为各种平台编写东西的新手，而且Swift绝对是我见到的可读性很低的语言。</p>
<p>我还不相信苹果参与设计这个语言的初衷 - 四年之后，Swift并不用于iOS，OS或框架的重要部分（我在Twitter上保留了苹果公司的Swift应用程序，macOS很少采用它的新特性相对于iOS来说)。我明白为什么会这样（ABI的稳定性等），但如果苹果没有使用Swift，我不明白为什么我需要代表他们进行beta测试。在Swift准备好之前，我没有什么期待，而且在此期间我获得了Objective-C所带来的一切好处。</p>
<blockquote>
<p>我完全相信，只是因为苹果建立了一些东西，并说这是前进的道路并不意味着它是正确的选择。</p>
</blockquote>
<p>有趣的是，在最初的几年中，我曾经听说过苹果与Swift的任何人分开，苹果公司当然是大量的ObjC开发人员，而Swift对于许多人来说，对我们来说是一个惊喜。 而且我完全相信，只是因为苹果建立了一些东西，并表示这是前进的道路并不意味着它是正确的选择 - 我们已经看到了一大堆错误（DNS 解析服务 discoveryd，iOS 7，iOS 8）或’mehs ‘（macOS，Touch Bar）在过去几年里，而且看到如何摆脱这些不好因素带来的负面影响。</p>
<p><strong>迈克尔·劳尔</strong>：我看不到激励。我在Objective-C方面非常有成效，我将语言视为非常优雅，简洁，富有表现力。如果Swift有一流的（异步）并发，我会高兴的跳起来。相比之下，我听说缓慢的编译时间，大量的运行时库重复，我还没有看到运行时性能的显着提升。</p>
<p><strong>丹·莱弗斯</strong>：对于技术原型预演Demo或非常小的项目，我将使用Objective-C，纯粹为了在经过相当长的时间（通常可能与这些类型的客户端）之后的易于更新。我还为许多客户保留了Objective-C应用程序，而且没有时间（或将其切换到Swift的理由）。在Swift中构建这样的项目的代码通常会把它当做演示原型的Demo来简单使用。</p>
<p><strong>彼得·莫尔纳尔</strong>：在3.0版本之前，我的主要障碍是缺少源代码兼容性，即使4.0之后，我还在等待ABI的稳定性。我认为这是剩下的唯一一个问题，如果源兼容性有效，我个人觉得这对我来说很重要。</p>
<p><strong>托德·托马斯</strong>：Xcode对Swift的支持似乎很好笑。从大型项目的愚蠢长编译时间到重构和调试。Tweetbot for Mac是一个相当可观的项目，在2012款的Retina MBP上编译它需要44秒。这包括1个框架，1个库和应用程序本身。此外，Swift的ABI仍然不稳定 - 当我不需要使用我的应用程序包含的所有库被全部缓慢的构建为应用时。</p>
<p><strong>伊恩·麦克道尔</strong>：我们有一大堆共享的C++代码，用于我们的业务逻辑，它与Windows和Android共享。我们在Objective-C中的本地UIKit/AppKit中编写我们的UI，并且有很多Objective-C++文件在两种语言之间桥接。至今，除了几个脚本和内部工具之外，我们还没有采用Swift。据使用Swift的其他团队说，编译时间比Objective-C / C ++慢。</p>
<p>我们有数百个Xcode项目，最终编译成一个巨大的静态库，链接到每个应用程序二进制文件。这样做可以减少应用启动时间。我们花费大概6小时流畅的构建我们的应用，不会增加很多时间。</p>
<p><strong>西蒙·沃尔夫</strong>：我的主要编码项目是一个客户端，它是一个已经发展了几年的大型代码库。虽然我也会引入一些Swift进去，因为我做的很多工作涉及到编辑现有的代码，它阻止我使用太多Swift。</p>
<p>我也意识到作为一个开发者，每次有一个新的主要版本的Swift的更新，我都会将那些工作中可以用到拿来用，但这不是我真正需要的。</p>
<p><strong>马科·阿门特</strong>：对我来说，这不是对Swift本身的判断，而是一个务实的决定：我已经是Objective-C的专家，在使用它方面极富生产力，而切换到Swift的好处并不足以说服我。</p>
<p><strong>马塞尔·维赫尔</strong>：我最多的工作包括一些复杂的元编程和 C 进行部分混合的objective - C的动态消息部分。在使用Swift后所有的这些都会变得更加困难，例如，你无法在Swift中编写CoreData。还很纠结：我只是试图找到一些用Swift编写的Apple Pencil示例代码。结果浪费了我一天时间。</p>
<h2 id="你有没有觉得开发人员可能会对使用Objective-C或者在社交媒体上谈论鄙视？"><a href="#你有没有觉得开发人员可能会对使用Objective-C或者在社交媒体上谈论鄙视？" class="headerlink" title="你有没有觉得开发人员可能会对使用Objective-C或者在社交媒体上谈论鄙视？"></a>你有没有觉得开发人员可能会对使用Objective-C或者在社交媒体上谈论鄙视？</h2><p><strong>史蒂夫·特劳顿 - 史密斯</strong>：真的吗？使用ObjC非常不受欢迎，或者说你喜欢ObjC 胜过 Swift。Swift有一个真正大规模的炒作人群，这个是你无法阻止的。</p>
<p>像任何充满激情的球迷一样，没有任何理由参与讨论。 Swift用户与我一样（或更多）了解其缺点，但是由于感知到的好处，他们很乐意做出妥协。我不是，也不觉得同样的好处。</p>
<p><strong>迈克尔·劳尔</strong>： 实际上。我觉得我一直在为自己对Objective-C的认同而保卫自己不受外界的干扰。</p>
<blockquote>
<p>我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。</p>
</blockquote>
<p><strong>丹·莱弗斯</strong>：当然，有一个新的和有光泽的驱动器。这最终有多少的iOS社区呢，所以它不是完全不足为奇，仍然存在很多争议。我相信艾米·沃洛尔在iOSDevUK上的关于Objective-C的演讲中，观众中有些动荡似乎是人们不理解造成的。</p>
<p><strong>彼得·莫尔纳尔</strong>：当我正在阅读职位和职位描述时，这种感觉更多，不一定在社交媒体上。大家现在正在寻找高级Swift开发人员。</p>
<p><strong>托德·托马斯</strong>：我并没有太多的担心。这个应该让应用程序自己来决定。如果它是好的，用户不会在乎它是用什么语言编写的。</p>
<p><strong>伊恩·麦克道尔</strong>：对于仍然使用Objective-C，我感觉到一些耻辱，但并不多。 我使用Swift为我的个人项目，并爱上它，并理解我们在工作中不使用它的原因。</p>
<p><strong>西蒙·沃尔夫</strong>：有一点，因为我不相信Swift是坏的，Objective-C是一个真正的Cocoa语言，我不会避免对Swift的利弊的热烈争论。我也没有看到人们对Objective-C开发人员太粗鲁，但作为Mac开发人员，我倾向于处于iOS社区的边缘，这可能是大多数冲突的地方。我不认为Mac开发人员很乐意使用最新最好的。我们还在争为NSCell争论(NSTableView中的NSCel)。</p>
<p><strong>马科·阿门特</strong>：这已经开始了，但是每个过渡都是这样发生的。Objective-C开发人员为Carbon开发人员开辟了乐趣。这只是一个自然的发展历程，每当你的语言不在当前考虑范围内的，只要你的语言不被视为“进步语言”。但是你仍然以务实的原因使用它。作为网络上的PHP开发人员，我习惯了这一点。</p>
<h2 id="当你看到开发者会议上大多数时间都在讨论Swift的使用时，你的感受是什么？"><a href="#当你看到开发者会议上大多数时间都在讨论Swift的使用时，你的感受是什么？" class="headerlink" title="当你看到开发者会议上大多数时间都在讨论Swift的使用时，你的感受是什么？"></a>当你看到开发者会议上大多数时间都在讨论Swift的使用时，你的感受是什么？</h2><p><strong>史蒂夫·特劳顿 - 史密斯</strong>：毫无感觉，一个只有Swift的会议是对我没有任何影响。在语言还未完善之前，以及苹果尚未大规模使用之前，我并不关心Swift最佳做法或设计模式。我不想整理十几个社区主导的设计模式，我等待苹果对于Swift的进一步完善。</p>
<blockquote>
<p>一个只有Swift的会议是对我没有任何影响。</p>
</blockquote>
<p>知道Swift是苹果发展的一个真正的“未来”，已经做了很多工作来推动我彻底远离应用程序; iOS 7 UI与Swift一对一转换的冲击让我觉得这不是我想要开发的平台。</p>
<p><strong>迈克尔·劳尔</strong>：这是可悲的。当然，我可以翻译我看到的一切，但比以前付出了更多的努力。而且我拒绝在任何要求使用Swift例子的会议上谈论它。幸运的是，还可以参加一些除了Swift之外的会议。</p>
<p><strong>丹·莱弗斯</strong>：至少他们大都一致！</p>
<p><strong>彼得·莫尔纳尔</strong>：我认为这是演变的一部分，但它是真实的 - 在Objective-C周围没有太多的吸引力。Swift是新的，由于它不断变化，有很多话要说，显然这些新的话题也在快速过时。</p>
<p><strong>托德·托马斯</strong>：我想如果你想要向前看，开发者会议应该谈论Swift。我不介意个人使用Swift，但也不要过度重视会议上对Swift的讨论。</p>
<p><strong>伊恩·麦克道尔</strong>：我感觉很好，这是未来！</p>
<p><strong>西蒙·沃尔夫</strong>：我不介意，我意识到Swift是新的闪亮的东西，因为我知道Swift足够好了解它，真的不用担心我。如果我把我的头埋在沙滩上，而不是继续学习Swift，那么我可能会被遗忘，然而我不认为这种做法有利于成为一个好的开发者。</p>
<p><strong>马尔科·阿门特</strong>：它不打扰我。大多数会议组织者和与会者都比我做得更紧密，所以当然应该使用Swift。将Swift代码片段从会议，教程和StackOverflow转换为Objective-C，只是继续使用Objective-C的成本之一，迄今尚未证明特别繁重的。 但随着时间的推移，这种转换负担会增加。</p>
<p><strong>马塞尔·维赫尔</strong>：我不得不承认，我发现很多Swift的讨论非常肤浅，经常因为不知情而被嘲笑，所以我感到失望。我知道这听起来很苛刻，而且有明显的例外，然而很仍然感到吃惊。</p>
<h2 id="你认为Swift的引入有助于或阻碍Objective-C作为一种语言的发展吗？"><a href="#你认为Swift的引入有助于或阻碍Objective-C作为一种语言的发展吗？" class="headerlink" title="你认为Swift的引入有助于或阻碍Objective-C作为一种语言的发展吗？"></a>你认为Swift的引入有助于或阻碍Objective-C作为一种语言的发展吗？</h2><p><strong>史蒂夫·特劳顿 - 史密斯</strong>：Swift对于Objective-C开发绝对是灾难性的; 对于任何新的API或功能，我不再具有示例代码，WWDC幻灯片，教程，GitHub或StackOverflow。无论StackOverflow千禧年的笑话，但是失去了对所有这些上下文和知识的访问是毁灭性的。在这方面，ObjC语言本身已经获得了一堆生活质量/语法糖功能，以帮助它更好地与Swift进行交互，所有这些都是梦幻般的。</p>
<blockquote>
<p>对于Objective-C开发，Swift绝对是灾难性的。</p>
</blockquote>
<p>我非常厌恶为了让Swift存活而使ObjC死去 - 如果两种语言可以彼此独立存在，对于像我这样的开发人员来说是非常好的，他们可以选择最适合手头任务的语言。Swift背后的激情，大规模的推广宣传，苹果停止为开发人员创建ObjC资源。</p>
<p><strong>迈克尔·劳尔</strong>：使用Swift的主要好处，“我们”要感谢轻量级泛型和可空性，但这是关于它的。如果背后有相同的人力投入，我只会希望Objective-C能获得Swift这样的好处。</p>
<p><strong>丹·莱弗斯</strong>：我认为这最初是有帮助的，但我现在强烈感觉到，这样的做法有些舍本逐末了。</p>
<p><strong>托德·托马斯</strong>：我认为这有帮助。他们为Swift的语言添加了许多有用的东西，所以我们不能抱怨。</p>
<p><strong>伊恩·麦克道尔</strong>：Objective-C已经从Swift获得了一些很好的功能，包括<font color="#C52950"><code>@available</code></font>语法和可空性说明符。这是一种稳定的语言，我没有想到它会改变任何事情。</p>
<blockquote>
<p>在Swift中打包可能是一个痛苦，但它帮助我在Objective-C中采用更好的打包方式。</p>
</blockquote>
<p><strong>西蒙·沃尔夫</strong>：对于Swift导致的结果，Objective-C有一些变化和改进，这是有帮助的。另外，写一点Swift也鼓励我去看看我的Objective-C代码是否完美，而且我不太愿意让空对象去操作底层的一些东西。在Swift中打包可能是一个痛苦，但它帮助我在Objective-C中采用更好的打包方式。</p>
<p><strong>马尔科·阿门特</strong>：Swift已经有效地停止了Objective-C作为一种语言的开发。 这并不奇怪或不合理，但幸运的是Objective-C相当成熟。前几年Swift的引入带来了许多改进，应该保持Objective-C可用，直到我们大部分人都转移到Swift。</p>
<p><strong>马塞尔·维赫尔</strong>：显然受到阻碍，即使Objective-C很好，但Swift的出现结束了Objective-C进一步的发展！</p>
<p>更令人惊奇和不安的是，一些首选Swift作为语言编写的三方库中有很多明显的缺陷。<br>一些对Swift的改进被阻止，以使Swift看起来不错，虽然我很确定这不是怎么回事。</p>
<p>然而，最大的负面影响就是那些可能阻止Swift后续发展的一系列做法。我们正在尽我们所能创造一种脱离控制的Swift，而苹果忽略了所有这一切。这是一个犯罪。</p>
<h2 id="你怎么看？"><a href="#你怎么看？" class="headerlink" title="你怎么看？"></a>你怎么看？</h2><p>除了上述所有问题，我还问到人们使用Objective-C已经有多长时间了，因为我认为公平地说，在精通一门语言后，选择继续使用或这彻底放弃时总是很重要。</p>
<p>听到大多数人说他们在iPhone SDK第一次启用或不久之后立即使用Objective-C，几个人已经使用了十多年，其中一个人27了——是的,27岁。我应该补充说，一位回应者表示他们最近开始使用Objective-C，所以也许还存在一些固执的人。</p>
<p>另外还有一件事：去年，我写了一本名为<a href="https://www.hackingwithswift.com/store/objective-c-for-swift-developers" target="_blank" rel="external">Objective-C for Swift Developers</a>的书，在介绍中，我介绍了一个题为“我喜欢Objective-C”的部分，这里是我写的一些话：</p>
<p>当我阅读本书的第一本完整的草稿时，我想到了自己，“哇，这看起来像是Snark的Objective-C指南”，因为几乎每一章都觉得是在抱怨。</p>
<p>结果，我花了一些时间来编辑这本书，让它更加完美 - 不是因为我试图用人造光线向你呈现东西，而是因为我真的很喜欢用Objective-C编码。在Apple发布Swift时，我就开始使用Swift了，并且在早期就发布了一款Swift应用程序到App Store上。因此，在许多方面，和Swift相比Objective-C只是看起来很糟糕，我已经使用Swift很长时间了，再次使用Objective-C感觉有点像从长期生活的大城市回到老家过圣诞节一样。</p>
<p>我不知道我是否喜欢Objective-C，因为我有斯德哥尔摩综合症，或者是因为苹果的API是如此强大。无论如何，我认为重要的是你意识到，一些令人惊奇的软件已经与Objective-C一起构建，许多人始终如一的爱着她。</p>
<p>当你在这本书中发现让你感到沮丧的事情时，你要温柔一点：这是一种古老的语言，经历了坎坷的发展历程。它为我们提供了很好的服务。至少，在它慢慢远离人们视线时应该被尊重!</p>
<p><strong>谢谢Steve 史蒂夫·特劳顿 - 史密斯，迈克尔·劳尔，丹·莱弗斯，彼得·莫尔纳尔，托德·托马斯，伊恩·麦克道尔，西蒙·沃尔夫，马尔科·阿门特，以及马塞尔·维赫尔，花时间对这篇文章发表观点。</strong></p>
<p>现在结束了 - 如果你仍然喜欢在Swift上使用Objective-C，可以在<a href="https://twitter.com/twostraws" target="_blank" rel="external">Twitter</a>上联系我！</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://www.hackingwithswift.com/articles/27/why-many-developers-still-prefer-objective-c-to-swift?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios" target="_blank" rel="external">Why many developers still prefer Objective-C to Swift</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS SDK已经发布很多年了，开发人员纷纷涌向Objective-C，他们力图通过开发会大卖应用程序而获得丰厚的回报。但那样的时代如今已不复存在了：Swift已经面世三年多了，与Objective-C相比，大大地获取了大家的关注度。&lt;/p&gt;
&lt;p&gt;Objective-C 
    
    </summary>
    
      <category term="译文" scheme="http://XibHe.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="译文" scheme="http://XibHe.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Swift" scheme="http://XibHe.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发总结</title>
    <link href="http://XibHe.github.io/2017/09/25/wx-mini-AppSummary/"/>
    <id>http://XibHe.github.io/2017/09/25/wx-mini-AppSummary/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2017-10-14T02:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序开发结束已经两天了，这是第一个我参与的小程序项目。回顾开发过程中踩过的种种坑，剖析项目中的痛点，需要优化的地方。以后如何避免这样的问题？是否从此入坑H5了？自己的知识短板是什么？</p>
<p>之前一直从事iOS开发，对web前端没有过多了解。单凭一腔热血去开发小程序，初识比较迷茫，纠结于html和css的样式，js的数据交互等基础知识。但项目周期短，任务重，需要与pc，平板进行数据同步。就没有太多时间去理会前端基础知识，都是现学现用。</p>
<p>就是产品有些坑，设计的小程序产品原型还是是基于原生App的思维。因此，设计出的UI效果图，页面数据展示效果多数是原生App的效果，有些设计甚至与小程序组件相悖。为了实现与UI设计一致的效果，就需要花费很多时间自定义数据交互组件。</p>
<p>开发时没有完全吃透小程序开发文档，在实现某个功能时一直拿不定主意。以下是踩过的一些坑:</p>
<ul>
<li>小程序页面路径只能是五层，请尽量避免多层级的交互方式。</li>
<li>页面之间传递数据和变量的方式需要统一，不统一传参方式，一旦出现数据展示问题，会增加调试的难度。</li>
<li>一定要将多次调用的功能或样式封装起来，否则，重复相同功能代码会增加.js文件的代码量，使代码不易读。</li>
<li>使用swiper滑块视图容器时，一定要将滑块控制的页面抽离成单独的页面，放在一个页面中，当处理不同页面的数据交互时，会对其他不相干的页面数据造成干扰。</li>
<li>读取页面定义的变量时，不要忘记使用that关键字，把this对象复制到临时变量that，否则会找不到原来的对象。</li>
<li>wx.showToast吐司，当title文字超出限制，不会自适应宽高，需要自定义弹出框。</li>
<li>注意navigator 组件的几种跳转方式的不同之处。</li>
<li>小程序变量不支持下划线命名，若使用下划线命名会造成变量无法赋值。</li>
<li>避免快速点击，多次触发bindtap事件，造成打开多个相同页面。</li>
</ul>
<p>小程序写着还是很纠结的，这是内心的真实想法:</p>
<blockquote>
<p>一定是上辈子缺德事干多了，这辈子才会被安排写小程序！</p>
</blockquote>
<p>通过这次开发小程序的机会，发现了自己的知识短板，正是这些短板让自己裹足不前。以下是短板高发区:</p>
<ul>
<li>在哪些工作上花费时间最多?</li>
<li>可以改进的重复性劳动</li>
<li>自己没有完全理解的东西</li>
<li>你回答不出来的面试题</li>
</ul>
<p>对比以上几点快速找出你的技术短板，然后消除它。你必须要确切知道自己需要学什么，保证焦点正确。不要让这些短板成为你的“痛点”。</p>
<p>我是否陷入了对技术的狂热之中？因为崇拜某项特定的技术，只是因为自己熟悉这种技术。我很自然的会相信自己选择的是最好的，然后这会让我经常忽略一些与之相悖的意见。由于不了解其他技术，就倾向于选择自己最熟悉的技术并先入为主的认为它是最好的。</p>
<blockquote>
<p>人生多艰，无暇他顾。</p>
</blockquote>
<p>于是我局限在自己的世界中，变得自以为是，固步自封，墨守成规。自以为找到所有答案，却只是裹足不前。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序开发结束已经两天了，这是第一个我参与的小程序项目。回顾开发过程中踩过的种种坑，剖析项目中的痛点，需要优化的地方。以后如何避免这样的问题？是否从此入坑H5了？自己的知识短板是什么？&lt;/p&gt;
&lt;p&gt;之前一直从事iOS开发，对web前端没有过多了解。单凭一腔热血去开发小程序
    
    </summary>
    
      <category term="JavaScript" scheme="http://XibHe.github.io/categories/JavaScript/"/>
    
    
      <category term="小程序" scheme="http://XibHe.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="总结" scheme="http://XibHe.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>小程序页面跳转</title>
    <link href="http://XibHe.github.io/2017/09/16/wx.navigateTo/"/>
    <id>http://XibHe.github.io/2017/09/16/wx.navigateTo/</id>
    <published>2017-09-15T16:00:00.000Z</published>
    <updated>2017-10-14T02:44:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序页面跳转API时需要注意，官方文档中强调：“为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。” 也就是说在连续使用navigateTo进行页面跳转时，若当前页面若正好是第5级，则点击该页面任何绑定触发事件的控件，都不会有任何反应。</p>
<h1 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h1><p>更新记录:</p>
<ul>
<li>2017 年 9 月，第一版。</li>
<li>2017 年 10 月，增加页面跳转流程图及跳转说明。</li>
</ul>
<h2 id="小程序中页面导航的API"><a href="#小程序中页面导航的API" class="headerlink" title="小程序中页面导航的API"></a>小程序中页面导航的API</h2><p>为了避免发生超过五级页面而无法跳转的悲剧，首先要了解清楚小程序中页面导航的API。小程序中页面导航API有五个，两个跳转新页面的API分别为wx.navigateTo和wx.redirectTo，一个用来做重置操作的API为wx.reLaunch，一个用于跳转到tabBar的API为wx.switchTab，还有一个API名为wx.navigateBack，用于返回页面。</p>
<p><strong>wx.navigateBack 在小程序的初始版本中只能回到上一个页面，在最新版本的更新中给 navigateBack 添加了一个参数 delta，用于决定需要返回几层页面，返回的页面数，如果delta大于现有页面数，则返回首页。</strong></p>
<h2 id="几种跳转方式的不同之处"><a href="#几种跳转方式的不同之处" class="headerlink" title="几种跳转方式的不同之处"></a>几种跳转方式的不同之处</h2><p>navigator 组件的默认跳转方式与 wx.navigateTo 相同，而如果添加 redirect 属性，则与 wx.redirectTo 的跳转方式相同。</p>
<p>navigateTo 在官方文档中描述如下：</p>
<blockquote>
<p>保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面。</p>
</blockquote>
<p>通过 navigateTo 跳转后，可点击左上角的按钮返回上一个页面。而如果多次调用 navigateTo 之后，就需要返回多次才能回到初始页面。因此，官方在此处有一个限制。</p>
<blockquote>
<p>注意：为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。</p>
</blockquote>
<p>不过上述五层的限制只是针对 navigateTo，redirectTo 则无此限制。因为 redirectTo 的行为是：</p>
<blockquote>
<p>关闭当前页面，跳转到应用内的某个页面。</p>
</blockquote>
<p><font color="#FA8072">注意:</font> 使用redirectTo跳转到一个之前加载过的页面，不会再次调用该页面的onLoad方法。</p>
<p>通过 redirectTo 跳转后，则无法返回跳转前的页面。但并不是无法调用 navigateBack，而是调用之后，会回到使用 redirectTo 跳转前的上一个页面。</p>
<p>页面栈可以通过 getCurrentPages 方法获取：</p>
<blockquote>
<p>getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。</p>
</blockquote>
<p>上述的「页面路径」可以对应为页面栈中的元素，页面栈中的最后一个元素就是当前显示的页面，页面跳转就是新页面入栈的过程。</p>
<p>上述三种页面 API 的区别在于：</p>
<ul>
<li>navigateTo 不会将旧页面出栈；</li>
<li>redirectTo 会将旧页面出栈，再将需要跳转到的页面入栈；</li>
<li>navigateBack 则是将页面栈最后一个元素出栈，因此倒数第二个元素会成为最后一个元素，即变成「当前页面」。</li>
</ul>
<p>结合下面这个例子，如图，</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/wxnavigateTo_flow.png" alt="跳转流程"></p>
<p>小程序包含 A、B、C、D 四个页面，A 页面为首页。小程序启动后，在 A 页面中，我们通过 navigateTo 跳转到 B 页面，然后在 B 页面中再通过 navigateTo 跳转到 C 页面。</p>
<p>如果通过navigateTo跳转到 D 页面，则在D页面调用navigateBack会返回到C页面；<br>如果通过redirectTo跳转到 D 页面，则在D页面调用navigateBack会发现不是返回C 页面，而是返回到了 B 页面。</p>
<p>因为调用redirectTo 跳转到 D 页面，redirectTo 会将当前页面出栈，即将 C 页面出栈，再将 D 页面入栈，这时候，页面栈中的元素则会变为 A、B、D。</p>
<ul>
<li>navigateTo 不会将旧页面出栈，因此通过 navigateTo 跳转后，页面栈中元素个数会加一，因此在页面栈中元素个数达到 5 之后再调用 navigateTo 会失败，出现无法跳转的错误。</li>
<li>redirectTo 会在将旧页面出栈后，再将新页面入栈，因此通过 redirectTo 跳转，页面栈中元素个数会保持不变，所以即使在页面栈中元素达到 5 个之后再调用 redirectTo 也能成功跳转。</li>
</ul>
<h2 id="实际业务流程"><a href="#实际业务流程" class="headerlink" title="实际业务流程"></a>实际业务流程</h2><p>业务流程:<br>点击主页面的“扫码录入”按钮，页面跳转微信扫一扫页面，通过扫描条形码读取商品信息，若扫码到该商品信息存在数据库中，则获取数据库中的信息并将这些商品信息带至至“商品信息”页面，可以在商品信息页面对商品信息进行编辑。编辑结束后，点击商品信息页面底部的保存按钮，保存该条商品的最新信息。</p>
<p>为了在点击页面底部的“保存”按钮后直接跳转至微信扫一扫页面，达到快速扫码录入商品信息的目的。解决方案:</p>
<blockquote>
<ol>
<li>直接返回主界面，点击“扫码录入”按钮，跳转至微信扫一扫页面；</li>
<li>点击底部“保存”按钮后，立即调用wx.scanCode打开扫一扫页面；</li>
</ol>
</blockquote>
<p>方案1直接被否定了，原因是用户会频繁调用扫一扫进行商品信息的录入。如果在用户录入一天商品信息后，返回到主页面，再一次点击“扫码录入”按钮跳转至扫一扫页面进行商品录入或查询。会使得录入这一操作的连续性被打断，降低录入操作整体流畅度。</p>
<p>方案2在点击保存按钮后直接打开扫一扫固然可以保证操作的连贯性，但此时若在扫一扫页面不做扫码操作，而是点击扫一扫左上角的返回按钮，则返回到上个页面—商品信息保存页面。此时，如果点击“保存”按钮会对商品信息进行重复保存。</p>
<p>那么，能否在微信扫一扫页面做相应处理呢？比如，点击扫一扫左上角的返回按钮时，直接返回到首页。由于扫一扫页面是直接调用wx.scanCode而来的，其并不是以压栈的方式出现在页面控制的层级中。因此，无法通过getCurrentPages()函数获取对应的层级关系。</p>
<p>另外一种方式，针对方案2的问题，需要在点击“商品信息”页的“保存”按钮后做出特别处理，于是在点击保存绑定的事件中设置:</p>
<pre><code class="js">saveTap: function (res) {
   wx.request({
      url: requestUrl.LookForGoodsUrl
      data: {
        &quot;userId&quot;: userId,
        &quot;goodsId&quot;: numResult,
        &quot;name&quot;: name,
        &quot;factory&quot;: factory,
      },
      header: {
        &#39;content-type&#39;: &#39;application/json&#39;
      },
      success: function (res) {
        if (res.data.code == &#39;0000&#39;) {
            // 保存成功
           wx.redirectTo({
              url: &#39;../homePage/homePage&#39;
           })
        }  
      }
   })
}
</code></pre>
<p>将最新商品信息上传至服务器，关闭当前页面，跳转到应用内的某个页面。再调用:</p>
<pre><code class="js">wx.scanCode({
  var numResult = res.result;
  if (numResult.substring(0, 2) == &#39;69&#39;) {
     wx.request({
        url: requestUrl.LookForGoodsUrl
        data: {
           &quot;userId&quot;: userId,
           &quot;goodsId&quot;: numResult,
         },
        header: {
           &#39;content-type&#39;: &#39;application/json&#39;
        },
        success: function (res) {
            if (res.data.state == &#39;1&#39;) {
               // 存在该商品
               wx.redirectTo({
                   url: &#39;../goodsInfo/goodsInfo?goodsChart=&#39; + goodsChart + &#39;&amp;goodsId=&#39; + goodsId,
               })
            }
        }
     })
  }
})
</code></pre>
<p>调用扫一扫，获取商品条码，将获取的条码作为参数上传服务器得到服务器返回的商品信息。再将这些信息传递并跳转至“商品信息”页，展示这些信息。再次扫描商品条码时，重复以上操作。</p>
<p>但是为了在商品信息页面点击“保存”按钮时关闭当前页面，使用了wx.redirectTo，会先返回到首页（homePage），然后再调出扫一扫页面。这期间会出现短暂（大概2~3秒钟）的停顿，停顿期间页面(homePage)仍然可以操作，会误触页面上的其他点击事件。最后，即使在该页面(homePage)加上loading，以防止误触。仍然无法回避短暂停顿后再跳转扫一扫页面的问题。</p>
<p>最后的解决方案是: 点击商品信息页的“保存”按钮后，将该按钮隐藏。这样当从扫一扫页面返回商品信息页时就不会出现重复保存数据的问题了。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序页面跳转API时需要注意，官方文档中强调：“为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。” 也就是说在连续使用navigateTo进行页面跳转时，若当前页面若正好是第5级，则点击该页面任何绑定触发事件的控件，都不会有
    
    </summary>
    
      <category term="JavaScript" scheme="http://XibHe.github.io/categories/JavaScript/"/>
    
    
      <category term="小程序" scheme="http://XibHe.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="wx.navigateTo" scheme="http://XibHe.github.io/tags/wx-navigateTo/"/>
    
  </entry>
  
  <entry>
    <title>爱之初体验 - 小程序</title>
    <link href="http://XibHe.github.io/2017/09/01/wx-mini-AppBlindDate/"/>
    <id>http://XibHe.github.io/2017/09/01/wx-mini-AppBlindDate/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2017-10-14T02:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发小程序已经有两周了，从最开始踌躇满志到现在喜忧参半。这中间经历了许多波折，好像又回到了第一次初恋时的感觉，迫切，含蓄，喜悦，又苦于不能迅速了解对方的方方面面，而感到沮丧。但随着一步步的接触，由浅入深，终会瓜熟蒂落，水到渠成。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>小程序由视图层，逻辑层，渲染层三部分组成的一整套框架。框架使用自己的视图层描述语言WXML(.WXML文件中使用的是view标签构建视图，相当于CSS中的div标签。)和WXSS，逻辑层是基于JavaScript框架。视图层和逻辑层间微信提供了用于数据交互，事件绑定的丰富组件和API。</p>
<p>框架的核心是一个响应的数据绑定系统。整个系统分为两块: 视图层(View) 和逻辑层(App Service)。框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会发生相应的更新。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。什么是组件: </p>
<ul>
<li>组件是视图层的基本组成单元。</li>
<li>组件自带一些功能与微信风格的样式。</li>
<li>一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。</li>
</ul>
<p>但使用起来还是有些不足，很多组件的风格与微信风格类似，不想使用这种风格的组件就需要自定义组件，而自定义需要花费一些额外的时间，就算自定义成功了，仍需要经过仔细的测试，确保该自定义组件在交互上不会与基础组件产生偏差。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>框架提供了丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<p>说明：</p>
<ul>
<li>wx.on 开头的 API 是监听某个事件发生的API接口，接受一个 CALLBACK 函数作 为参数。当该事件触发时，会调用 CALLBACK 函数。</li>
<li>如未特殊约定，其他 API 接口都接受一个OBJECT作为参数。</li>
<li>OBJECT中可以指定success, fail, complete来接收接口调用结果。<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1></li>
</ul>
<p><img src="http://odchyrav4.bkt.clouddn.com/wx-mini-AppPits_IDE.png" alt="IDE"></p>
<p>在原有的公众号网页调试工具的基础上，推出了全新的微信开发者工具，集成了公众号网页调试和小程序调试两种开发模式。</p>
<p>在8月30日和8月31日，对开发工具进行了很大的<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html" target="_blank" rel="external">更新</a>。全新的视觉和交互体验，新增了申请<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/monkey-test.html" target="_blank" rel="external">测试报告</a>功能，新增<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxs/" target="_blank" rel="external">WXS</a>功能。</p>
<h1 id="开发中填的坑"><a href="#开发中填的坑" class="headerlink" title="开发中填的坑"></a>开发中填的坑</h1><p><a href="https://github.com/XibHe/WXAppPits" target="_blank" rel="external">微信小程序填坑记录</a><br>希望对你有帮助。</p>
<h1 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h1><blockquote>
<p>多看官方文档，多看几遍，遇到问题时再看，没有问题时继续看；</p>
<p>关注<a href="http://www.wxapp-union.com" target="_blank" rel="external">论坛</a>最新动态； </p>
<p>基础知识一定要过关（小程序的框架，组成部分，运行机制，自身限制）；</p>
<p>不要眼高手低，人家的demo下载下来跑起来，看懂之后一定要自己尝试写一遍；</p>
<p>找一个自己熟悉的逻辑，开始模仿（结合实际的项目需求，一步一步解决遇到的问题）。</p>
</blockquote>
<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>模态窗体上的textarea多行输入框，当滑动整个页面时，会将textarea里输入的内容一起滑动至输入框外部，随着滑动的方向一起滑动。官方文档中备注了关于textarea的一个tip:</p>
<blockquote>
<p>textarea组件是由客户端创建的原生组件，它的层级是最高的。</p>
</blockquote>
<p>或许正是由于textarea是最高层级导致的滑动问题。</p>
<h1 id="demo下载"><a href="#demo下载" class="headerlink" title="demo下载"></a>demo下载</h1><p><a href="https://github.com/XibHe/wxModeList" target="_blank" rel="external">wxModeList</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="external">微信公众平台 | 小程序</a></p>
<p><a href="http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1509" target="_blank" rel="external">小程序中的循环列表，在点击时改变当前项的背景颜色</a></p>
<p><a href="http://www.mntuku.cn/index.php/article/show/id-7141" target="_blank" rel="external">小程序操作按钮悬浮固定在底部</a></p>
<p><a href="http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1261" target="_blank" rel="external">动态的显示或隐藏控件</a></p>
<p><a href="http://www.jianshu.com/p/aa8254b23847" target="_blank" rel="external">微信小程序从子页面退回父页面时的数据传递</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发小程序已经有两周了，从最开始踌躇满志到现在喜忧参半。这中间经历了许多波折，好像又回到了第一次初恋时的感觉，迫切，含蓄，喜悦，又苦于不能迅速了解对方的方方面面，而感到沮丧。但随着一步步的接触，由浅入深，终会瓜熟蒂落，水到渠成。&lt;/p&gt;
&lt;h1 id=&quot;框架&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="JavaScript" scheme="http://XibHe.github.io/categories/JavaScript/"/>
    
    
      <category term="小程序" scheme="http://XibHe.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="初体验" scheme="http://XibHe.github.io/tags/%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>二次筛选功能开发心得</title>
    <link href="http://XibHe.github.io/2017/08/23/FilterError/"/>
    <id>http://XibHe.github.io/2017/08/23/FilterError/</id>
    <published>2017-08-22T16:00:00.000Z</published>
    <updated>2017-10-14T02:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个类似于京东搜索结果页的筛选功能，侧边栏条件筛选器，根据不同的数据类型进行条件筛选及筛选条件的排列展示。</p>
<h1 id="构建原理及使用到的技术点"><a href="#构建原理及使用到的技术点" class="headerlink" title="构建原理及使用到的技术点"></a>构建原理及使用到的技术点</h1><blockquote>
<p>RunTime<br>继承<br>组合</p>
</blockquote>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><blockquote>
<p>筛选列表距离顶部状态栏距离过近<br>筛选列表展示<br>选中数量限制<br>替换二次筛选结果页数据源<br>循环移除数组元素报错<br>在筛选更多，跳转的搜索页面进行搜索调用两次接口请求</p>
</blockquote>
<h1 id="解决的方式"><a href="#解决的方式" class="headerlink" title="解决的方式"></a>解决的方式</h1><h2 id="替换二次筛选结果页数据源"><a href="#替换二次筛选结果页数据源" class="headerlink" title="替换二次筛选结果页数据源"></a>替换二次筛选结果页数据源</h2><p>需求中要求替换筛选条件的数据源,表述如下:</p>
<blockquote>
<p>选中的选项需要在二次筛选条件选择页中显示，选中的选项为默认展开的选项时，无需变更选项的位置，若选中的不是默认展开的选项，需要将选中的选项放到二次筛选条件选择页中，并代替筛选条件选择页中没被选择的默认展开的选项的位置，按照选中的时间顺序正序占据页面中的默认展开的选项的位置（举例说明：筛选条件选择页中的默认展开的选项是1、2、3、4、5，默认展开的选项选中的是2和4,然后用户点击查看更多的选项，先选了11然后又选了9的选项,根据逻辑，筛选条件选择页中显示的选项依次显示的是：11、2、9、4、5），若选中的选项被取消选择，选项的位置按照选中时的位置显示，不更改选项的位置。</p>
</blockquote>
<p>如图，二次筛选结果页和生产厂家搜索列表页</p>
<center><br>    <img src="http://odchyrav4.bkt.clouddn.com/filterError_1.PNG?imageView/4/w/300"><br>    <img src="http://odchyrav4.bkt.clouddn.com/filterError_2.PNG?imageView/4/w/300"><br></center>

<p>当生产厂家筛选数据源大于6项时，只展示5个生产厂家，并显示“更多生产厂家 &gt;”的跳转提示。点击跳转至生产厂家搜索列表页面，在搜索页面会根据搜索关键字展示所有的生产厂家列表信息。该列表会展示上个页面勾选的生产厂家，并将其置于列表最前面。现在需要做的是: <font color="#DC143C">当勾选列表页中一个或多个生产厂家，该生产厂家是二次筛选结果页(上一个页面)中，默认展示5个生产厂家中从未出现的一个，是一个新的生产厂家。则需要替换掉二次筛选结果页，生产厂家一栏中未被勾选的一个或多个生产厂家，直到全部替换完成。</font></p>
<blockquote>
<p>方案一: 进行多层嵌套循环遍历，判断如果对象的selected属性为YES，则跳出当前循环并做一个标记，再从新进行外层循环。这样就需要设置至少两个以上的标记在循环遍历的基础之上再进行循环遍历。增加了逻辑判断的复杂性，也使代码变得不易读。</p>
</blockquote>
<p>针对方案一不足之处，将方案一中的杂糅在一起的逻辑判断抽离成不同的情况，形成方案二。</p>
<blockquote>
<p>方案二: 需要定义两个可变数组，_dataList(二次筛选结果页，生产厂家数据源)，_selectList(生产厂家搜索页，所有勾选的生产厂家数据源)。对二者进行嵌套循环遍历，需要考录到三种不同情况，并对这三种情况进行一一判断。<br>① _dataList全部包含了_selectList中的元素；<br>② _dataList不包含_selectList中的元素；<br>③ _dataList包含部分_selectList中的元素。</p>
</blockquote>
<p>针对以上三种情况对应的具体步骤: </p>
<ul>
<li>① 遍历找到_dataList中的_selectList元素，变更生产厂家Model中selected状态，将这些选中的元素放到_dataList中元素位置的最前面；</li>
<li>② 直接将_selectList插入到_dataList的最前面；</li>
<li>③ 先替换，再插入新元素到_dataList中，最后再将生产厂家Model中selected为YES的元素前置到_dataList的最前面位置。</li>
</ul>
<p>方案二仍需要进行大量的判断，操作起来仍旧复杂。那么，有没有简单粗暴，提刀就干的方案呢？下面就要说说方案三了。</p>
<blockquote>
<p>方案三: 在生产厂家搜索列表页面直接进行操作。在二次筛选结果页点击跳转至生产厂家搜索页时，传入已经选中生产厂家的数组_selectList，生产厂家搜索结果列表页的数据源_datalist(包含当前已选中生产厂家的数组_selectList和所有未选中的生产厂家)。点击”确定“按钮时，去除_datalist中已选中的生产厂家的Model，然后使用block反向将去除后的_datalist和_selectList传给二次筛选结果页。</p>
</blockquote>
<p>这样在二次筛选结果页就能直接操作已经处理过的筛选数据了，不用再进行复杂的逻辑判断了。总的来说，这种替换原有页面数据源的操作，以后还是在可以对数据源进行修改的页面进行处理，避免最后需要进行复杂的逻辑判断。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://github.com/liuzhiyi1992/ZYSideSlipFilter" target="_blank" rel="external">ZYSideSlipFilter</a></p>
<p><a href="https://stackoverflow.com/questions/8834031/objective-c-nsmutablearray-mutated-while-being-enumerated" target="_blank" rel="external">Objective-C NSMutableArray mutated while being enumerated?
</a></p>
<p><a href="https://stackoverflow.com/questions/32865704/collection-nsarraym-0x7fa1f2711910-was-mutated-while-being-enumerated" target="_blank" rel="external">Collection <__nsarraym: 0x7fa1f2711910=""> was mutated while being enumerated
</__nsarraym:></a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个类似于京东搜索结果页的筛选功能，侧边栏条件筛选器，根据不同的数据类型进行条件筛选及筛选条件的排列展示。&lt;/p&gt;
&lt;h1 id=&quot;构建原理及使用到的技术点&quot;&gt;&lt;a href=&quot;#构建原理及使用到的技术点&quot; class=&quot;headerlink&quot; title=&quot;构建原理及使用
    
    </summary>
    
      <category term="Objective-C" scheme="http://XibHe.github.io/categories/Objective-C/"/>
    
    
      <category term="二次筛选" scheme="http://XibHe.github.io/tags/%E4%BA%8C%E6%AC%A1%E7%AD%9B%E9%80%89/"/>
    
      <category term="NSArray enumerate" scheme="http://XibHe.github.io/tags/NSArray-enumerate/"/>
    
  </entry>
  
  <entry>
    <title>重构webView页面间跳转逻辑</title>
    <link href="http://XibHe.github.io/2017/08/07/reconsiderUrlPush/"/>
    <id>http://XibHe.github.io/2017/08/07/reconsiderUrlPush/</id>
    <published>2017-08-06T16:00:00.000Z</published>
    <updated>2017-10-14T02:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在处理webView页面内的跳转逻辑时，需要在当前webView中点击某个按钮push到另一个webView页，在这个新的webView页中仍然可以操作页面上的点击事件，跳转到其他webView页面。于是，这些webView页面可以相互跳转，不断跳转新的或者之前的webView页面。</p>
<h1 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h1><p>点击商品进入到“商品详情”页(GoodInforH5WebViewController)，点击店铺进入“店铺详情”页(ShopInfoH5WebViewController)，其中(“商品详情”页和”店铺详情”页均为webView)。其中，店铺详情页和商品详情页可以相互跳转。</p>
<h1 id="当前逻辑"><a href="#当前逻辑" class="headerlink" title="当前逻辑"></a>当前逻辑</h1><p>在继承于UINavigationController的自定义导航控制器MyNavigationController里做判断，重写方法:</p>
<pre><code class="objectivec">- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated
{
    if (self.viewControllers.count &gt; 0)
    {
        if ([self respondsToSelector:@selector(interactivePopGestureRecognizer)])
        {
            self.interactivePopGestureRecognizer.delegate = nil;
        }
        viewController.hidesBottomBarWhenPushed = YES;
        if ([viewController isKindOfClass:[GoodInforH5WebViewController class]] || [viewController isKindOfClass:[ShopInfoH5WebViewController class]]) {
            viewController.navigationItem.leftBarButtonItem = [UIBarButtonItem itemWithTarget:self action:@selector(backRootViewController) image:@&quot;navigation_back&quot; highlightImage:@&quot;navigation_back&quot;];
        }
    }     
   [super pushViewController:viewController animated:YES];
}
</code></pre>
<p>重写GoodInforH5WebViewController和ShopInfoH5WebViewController的返回事件。即，backRootViewController。在backRootViewController方法里做相应页面的跳转操作。</p>
<p>在GoodInforH5WebViewController页面的viewWillAppear方法里进行页面跳转逻辑的判断。如下:</p>
<font color="#DC143C"> 前方高能预警!!! </font>

<pre><code class="objectivec">- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];
    [self.navigationController setNavigationBarHidden:NO animated:NO];

    //[_webView reload];
    CLog(@&quot;self.navigationController.viewControllers count = %ld&quot;,[self.navigationController.viewControllers count]);
    CLog(@&quot;self.navigationController.viewControllers = %@&quot;,self.navigationController.viewControllers);
    // 若是经首页;分类列表页面;订单中心;商业店铺列表页;我的收藏,且viewControllers&lt;5,则设置pop回上一页的标识;商家促销,且viewControllers&lt;5,则设置pop回上一页的标识
    if ([_fromWebUrl isEqualToString:@&quot;home_bussinessUrl&quot;] || ([_fromWebUrl isEqualToString:@&quot;assortment_searchByCate&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) ||
        [_fromWebUrl isEqualToString:@&quot;sellOrderCenter_buyOrders&quot;] || 
        ([_fromWebUrl isEqualToString:@&quot;My_collectionListUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) ||
         [_fromWebUrl isEqualToString:@&quot;businessShopSearchList_goodInfo&quot;] ||  
         ([_fromWebUrl isEqualToString:@&quot;ActivityViewController&quot;] &amp;&amp; 
         [self.navigationController.viewControllers count] &lt; 5)  || ([_fromWebUrl isEqualToString:@&quot;BusinessPromoteViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5)) {
        [[NSUserDefaults standardUserDefaults] setObject:@&quot;1&quot; forKey:KPopHomeIndentify];
        [[NSUserDefaults standardUserDefaults] synchronize];
    } else if (([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 5) || [_fromWebUrl isEqualToString:@&quot;search_searchByKey&quot;] || [_fromWebUrl isEqualToString:@&quot;business_shopSearch&quot;] || ([_fromWebUrl isEqualToString:@&quot;home_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 6) || [_fromWebUrl isEqualToString:@&quot;businessShopSearchList_shopInfo&quot;] || ([_fromWebUrl isEqualToString:@&quot;home_productDetailUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 4) || ([_fromWebUrl isEqualToString:@&quot;ShopCarListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 4)){
        // 从GoodsListViewController跳转至原生商品详情页面;从顶部搜索等页面跳转至原生商品详情页面; 从商业店铺搜索结果列表页跳转,点击返回至self.viewControllers[2]的页面;若是从搜索首页，分类的搜索结果页跳转而来,返回搜索商品列表页;若是从商业店铺列表页跳转而来，则返回到店铺详情的H5页面;从首页商品--&gt;商品详情--&gt;店铺详情--&gt;商品详情，并且viewControllers&gt;=4，则返回店铺详情页;从原生购物车跳转而来,且viewControllers&gt;=4，则返回店铺详情页;
        [[NSUserDefaults standardUserDefaults] setObject:@&quot;2&quot; forKey:KPopHomeIndentify];
        [[NSUserDefaults standardUserDefaults] synchronize];
    } else if (([_fromWebUrl isEqualToString:@&quot;shopInfor_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &lt; 7) || ([_fromWebUrl isEqualToString:@&quot;assortment_searchByCate&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;My_collectionListUrl&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;ActivityViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 5) || ([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] == 5)) {
        // 若是从商业店铺详情搜索跳转而来;若是从分类列表页跳转而来;若是从我的收藏跳转而来，且viewControllers&gt;=5，则返回店铺详情页面。
        [[NSUserDefaults standardUserDefaults] setObject:@&quot;3&quot; forKey:KPopHomeIndentify];
        [[NSUserDefaults standardUserDefaults] synchronize];
    } else if (([_fromWebUrl isEqualToString:@&quot;home_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 6) || ([_fromWebUrl isEqualToString:@&quot;GoodsListViewController&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 6)) {
        // 从搜索商品列表--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=6，则返回店铺详情页；从订单详情页--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=6，则返回店铺详情页；
        [[NSUserDefaults standardUserDefaults] setObject:@&quot;4&quot; forKey:KPopHomeIndentify];
        [[NSUserDefaults standardUserDefaults] synchronize];
    } else if ([_fromWebUrl isEqualToString:@&quot;shopInfor_searchVC&quot;] &amp;&amp; [self.navigationController.viewControllers count] &gt;= 7) {
        // 从搜索商品列表--&gt;商品详情--&gt;店铺详情--&gt;商品详情,且viewControllers&gt;=7，则返回店铺详情页。
        [[NSUserDefaults standardUserDefaults] setObject:@&quot;5&quot; forKey:KPopHomeIndentify];
        [[NSUserDefaults standardUserDefaults] synchronize];
    }
    else {
        [[NSUserDefaults standardUserDefaults] setObject:@&quot;0&quot; forKey:KPopHomeIndentify];
        [[NSUserDefaults standardUserDefaults] synchronize];
    }
}
</code></pre>
<p>这里是通过设置一个名为KPopHomeIndentify的NSUserDefaults对象用于存储navigationController中，当前页面的层级。通过设置一个名为_fromWebUrl的字符串，用于判断是哪个页面跳转而来的。二者结合起来，设置经过GoodInforH5WebViewController页面的返回逻辑。</p>
<p>当触发商品详情页的跳转链接时，需要在webView的shouldStartLoadWithRequest代理方法里做判断，当request的绝对地址中包含店铺详情的路径时，则push到店铺详情页。如下:</p>
<pre><code class="objectivec">#pragma mark - UIWebViewDelegate
-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
{
    _absoluteUrl = [request.URL absoluteString];

    // push到店铺详情页面
    if ([_absoluteUrl rangeOfString:@&quot;appLink/showBusyInfo?&quot;].location != NSNotFound) {

        ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init];
        shopInforH5WebVC.webUrl = _absoluteUrl;
        shopInforH5WebVC.fromWebUrl = _fromWebUrl;
        [self.navigationController pushViewController:shopInforH5WebVC animated:YES];

        return NO;
    } else {
        return YES;
    }
}
</code></pre>
<p>再回到自定义导航控制器MyNavigationController重写的返回事件中:</p>
<pre><code class="objectivec">- (void)backRootViewController
{
    CLog(@&quot;self.viewControllers = %@&quot;,self.viewControllers);
    NSString *popIndentify = [[NSUserDefaults standardUserDefaults] objectForKey:KPopHomeIndentify];
    UIViewController *viewCtl;
    if ([popIndentify isEqualToString:@&quot;0&quot;]) {
        viewCtl = self.viewControllers[0];
    } else if ([popIndentify isEqualToString:@&quot;1&quot;]) {
        viewCtl = self.viewControllers[1];
    } else if ([popIndentify isEqualToString:@&quot;2&quot;]) {
        viewCtl = self.viewControllers[2];
    } else if ([popIndentify isEqualToString:@&quot;3&quot;]) {
        viewCtl = self.viewControllers[3];
    } else if ([popIndentify isEqualToString:@&quot;4&quot;]) {
        viewCtl = self.viewControllers[4];
    } else if ([popIndentify isEqualToString:@&quot;5&quot;]) {
        viewCtl = self.viewControllers[5];
    }
    [self popToViewController:viewCtl animated:YES];
}
</code></pre>
<p>同样是结合GoodInforH5WebViewController中设置好的KPopHomeIndentify进行判断。根据KPopHomeIndentify存储的导航控制器中的页面层级，在导航控制器中通过这些层级获取到对应的页面viewController，最后popToViewController到这些页面中。</p>
<h1 id="重构原因"><a href="#重构原因" class="headerlink" title="重构原因"></a>重构原因</h1><p>看了上面那一片高能预警的代码逻辑，重构原因就不言而喻了。</p>
<blockquote>
<p>*逻辑判断复杂，每次新增与商品详情，店铺详情相关页面时，都需要新增一系列对应页面层级的判断逻辑；</p>
<p>*给调试造成困难，与商品详情，店铺详情关联的页面很多，需要进行多场景的关联测试；</p>
<p>*最重要的一点:每次从商品详情页跳转到店铺详情都需要重新重新alloc一个新的ShopInfoH5WebViewController对象，耗费了很多资源。</p>
</blockquote>
<h1 id="重构逻辑"><a href="#重构逻辑" class="headerlink" title="重构逻辑"></a>重构逻辑</h1><p>通过设置NSUserDefaults存储页面层级方式进行页面跳转的逻辑，不易操纵，并且非常的不合理，也降低了代码的可读性。设想一下，这里之所以明确不同跳转页面在navigationController中的层级关系，是为了返回操作能回退到指定页面。而导致该冗余代码的罪魁祸首是:每次触发商品详情页或店铺详情页的跳转链接时，都会重新alloc一个新的对象。在进行多次跳转操作后，navigationController中控制的层级就会一直增加，若想在pop操作时跳转到指定页面，就必须明确所要跳转页面在导航控制器中的层级。</p>
<p>那接下来的操作就很明确了，首先移除GoodInforH5WebViewController中viewWillAppear里的一堆判断代码；然后，在webView的代理方法shouldStartLoadWithRequest中增加跳转判断，如下:</p>
<pre><code class="objectivec">#pragma mark - UIWebViewDelegate
-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
{
    _absoluteUrl = [request.URL absoluteString];
    CLog(@&quot;_absoluteUrl = %@&quot;,_absoluteUrl);
        // push到商业店铺详情页面
    if ([_absoluteUrl rangeOfString:@&quot;appLink/showBusyInfo?&quot;].location != NSNotFound) {
        UIViewController *shopInfoH5WebViewController;
        for (shopInfoH5WebViewController in self.navigationController.viewControllers) {
            if ([shopInfoH5WebViewController isKindOfClass:[ShopInfoH5WebViewController class]]) {
                //                addExtractBankCardVCIndex = [self.navigationController.viewControllers indexOfObject:addExtractBankCardVC];
                [self.navigationController popToViewController:shopInfoH5WebViewController animated:YES];
                break;
            } else if ([shopInfoH5WebViewController isKindOfClass:[GoodInforH5WebViewController class]]) {
                ShopInfoH5WebViewController *shopInforH5WebVC = [[ShopInfoH5WebViewController alloc] init];
                shopInforH5WebVC.webUrl = _absoluteUrl;
                shopInforH5WebVC.fromWebUrl = _fromWebUrl;
                [self.navigationController pushViewController: shopInforH5WebVC animated:YES];
                break;
            }
       }       
       return NO;  
   } else {
       return YES;
   }    
}
</code></pre>
<p>这里遍历navigationController.viewControllers中所有视图控制器。如果存在店铺详情(ShopInfoH5WebViewController)对象类，则直接popToViewController到该控制器中；如果不存在，则alloc一个新的店铺详情(ShopInfoH5WebViewController)，并pushViewController到该页面。</p>
<p>最后仍然需要在自定义导航控制器MyNavigationController重写的返回事件（backRootViewController）中做跳转的逻辑判断。如下:</p>
<pre><code class="objectivec">- (void)backRootViewController
{
    CLog(@&quot;self.viewControllers = %@&quot;,self.viewControllers);
    // 当前视图控制器
    UIViewController *currentVC = [self.viewControllers lastObject];
    // 视图控制器的层级
    NSInteger currentVCIndex = [self.viewControllers indexOfObject:currentVC];
    // 上一个页面的视图控制器
    UIViewController *previousVC = self.viewControllers[currentVCIndex - 1];
    if ([currentVC isKindOfClass:[GoodInforH5WebViewController class]]) {
        if ([previousVC isKindOfClass:[ShopInfoH5WebViewController class]]) {
            [self popToViewController:previousVC animated:YES];
        } else {
            [self popViewControllerAnimated:YES];
        }
    } else if ([currentVC isKindOfClass:[ShopInfoH5WebViewController class]]) {
    // 其他会跳转到店铺页面视图的跳转逻辑
        UIViewController *previoussLastVC;
        if ((currentVCIndex - 2) &gt;= 0) {
           previoussLastVC = self.viewControllers[currentVCIndex - 2];
        } else {
            previoussLastVC = [self.viewControllers firstObject];
        }
        if ([previousVC isKindOfClass:[GoodInforH5WebViewController class]] ) {
            // 我的积分跳转
            if ([previoussLastVC isKindOfClass:[OrderDetailsViewController class]]) {
                [self popToViewController:previoussLastVC animated:YES];
            }
            // 我的收藏
            else if ([previoussLastVC isKindOfClass:[MyCollectionViewController class]]) {
                [self popToViewController:previoussLastVC animated:YES];
            }
            // 分类
            else if ([previoussLastVC isKindOfClass:[LonchH5WebController class]] &amp;&amp; [self.viewControllers[0] isKindOfClass:[AssortmentViewController class]]) {
                [self popToViewController:previoussLastVC animated:YES];
            }
            // 首页，分类搜索结果页
            else if ([previoussLastVC isKindOfClass:[SearchResultViewController class]]) {
                [self popToViewController:previoussLastVC animated:YES];
            }
            else {
                [self popToRootViewControllerAnimated:YES];
            }
        } else {
            [self popViewControllerAnimated:YES];
        }
     }      
}
</code></pre>
<p>这里通过获取当前页面层级，以及当前页面上一个页面的层级，通过这些层级做相应的跳转操作:</p>
<blockquote>
<p>如果当前页面是商品详情页(GoodInforH5WebViewController)，再进一步判断它的上个页面是否为店铺详情页(ShopInfoH5WebViewController)，若是则popToViewController到上个页面，否则直接popViewControllerAnimated；</p>
<p>如果当前页面是店铺详情页(ShopInfoH5WebViewController)，则需要判断当前视图层级是否越界(当前页面层级currentVCIndex不会超过3级，可能会遇到导航控制器中只有1个视图控制器的情况)，这里与商品详情页不同的是:增加了其它会跳转到店铺页面视图的跳转逻辑。需要对这些页面（积分、我的收藏、分类、搜索结果页）的跳转进行判断。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事不过三，过则重构!</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在处理webView页面内的跳转逻辑时，需要在当前webView中点击某个按钮push到另一个webView页，在这个新的webView页中仍然可以操作页面上的点击事件，跳转到其他webView页面。于是，这些webView页面可以相互跳转，不断跳转新的或者之前的webVi
    
    </summary>
    
      <category term="Objective-C" scheme="http://XibHe.github.io/categories/Objective-C/"/>
    
    
      <category term="重构" scheme="http://XibHe.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>(译)一个给iOS App瘦身的奇怪窍门</title>
    <link href="http://XibHe.github.io/2017/07/23/One%20Weird%20Trick%20to%20Lose%20Size/"/>
    <id>http://XibHe.github.io/2017/07/23/One Weird Trick to Lose Size/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2017-10-14T02:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>流行的社交网络应用程序超过400M。每周更新一次，每年你下载的应用总量接近20G。</p>
<p>自从我们推出了<a href="https://halide.cam" target="_blank" rel="external">Halide</a>，我们听到的最令人意想不到的赞美就是它的大小。 在11M，我们将在一年内推出较少数据的更新，而不是社交网络应用进行频繁更新。</p>
<p><img src="http://odchyrav4.bkt.clouddn.com/LoseSizeMajor.png" alt=""><br>一个朋友问道：“所以你没有使用Swift。” 毕竟，Swift将其标准库捆绑到你的应用程序中，使应用大小增大。 Halide几乎完全是使用Swift编写的。</p>
<p>我们是怎么做的？ 我们从技术位开始吧。 <a href="https://developer.apple.com/library/content/qa/qa1795/_index.html" target="_blank" rel="external">这里</a>有很多关于如何减少App大小的重要评论。</p>
<h2 id="测量，不要猜"><a href="#测量，不要猜" class="headerlink" title="测量，不要猜"></a>测量，不要猜</h2><p>从Xcode导出版本构建。 选择“Save for Ad Hoc deployment.”。假设你的应用程序支持<a href="https://developer.apple.com/videos/play/wwdc2015/404/" target="_blank" rel="external">app thinning</a>（此时真的应该这样做），请选择“Export for Specific Devices.”。确保选中“<font size="4" face="黑体"> Rebuild from bitcode </font>”。</p>
<p>你不仅可以获得最终包的大小，还可以获得App Thinning报告。检查你的应用程序包，找到最大存储空间的占用者。</p>
<h2 id="使用-Asset-Catalogs"><a href="#使用-Asset-Catalogs" class="headerlink" title="使用 Asset Catalogs"></a>使用 Asset Catalogs</h2><p>将资源保存在资源目录中。当你上传应用程序时，Apple将其分解为特定设备的版本，因此具有2x屏幕的设备不会获得3x资源，反之亦然。</p>
<h2 id="运行-PNG-crush"><a href="#运行-PNG-crush" class="headerlink" title="运行 PNG-crush"></a>运行 PNG-crush</h2><p>将资源放入目录之前，请运行pngcrush。 根据<a href="https://developer.apple.com/library/content/qa/qa1681/_index.html" target="_blank" rel="external">QA1681</a>，Xcode将自动压缩资源目录之外的PNG资源。</p>
<h2 id="尝试JPEG格式照片"><a href="#尝试JPEG格式照片" class="headerlink" title="尝试JPEG格式照片"></a>尝试JPEG格式照片</h2><p>由于UI资源格式限制以及PNG格式资源更加精细。这可能构成了你应用程序中大部分资源，但如果你有照片，请尝试使用JPEG格式。这样做会有些压力。</p>
<h1 id="现在进入到一个困难步骤的实现"><a href="#现在进入到一个困难步骤的实现" class="headerlink" title="现在进入到一个困难步骤的实现"></a>现在进入到一个困难步骤的实现</h1><p>经过这么辛苦的工作，你只能删掉一个100M项目中几M的文件。我不知道如何告诉你，但你需要更少的代码。</p>
<h2 id="选择正确的方式"><a href="#选择正确的方式" class="headerlink" title="选择正确的方式"></a>选择正确的方式</h2><p>Halide有大概15000行用Swift编写的代码。这包括一个实时视频处理器，一系列自定义控件，以及我们控制AVFoundation的平台。有趣的是我并没有写代码。</p>
<p>通过使用自动布局，我绘制了数千条样板。许多开发人员仍然坚持手工布局。也许他们不明白自动布局，也许他们听到朋友的朋友关于自动布局如何缓慢的言论。（事实并非如此。）</p>
<p>我看到太多的开发人员 - 特别是在大型公司 - 发明内部布局引擎。这简直太疯狂了。当Apple在操作系统上捆绑一个精细的布局引擎时，不要用自己定制的框架来增大应用程序。</p>
<p>我们可以通过删除Interface Builder来减少100k。用户手册和设置几乎完全是具有约束条件的IB。相机UI的高级布置也类似如此。但我们认为短期内开发进度是值得肯定的。</p>
<h2 id="避免Library过大"><a href="#避免Library过大" class="headerlink" title="避免Library过大"></a>避免Library过大</h2><p>检查许多大型应用程序的包，你会发现几十个第三方框架，大小从100k到几兆。</p>
<p>我不使第三方库。这虽然有点极端，但我们有一个独特的情况。</p>
<p>很多第三方库不具备我们所需要的功能。iOS开发社区拥有大量的JSON映射器，但对于DNG文件的低级操作没有任何意义。</p>
<p>但是我之前提到的视频处理呢？我可以听到你大声喊叫，“GPUImage是可扩展的！你的做法太疯狂了!”</p>
<p>从我对Periscope的堆栈的<a href="https://news.realm.io/news/building-periscope-sketches-ios/" target="_blank" rel="external">经验</a>来看，我们看到从GPUImage到内部解决方案的巨大收益。如果实时图像处理不是你业务的一部分，GPUImage就会很好。但是鉴于我们对Halide的长期愿景，以及实时渲染的作用，重要的是能掌控这样的组件。</p>
<p>由于文件太大，我从未引入过GPUImage。但是作为自己疯狂的结果，我避免了在我们的应用程序中捆绑125个未使用的过的滤镜。</p>
<p>PSPDFKit具有相似的<a href="https://pspdfkit.com/blog/2017/pspdfkit-ios-6-8/" target="_blank" rel="external">成功经验</a>，取代了太大的框架：</p>
<blockquote>
<p>我们很高兴地告诉你，使用PSPDFKit 6.8 for iOS，我们重写了数字签名实施的核心，以改进检测，验证和更好的错误报告。因此，我们也设法完全放弃了对OpenSSL的依赖，从而减少了二进制文件的大小。</p>
</blockquote>
<p>不要感染 Not-Invented-Here 综合征，有<a href="https://sandofsky.com/blog/third-party-libraries.html" target="_blank" rel="external">很多理由</a>来避免使用三方库。</p>
<h2 id="不要在分析和A-B测试中浪费资源"><a href="#不要在分析和A-B测试中浪费资源" class="headerlink" title="不要在分析和A / B测试中浪费资源"></a>不要在分析和A / B测试中浪费资源</h2><p>我们不会使用任何第三方分析或崩溃报告服务。首先，我们不是很乐意将用户数据发送给广告公司。让我们暂停这样的想法。</p>
<p>数据不是免费的。在大型应用中，每个动作都会记录一个分析事件。大型应用程序需要日志记录基础设施 - 唯一标识用户，重复数据删除请求，缓存日志，重试失败等。这些操作都会进行叠加。</p>
<p>A / B测试更糟糕。你的典型社交网络应用程序由于没有人使用而死在的A / B测试上。</p>
<p>我们出于代码膨胀的考虑避免了分析和A / B测试。这只是我们的产品理念。知道太多的数据会扭曲你的想法。你发现自己在优化某个不存在的特殊场景，而不是真的去关注用户实际会不会有这样的需求。</p>
<p>所以我们使用苹果分析。它只是简单的记录，没有任何代码更改。并且免费。它尊重用户的隐私，需要选择加入。我们的选择加入率为32％，这对我们的需求是很好的。</p>
<p>有分析的时间和地点。我们不确定我们的最优价格，所以我们可以在那里进行实验。然而，我们在业务驱动的分析和产品开发之间保持隔离。</p>
<h1 id="你需要一致的目标"><a href="#你需要一致的目标" class="headerlink" title="你需要一致的目标"></a>你需要一致的目标</h1><p>我们是一个两个人的开发团队。我们通过销售产品赚钱。我们顺其自然的成长。当用户高兴时，他们会向朋友们推荐我们。小应用让我们开心，我们认为用户也很开心。</p>
<p>我们的建议并不能帮助应用程序包很大的App。社交网络通过广告赚钱，广告客户需要详细的分析广告定位。</p>
<p>大型应用程序拥有数百名开发人员，组成数十个团队，每个团队都有独立的季度目标。 你走的越快，你达成的目标越多，你的晋升越有可能。</p>
<p>想想这是可以理解的，“这个三方库节省了我们一个星期的开发时间，但是在我们的应用程序中增加了1M。那么我们的App已经是几百M了，还有其它办法吗？”</p>
<p>大型组织充满带来意想不到后果的合理想法。</p>
<p>据说工程师想得到提升。输送功能不会让你达到目的。建立一个新的布局引擎。该公司甚至获得了工程博客的招聘诱饵。</p>
<p>唯一的解决方案是高层领导宣布：“我们将减少我们的应用程序大小。”不幸的是，科技CEO们不会使用8G的储存空间的iPhone，他们不会生活在网速受限的地区。</p>
<p>这不是一个毫不费力的努力。自从Halide发布以来，我们收到了来自世界各地的大量消息，感谢我们努力保持App的小巧。</p>
<p>减小App安装包大小真的有一个奇怪的伎俩：专注于你的客户。</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://blog.halide.cam/one-weird-trick-to-lose-size-c0a4013de331" target="_blank" rel="external">One Weird Trick to Lose Size</a></p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流行的社交网络应用程序超过400M。每周更新一次，每年你下载的应用总量接近20G。&lt;/p&gt;
&lt;p&gt;自从我们推出了&lt;a href=&quot;https://halide.cam&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Halide&lt;/a&gt;，我们听到的最令人意想
    
    </summary>
    
      <category term="译文" scheme="http://XibHe.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="译文" scheme="http://XibHe.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="App瘦身" scheme="http://XibHe.github.io/tags/App%E7%98%A6%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>第一个父亲节</title>
    <link href="http://XibHe.github.io/2017/06/18/First-father&#39;s-day/"/>
    <id>http://XibHe.github.io/2017/06/18/First-father&#39;s-day/</id>
    <published>2017-06-17T16:00:00.000Z</published>
    <updated>2017-10-14T02:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>我和妻子是大学同学，在恋爱长跑五年后结了婚。妻子老家不是我们那边的，但是在同一个省，最开始的地域原因，造成了我家人对她的偏见。我们俩克服了种种阻碍，在15年情人节那天领了证。</p>
<p>我们的小孩比计划来的早，妻子一直很期待在猴年能生一个聪明伶俐的猴宝宝。当得知自己要作父亲的那一天，内心感受是复杂的，有期待，也有忐忑。觉得自己没有做好成为一个父亲的准备。伴随着孩子快要出生，我的这种焦虑感越发的明显了。在妻子待产期间，没有全身心的去照顾她，总是把工作中的压力和不快带到家里。终于，在一个周三的早上爆发了…… 最后，还是妻子在妻子的安慰下，我才渐渐平复了自己的心情。</p>
<p>由于老家人和妻子之间的矛盾，再加上我父母都不在老家，不能照顾快要临产的妻子。最终选择在我妻子老家待产。孩子出生那天的凌晨十二点多，那时我并不在妻子身边，电话那头当妻子告诉我小家伙出生了，是个男孩时，我就再也控制不住自己的激动，惊喜，幸福的感情了。当得知妻子由于羊水不足而剖腹产时，听着电话一头，妻子有气无力的声音。当时真想给自己一巴掌，我没有尽到作丈夫的责任，在妻子临盆时不能陪在她身边，给她鼓励，让她安心。还让我岳母，一个50多岁，腿脚不便利的老人家为我妻子跑前跑后，楼上楼下的张罗妻子生产的一切事宜。</p>
<p>像我这样的渣男竟然还有女人给我生孩子，把自己的终身幸福托付给我。我上辈子一定是积了什么大功德了！无法忘记第一次见到小家伙的场景，他紧握着一双小手，眼睛半闭半睁，好奇的打量着周围的一切。虽然我嘴上一直在埋怨小家伙让他妈妈挨了一刀，但心里还是对他充满了怜爱。唯一遗憾的是，陪在她们母子身边的时间太短，不等小家伙满月我就不得不离开她们母子俩，带着不舍与留恋重新投入到工作中。</p>
<p>这次端午节回家，小家伙给了我一个大大的惊喜。刚一见面，盯着看了我半天，然后就用一双小手抚摸我的脸，最后，嘿嘿一笑，扑到我的怀里。那一刻，时间仿佛静止，而我又找到了初恋的感觉[害羞]。这不禁又让我感慨了一番：不能时刻陪在你身边，经历你的成长，听到你第一次喊爸爸。终究是我无法弥补的遗憾。这里不奢望能得到你的原谅，只希望将来的某一天你能理解。成年人的生活里没有容易二字。爱❤你我的小宝贝！            </p>
<p>再过一个多月我们家宝宝就一岁了，这一年来我经历了很多，也成长了很多。感谢妻子的宽容和奉献，她总是迁就我的时不时就发作的小情绪，安慰我，鼓励我，支持我。尽她最大的力量来爱我和儿子。爱❤你我的大宝贝！你和儿子就是我的一切，我的天下无双。</p>
<p>–EOF–</p>
<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我和妻子是大学同学，在恋爱长跑五年后结了婚。妻子老家不是我们那边的，但是在同一个省，最开始的地域原因，造成了我家人对她的偏见。我们俩克服了种种阻碍，在15年情人节那天领了证。&lt;/p&gt;
&lt;p&gt;我们的小孩比计划来的早，妻子一直很期待在猴年能生一个聪明伶俐的猴宝宝。当得知自己要作
    
    </summary>
    
      <category term="随笔" scheme="http://XibHe.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="父亲节" scheme="http://XibHe.github.io/tags/%E7%88%B6%E4%BA%B2%E8%8A%82/"/>
    
  </entry>
  
</feed>
